This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/*.log, tmp/, **/Illustrations/**, **/*.json, **/Localization.ts, **/SVGS/**, **/generated/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
apps/
  merchant-app/
    app/
      _layout.tsx
      +not-found.tsx
      index.tsx
    components/
      dashboard/
        AlertRow.tsx
        AlertsCard.tsx
        DashboardHeader.tsx
        PrepCard.tsx
        StatsGrid.tsx
      layout/
        index.ts
        ScreenContainer.tsx
        SearchOverlay.tsx
      ui/
        Avatar.tsx
        Badge.tsx
        Box.tsx
        Button.tsx
        Card.tsx
        index.ts
        Tabs.tsx
        Text.tsx
    constants/
      Colors.ts
      Spacing.ts
      theme.ts
      Typography.ts
    hooks/
      useColorScheme.ts
      useColorScheme.web.ts
      useTheme.ts
      useThemeColor.ts
    .gitignore
    types.ts
.gitignore
.npmrc
.nvimrc
pnpm-workspace.yaml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="apps/merchant-app/components/dashboard/AlertsCard.tsx">
import React from "react";
import { StyleSheet, Pressable, View } from "react-native";
import Animated, {
	FadeInUp,
	FadeOutDown,
	useAnimatedStyle,
	useSharedValue,
	withTiming,
} from "react-native-reanimated";
import { Ionicons } from "@expo/vector-icons";
import { AnimatedBox, Box, Text } from "@/components/ui";
import { AppTheme } from "@/hooks/useTheme";
import { Alert } from "@/types";
interface AlertsCardProps {
	alerts: Alert[];
	theme: AppTheme;
	onViewAlert: (id: string | number) => void;
	onViewAllAlerts?: () => void;
}
export const AlertsCard: React.FC<AlertsCardProps> = React.memo(
	({ alerts, theme, onViewAlert, onViewAllAlerts }) => {
		const hasAlerts = alerts.length > 0;
		return (
			<AnimatedBox
				entering={FadeInUp.delay(350).duration(400).springify().damping(15)}
				exiting={FadeOutDown.duration(200)}
				bg="card"
				rounded="lg"
				marginHorizontal="md"
				marginBottom="lg"
				elevation="small"
				style={{ overflow: "hidden" }}
			>
				<Box
					row
					justifyContent="space-between"
					alignItems="center"
					marginBottom="md"
					paddingHorizontal="md"
					paddingTop="md"
				>
					<Text variant="lg" weight="semibold">
						Alerts
					</Text>
					{hasAlerts && (
						<Animated.View>
							<Pressable
								onPress={onViewAllAlerts}
								style={({ pressed }) => [
									{
										paddingVertical: theme.spacing.xs,
										paddingHorizontal: theme.spacing.sm,
										borderRadius: theme.radius.sm,
										backgroundColor: pressed
											? theme.colors.primaryLight
											: undefined,
										transform: [{ scale: pressed ? 0.96 : 1 }],
									},
								]}
							>
								<Text variant="sm" color="primary" weight="medium">
									View all
								</Text>
							</Pressable>
						</Animated.View>
					)}
				</Box>
				{hasAlerts ? (
					<Box>
						{alerts.map((alert, index) => (
							<AlertItem
								key={alert.id}
								alert={alert}
								theme={theme}
								onPress={() => onViewAlert(alert.id)}
								isLast={index === alerts.length - 1}
							/>
						))}
					</Box>
				) : (
					<Box
						alignCenter
						paddingVertical="lg"
						paddingHorizontal="md"
						bg="backgroundAlt"
						style={{
							borderBottomLeftRadius: theme.radius.lg,
							borderBottomRightRadius: theme.radius.lg,
						}}
					>
						<Box
							rounded="round"
							bg="primaryLight"
							padding="md"
							marginBottom="md"
							style={{
								width: theme.sizes.avatarLg,
								height: theme.sizes.avatarLg,
								alignItems: "center",
								justifyContent: "center",
							}}
						>
							<Ionicons
								name="checkmark-circle"
								size={theme.sizes.iconMd}
								color={theme.colors.primary}
							/>
						</Box>
						<Text color="textSecondary" center>
							You're all caught up!
						</Text>
						<Text color="textMuted" variant="sm" center marginTop="xs">
							No pressing alerts at the moment
						</Text>
					</Box>
				)}
			</AnimatedBox>
		);
	},
);
interface AlertItemProps {
	alert: Alert;
	theme: AppTheme;
	onPress: () => void;
	isLast?: boolean;
}
const AlertItem: React.FC<AlertItemProps> = React.memo(
	({ alert, theme, onPress, isLast = false }) => {
		const iconColor = theme.colors[alert.type];
		const pressed = useSharedValue(0);
		const handlePressIn = () => {
			pressed.value = withTiming(1, { duration: 100 });
		};
		const handlePressOut = () => {
			pressed.value = withTiming(0, { duration: 200 });
		};
		const animatedStyle = useAnimatedStyle(() => {
			return {
				transform: [
					{
						scale: withTiming(pressed.value === 1 ? 0.98 : 1, {
							duration: pressed.value === 1 ? 100 : 200,
						}),
					},
				],
				backgroundColor:
					pressed.value === 1 ? theme.colors.backgroundAlt : "transparent",
			};
		});
		return (
			<Animated.View
				style={[
					{
						borderBottomWidth: isLast ? 0 : StyleSheet.hairlineWidth,
						borderBottomColor: theme.colors.divider,
					},
					animatedStyle,
				]}
			>
				<Pressable
					onPress={onPress}
					onPressIn={handlePressIn}
					onPressOut={handlePressOut}
					style={{
						flexDirection: "row",
						alignItems: "center",
						padding: theme.spacing.md,
					}}
					android_ripple={{ color: theme.colors.overlay }}
				>
					<View
						style={{
							width: theme.sizes.buttonSm,
							height: theme.sizes.buttonSm,
							borderRadius: theme.radius.round,
							alignItems: "center",
							justifyContent: "center",
							backgroundColor: theme.colors.primaryLight,
						}}
					>
						<Ionicons
							name={alert.icon as any}
							size={theme.sizes.iconSm}
							color={iconColor}
						/>
					</View>
					<Box flex={1} marginLeft="sm">
						<Text variant="sm" weight="medium" numberOfLines={1}>
							{alert.title}
						</Text>
						{alert.timestamp && (
							<Text
								variant="xs"
								color="textMuted"
								marginTop={theme.spacing.xs / 2}
							>
								{alert.timestamp}
							</Text>
						)}
					</Box>
					<Box
						marginLeft="sm"
						paddingVertical="xs"
						paddingHorizontal="sm"
						rounded="xs"
						bg="backgroundAlt"
					>
						<Text
							variant="xs"
							weight="medium"
							color={alert.type}
							numberOfLines={1}
						>
							{alert.type.charAt(0).toUpperCase() + alert.type.slice(1)}
						</Text>
					</Box>
				</Pressable>
			</Animated.View>
		);
	},
);
</file>

<file path="apps/merchant-app/components/dashboard/PrepCard.tsx">
import React from "react";
import { StyleSheet, Pressable } from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { Box, Text, Badge } from "@/components/ui";
import { AppTheme } from "@/hooks/useTheme";
import { MealPrepSummary } from "@/types";
interface TodayPrepCardProps {
	summary: MealPrepSummary;
	theme: AppTheme;
	onPress: () => void;
}
const MAX_MEALS_TO_SHOW = 3;
const PREP_CARD_WIDTH = 170;
export const TodayPrepCard: React.FC<TodayPrepCardProps> = React.memo(
	({ summary, theme, onPress }) => {
		const periodIcons = {
			Breakfast: "cafe-outline",
			Lunch: "restaurant-outline",
			Dinner: "fast-food-outline",
		};
		const periodColors: Record<
			"Breakfast" | "Lunch" | "Dinner",
			"info" | "primary" | "error"
		> = { Breakfast: "info", Lunch: "primary", Dinner: "error" };
		return (
			<Pressable
				onPress={onPress}
				style={({ pressed }) => [
					localStyles.prepCardContainer,
					{ borderRadius: theme.radius.lg },
					pressed && { opacity: 0.8 },
				]}
				android_ripple={{ color: theme.colors.overlay }}
			>
				<Box
					style={[
						localStyles.prepCard,
						{
							backgroundColor: theme.colors.card,
							borderRadius: theme.radius.lg,
							shadowColor: theme.colors.shadow,
						},
					]}
					elevation="small"
				>
					<Box row alignCenter marginBottom="sm">
						<Ionicons
							name={periodIcons[summary.period] as any}
							size={theme.sizes.iconSm}
							color={theme.colors[periodColors[summary.period]]}
							style={{ marginRight: theme.spacing.sm }}
						/>
						<Text variant="md" weight="semibold">
							{summary.period}
						</Text>
					</Box>
					<Text
						variant="sm"
						weight="medium"
						color="textSecondary"
						marginBottom="xs"
					>
						Prep List:
					</Text>
					<Box style={localStyles.prepListContainer}>
						{summary.mealsToPrep.slice(0, MAX_MEALS_TO_SHOW).map((meal) => (
							<Box
								key={meal.id}
								row
								justifyContent="space-between"
								paddingVertical={theme.spacing.xs / 1.5}
							>
								<Text
									variant="sm"
									numberOfLines={1}
									style={{ flexShrink: 1, marginRight: theme.spacing.sm }}
								>
									{meal.name}
								</Text>
								<Text variant="sm" weight="medium" color="textSecondary">
									{meal.count}
								</Text>
							</Box>
						))}
					</Box>
					<Box
						row
						justifyContent="space-between"
						alignItems="flex-end"
						paddingTop="sm"
					>
						<Badge
							text={`${summary.totalMeals} Total`}
							variant={periodColors[summary.period]}
							size="sm"
						/>
						{summary.mealsToPrep.length > MAX_MEALS_TO_SHOW && (
							<Text variant="xs" color="textMuted">
								+ {summary.mealsToPrep.length - MAX_MEALS_TO_SHOW} more
							</Text>
						)}
					</Box>
				</Box>
			</Pressable>
		);
	},
);
const localStyles = StyleSheet.create({
	prepCardContainer: { width: PREP_CARD_WIDTH },
	prepCard: { padding: 16, minHeight: 170, justifyContent: "space-between" },
	prepListContainer: { marginTop: 4, flexGrow: 1 },
});
</file>

<file path="apps/merchant-app/components/dashboard/StatsGrid.tsx">
import React from "react";
import { StyleSheet } from "react-native";
import Animated, {
	FadeInUp,
	FadeOutDown,
	LinearTransition,
} from "react-native-reanimated";
import { Ionicons } from "@expo/vector-icons";
import { Box, Text } from "@/components/ui";
import { AppTheme } from "@/hooks/useTheme";
interface StatItem {
	title: string;
	value: string | number;
	icon: string;
}
interface StatsGridProps {
	stats: StatItem[];
	theme: AppTheme;
}
const AnimatedBox = Animated.createAnimatedComponent(Box);
export const StatsGrid: React.FC<StatsGridProps> = React.memo(
	({ stats, theme }) => {
		return (
			<AnimatedBox
				layout={LinearTransition.delay(100).duration(300)}
				row
				marginHorizontal="md"
				marginBottom="lg"
			>
				{stats.map((stat, index) => (
					<AnimatedBox
						key={stat.title}
						entering={FadeInUp.duration(300)}
						exiting={FadeOutDown.duration(200)}
						layout={LinearTransition.duration(300)}
						flex={1}
						marginRight={index < stats.length - 1 ? "sm" : undefined}
					>
						<Box
							bg="card"
							padding="md"
							rounded="lg"
							elevation="small"
							style={localStyles.statCard}
						>
							<Box row alignCenter marginBottom="sm">
								<Box
									style={[
										localStyles.statIconContainer,
										{ borderRadius: theme.radius.sm },
									]}
									bg="primaryLight"
									marginRight="sm"
								>
									<Ionicons
										name={stat.icon as any}
										size={theme.sizes.iconSm}
										color={theme.colors.primary}
									/>
								</Box>
								<Text variant="sm" color="textSecondary">
									{stat.title}
								</Text>
							</Box>
							<Text variant="xl" weight="bold">
								{stat.value}
							</Text>
						</Box>
					</AnimatedBox>
				))}
			</AnimatedBox>
		);
	},
);
const localStyles = StyleSheet.create({
	statCard: {},
	statIconContainer: {
		width: 32,
		height: 32,
		alignItems: "center",
		justifyContent: "center",
	},
});
</file>

<file path="apps/merchant-app/constants/Colors.ts">
export const QarnColors = {
	light: {
		primary: "#22C55E",
		primaryDark: "#15803D",
		primaryLight: "#E5F6ED",
		background: "#F8FAF8",
		card: "#FFFFFF",
		cardAlt: "#F3F4F6",
		text: "#1C1D1F",
		textSecondary: "#6B7280",
		textMuted: "#9CA3AF",
		success: "#22C55E",
		warning: "#FFD60A",
		info: "#3B82F6",
		error: "#EF4444",
		divider: "#E5E7EB",
		overlay: "rgba(0,0,0,0.4)",
		shadow: "rgba(0,0,0,0.1)",
		tabBar: "#FFFFFF",
		tabIconDefault: "#9CA3AF",
		tabIconSelected: "#22C55E",
	},
	dark: {
		primary: "#22C55E",
		primaryDark: "#15803D",
		primaryLight: "#2C2C2E",
		background: "#0C0C0C",
		card: "#1C1C1E",
		cardAlt: "#2C2C2E",
		text: "#F2F2F7",
		textSecondary: "#8E8E93",
		textMuted: "#636366",
		success: "#22C55E",
		warning: "#FFD60A",
		info: "#3B82F6",
		error: "#EF4444",
		divider: "#38383A",
		overlay: "rgba(0,0,0,0.6)",
		shadow: "rgba(0,0,0,0.3)",
		tabBar: "#1C1C1E",
		tabIconDefault: "#8E8E93",
		tabIconSelected: "#22C55E",
	},
};
</file>

<file path="apps/merchant-app/constants/Spacing.ts">
export const QarnSpacing = {
	xs: 4,
	sm: 8,
	md: 16,
	lg: 24,
	xl: 32,
	xxl: 48,
	screenPadding: 16,
	cardPadding: 16,
	itemSpacing: 12,
	sectionSpacing: 24,
};
export const QarnRadius = {
	xs: 4,
	sm: 8,
	md: 12,
	lg: 16,
	xl: 24,
	round: 999,
	button: 12,
	card: 16,
	input: 12,
	badge: 12,
};
export const QarnSizes = {
	touchTarget: 44,
	smallTouchTarget: 36,
	iconXs: 16,
	iconSm: 20,
	iconMd: 24,
	iconLg: 32,
	buttonSm: 36,
	buttonMd: 44,
	buttonLg: 52,
	inputHeight: 48,
	headerHeight: 56,
	tabBarHeight: 49,
	avatarSm: 32,
	avatarMd: 44,
	avatarLg: 64,
};
</file>

<file path="apps/merchant-app/constants/Typography.ts">
export const QarnTypography = {
	sizes: {
		xs: 12,
		sm: 14,
		md: 16,
		lg: 18,
		xl: 20,
		xxl: 24,
		xxxl: 30,
	},
	weights: {
		regular: "400",
		medium: "500",
		semibold: "600",
		bold: "700",
		extrabold: "800",
	} as const,
	lineHeights: {
		tight: 1.2,
		normal: 1.5,
		loose: 1.8,
	},
};
export const QarnShadows = {
	light: {
		small: {
			shadowColor: "#000",
			shadowOffset: { width: 0, height: 1 },
			shadowOpacity: 0.1,
			shadowRadius: 2,
			elevation: 1,
		},
		medium: {
			shadowColor: "#000",
			shadowOffset: { width: 0, height: 2 },
			shadowOpacity: 0.1,
			shadowRadius: 4,
			elevation: 2,
		},
		large: {
			shadowColor: "#000",
			shadowOffset: { width: 0, height: 4 },
			shadowOpacity: 0.1,
			shadowRadius: 8,
			elevation: 4,
		},
	},
	dark: {
		small: {
			shadowColor: "#000",
			shadowOffset: { width: 0, height: 1 },
			shadowOpacity: 0.3,
			shadowRadius: 2,
			elevation: 1,
		},
		medium: {
			shadowColor: "#000",
			shadowOffset: { width: 0, height: 2 },
			shadowOpacity: 0.4,
			shadowRadius: 4,
			elevation: 2,
		},
		large: {
			shadowColor: "#000",
			shadowOffset: { width: 0, height: 4 },
			shadowOpacity: 0.5,
			shadowRadius: 8,
			elevation: 4,
		},
	},
};
</file>

<file path="apps/merchant-app/hooks/useColorScheme.ts">
export { useColorScheme } from 'react-native';
</file>

<file path="apps/merchant-app/hooks/useColorScheme.web.ts">
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);
  useEffect(() => {
    setHasHydrated(true);
  }, []);
  const colorScheme = useRNColorScheme();
  if (hasHydrated) {
    return colorScheme;
  }
  return 'light';
}
</file>

<file path="apps/merchant-app/hooks/useThemeColor.ts">
import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';
export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];
  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}
</file>

<file path="apps/merchant-app/.gitignore">
# @generated expo-cli sync-2b81b286409207a5da26e14c78851eb30d8ccbdb
# The following patterns were generated by expo-cli

expo-env.d.ts
# @end expo-cli
</file>

<file path="apps/merchant-app/types.ts">
export interface MealCount {
	name: string;
	count: number;
	id: string | number;
}
export interface MealPrepSummary {
	period: "Breakfast" | "Lunch" | "Dinner";
	totalMeals: number;
	mealsToPrep: MealCount[];
}
export interface Alert {
	id: string | number;
	type: "warning" | "info" | "error";
	title: string;
	icon: string;
	timestamp?: string;
}
export interface StatItem {
	title: string;
	value: string | number;
	icon: string;
}
export interface OverviewStats {
	activeSubscriptions: number;
	newThisWeek: number;
}
export interface QuickActionItem {
	label: string;
	icon: string;
	action: () => void;
}
</file>

<file path=".npmrc">
node-linker=hoisted
engine-strict=true
</file>

<file path="apps/merchant-app/app/+not-found.tsx">
import React from "react";
import { StyleSheet } from "react-native";
import { Stack, router } from "expo-router";
import { Ionicons } from "@expo/vector-icons";
import Animated, { FadeIn, FadeOut } from "react-native-reanimated";
import { useTheme } from "@/hooks/useTheme";
import { Text, Button } from "@/components/ui";
import { ScreenContainer } from "@/components/layout";
export default function NotFoundScreen() {
	const theme = useTheme();
	const handleGoHome = () => {
		router.replace("/");
	};
	return (
		<ScreenContainer scrollable={false} padded={false}>
			<Stack.Screen options={{ title: "Not Found", headerShown: false }} />
			<Animated.View
				style={[styles.container, { backgroundColor: theme.colors.background }]}
				entering={FadeIn.duration(300)}
				exiting={FadeOut.duration(200)}
			>
				<Ionicons
					name="alert-circle-outline"
					size={theme.sizes.iconLg * 2.5}
					color={theme.colors.textMuted}
					style={styles.icon}
				/>
				<Text variant="xxl" weight="bold" center marginBottom="sm">
					Oops! Page Not Found
				</Text>
				<Text variant="md" color="textSecondary" center marginBottom="xl">
					We can't seem to find the page you're looking for. It might have been
					moved or doesn't exist.
				</Text>
				<Button
					title="Go to Dashboard"
					onPress={handleGoHome}
					leftIcon="home-outline"
					size="lg"
				/>
			</Animated.View>
		</ScreenContainer>
	);
}
const styles = StyleSheet.create({
	container: {
		flex: 1,
		alignItems: "center",
		justifyContent: "center",
		padding: 16,
	},
	icon: {
		marginBottom: 24,
	},
});
</file>

<file path="apps/merchant-app/components/dashboard/DashboardHeader.tsx">
import React from "react";
import { View, Pressable, StyleSheet } from "react-native";
import Animated from "react-native-reanimated";
import { Ionicons } from "@expo/vector-icons";
import { Text } from "@/components/ui";
import { AppTheme } from "@/hooks/useTheme";
import { EdgeInsets } from "react-native-safe-area-context";
interface DashboardHeaderProps {
	theme: AppTheme;
	insets: EdgeInsets;
	animatedStyle: any;
	currentDateString: string;
	onSettingsPress: () => void;
	headerHeight: number;
}
export const DashboardHeader: React.FC<DashboardHeaderProps> = ({
	theme,
	insets,
	animatedStyle,
	currentDateString,
	onSettingsPress,
	headerHeight,
}) => (
	<Animated.View
		style={[
			localStyles.headerBase,
			{
				backgroundColor: theme.colors.background,
				paddingTop: insets.top,
				height: headerHeight + insets.top,
				paddingHorizontal: theme.spacing.md,
				paddingBottom: theme.spacing.sm,
			},
			animatedStyle,
		]}
	>
		<View style={localStyles.headerContent}>
			<View>
				<Text
					variant="xs"
					color="textSecondary"
					weight="medium"
					style={localStyles.headerTitleSmall}
				>
					Dashboard
				</Text>
				<Text variant="xl" weight="semibold">
					{currentDateString}
				</Text>
			</View>
			<Pressable
				onPress={onSettingsPress}
				style={({ pressed }) => [
					localStyles.iconButton,
					pressed && { backgroundColor: theme.colors.overlay },
				]}
				android_ripple={{ color: theme.colors.overlay, borderless: true }}
			>
				<Ionicons
					name="settings-outline"
					size={theme.sizes.iconMd}
					color={theme.colors.textSecondary}
				/>
			</Pressable>
		</View>
	</Animated.View>
);
const localStyles = StyleSheet.create({
	headerBase: {
		position: "absolute",
		top: 0,
		left: 0,
		right: 0,
		zIndex: 100,
	},
	headerContent: {
		flex: 1,
		flexDirection: "row",
		alignItems: "center",
		justifyContent: "space-between",
	},
	headerTitleSmall: {
		textTransform: "uppercase",
		letterSpacing: 0.5,
	},
	iconButton: {
		padding: 8,
		borderRadius: 20,
	},
});
</file>

<file path="apps/merchant-app/components/layout/index.ts">
export * from "./ScreenContainer";
export * from "./SearchOverlay";
</file>

<file path="apps/merchant-app/components/layout/ScreenContainer.tsx">
import { useTheme } from "@/hooks/useTheme";
import { Screen } from "expo-router/build/views/Screen";
import React from "react";
import {
	RefreshControlProps,
	ScrollView,
	StatusBar,
	StyleSheet,
	View,
} from "react-native";
import {
	SafeAreaView,
	useSafeAreaInsets,
} from "react-native-safe-area-context";
interface ScreenContainerProps {
	children: React.ReactNode;
	scrollable?: boolean;
	screenOptions?: any;
	header?: React.ReactNode;
	padded?: boolean;
	refreshControl?: React.ReactElement<RefreshControlProps>;
	contentContainerStyle?: any;
	bottomInset?: boolean;
}
export const ScreenContainer: React.FC<ScreenContainerProps> = ({
	children,
	scrollable = true,
	screenOptions = { headerShown: false },
	header,
	padded = true,
	refreshControl,
	contentContainerStyle,
	bottomInset = true,
}) => {
	const theme = useTheme();
	const insets = useSafeAreaInsets();
	const styles = StyleSheet.create({
		container: {
			flex: 1,
			backgroundColor: theme.colors.background,
		},
		content: {
			flex: 1,
			paddingHorizontal: padded ? theme.spacing.screenPadding : 0,
		},
		scrollContent: {
			flexGrow: 1,
			paddingBottom: bottomInset
				? insets.bottom || theme.spacing.xl
				: theme.spacing.xl,
		},
	});
	const Container = header ? View : SafeAreaView;
	return (
		<>
			<Screen options={screenOptions} />
			<StatusBar
				barStyle={theme.isDark ? "light-content" : "dark-content"}
				backgroundColor={theme.colors.background}
			/>
			<Container style={styles.container}>
				{header}
				{scrollable ? (
					<ScrollView
						style={styles.content}
						contentContainerStyle={[
							styles.scrollContent,
							contentContainerStyle,
						]}
						showsVerticalScrollIndicator={false}
						refreshControl={refreshControl}
						keyboardShouldPersistTaps="handled"
					>
						{children}
					</ScrollView>
				) : (
					<View style={styles.content}>{children}</View>
				)}
			</Container>
		</>
	);
};
</file>

<file path="apps/merchant-app/components/ui/Avatar.tsx">
import { ThemeTokens, useTheme } from "@/hooks/useTheme";
import React from "react";
import {
	Image,
	ImageSourcePropType,
	StyleSheet,
	View,
	ViewProps,
} from "react-native";
import { Text } from "./Text";
interface AvatarProps extends ViewProps {
	size?: "sm" | "md" | "lg" | number;
	source?: ImageSourcePropType;
	text?: string;
	color?: ThemeTokens["colors"];
	backgroundColor?: ThemeTokens["colors"];
}
export const Avatar: React.FC<AvatarProps> = ({
	size = "md",
	source,
	text,
	color,
	backgroundColor,
	style,
	...props
}) => {
	const theme = useTheme();
	const getSize = () => {
		if (typeof size === "number") return size;
		switch (size) {
			case "sm":
				return theme.sizes.avatarSm;
			case "md":
				return theme.sizes.avatarMd;
			case "lg":
				return theme.sizes.avatarLg;
			default:
				return theme.sizes.avatarMd;
		}
	};
	const getFontSize = () => {
		if (typeof size === "number") return size / 2;
		switch (size) {
			case "sm":
				return theme.typography.sizes.sm;
			case "md":
				return theme.typography.sizes.lg;
			case "lg":
				return theme.typography.sizes.xl;
			default:
				return theme.typography.sizes.lg;
		}
	};
	const avatarSize = getSize();
	const bgColor = backgroundColor
		? theme.colors[backgroundColor]
		: theme.colors.primaryLight;
	const textColor = color ? theme.colors[color] : theme.colors.primary;
	const styles = StyleSheet.create({
		container: {
			width: avatarSize,
			height: avatarSize,
			borderRadius: avatarSize / 2,
			backgroundColor: bgColor,
			alignItems: "center",
			justifyContent: "center",
			overflow: "hidden",
		},
		image: {
			width: avatarSize,
			height: avatarSize,
		},
		textStyle: {
			fontSize: getFontSize(),
			lineHeight: getFontSize() * 1.2,
		},
	});
	return (
		<View style={[styles.container, style]} {...props}>
			{source ? (
				<Image source={source} style={styles.image} resizeMode="cover" />
			) : (
				<Text weight="bold" color={textColor} style={styles.textStyle}>
					{text ? text.charAt(0).toUpperCase() : "?"}
				</Text>
			)}
		</View>
	);
};
</file>

<file path="apps/merchant-app/components/ui/Button.tsx">
import React from "react";
import {
	TouchableOpacity,
	TouchableOpacityProps,
	StyleSheet,
	StyleProp,
	ViewStyle,
	ActivityIndicator,
} from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { useTheme } from "@/hooks/useTheme";
import { Text } from "./Text";
interface ButtonProps extends TouchableOpacityProps {
	title: string;
	variant?: "primary" | "secondary" | "outline" | "ghost";
	size?: "sm" | "md" | "lg";
	leftIcon?: string;
	rightIcon?: string;
	loading?: boolean;
	rounded?: boolean;
	fullWidth?: boolean;
	style?: StyleProp<ViewStyle>;
	textColor?: string;
}
export const Button: React.FC<ButtonProps> = ({
	title,
	variant = "primary",
	size = "md",
	leftIcon,
	rightIcon,
	loading = false,
	rounded = false,
	fullWidth = false,
	style,
	textColor: textColorOverride,
	...props
}) => {
	const theme = useTheme();
	const getVariantStyles = () => {
		switch (variant) {
			case "primary":
				return {
					backgroundColor: theme.colors.primary,
					textColorToken: theme.colors.background,
				};
			case "secondary":
				return {
					backgroundColor: theme.colors.cardAlt,
					textColorToken: theme.colors.text,
				};
			case "outline":
				return {
					backgroundColor: "transparent",
					borderWidth: 1,
					borderColor: theme.colors.primary,
					textColorToken: theme.colors.primary,
				};
			case "ghost":
				return {
					backgroundColor: "transparent",
					textColorToken: theme.colors.primary,
				};
			default:
				return {
					backgroundColor: theme.colors.primary,
					textColorToken: theme.colors.background,
				};
		}
	};
	const getSizeStyles = () => {
		switch (size) {
			case "sm":
				return {
					height: theme.sizes.buttonSm,
					paddingHorizontal: theme.spacing.md,
					fontSize: "sm" as const,
					iconSize: theme.sizes.iconXs,
				};
			case "md":
				return {
					height: theme.sizes.buttonMd,
					paddingHorizontal: theme.spacing.md,
					fontSize: "md" as const,
					iconSize: theme.sizes.iconSm,
				};
			case "lg":
				return {
					height: theme.sizes.buttonLg,
					paddingHorizontal: theme.spacing.lg,
					fontSize: "md" as const,
					iconSize: theme.sizes.iconMd,
				};
			default:
				return {
					height: theme.sizes.buttonMd,
					paddingHorizontal: theme.spacing.md,
					fontSize: "md" as const,
					iconSize: theme.sizes.iconSm,
				};
		}
	};
	const variantStyle = getVariantStyles();
	const sizeStyle = getSizeStyles();
	const finalTextColor = textColorOverride || variantStyle.textColorToken;
	const styles = StyleSheet.create({
		button: {
			height: sizeStyle.height,
			paddingHorizontal: sizeStyle.paddingHorizontal,
			borderRadius: rounded ? theme.radius.round : theme.radius.button,
			backgroundColor: variantStyle.backgroundColor,
			borderWidth: variantStyle.borderWidth || 0,
			borderColor: variantStyle.borderColor,
			flexDirection: "row",
			alignItems: "center",
			justifyContent: "center",
			width: fullWidth ? "100%" : undefined,
		},
		icon: {
			marginRight: leftIcon && title ? theme.spacing.xs : 0,
			marginLeft: rightIcon && title ? theme.spacing.xs : 0,
		},
	});
	return (
		<TouchableOpacity
			style={[styles.button, style]}
			activeOpacity={0.7}
			disabled={loading || props.disabled}
			{...props}
		>
			{loading ? (
				<ActivityIndicator color={finalTextColor} size="small" />
			) : (
				<>
					{leftIcon && (
						<Ionicons
							name={leftIcon as any}
							size={sizeStyle.iconSize}
							color={finalTextColor}
							style={styles.icon}
						/>
					)}
					<Text
						variant={sizeStyle.fontSize}
						weight="semibold"
						color={finalTextColor}
					>
						{title}
					</Text>
					{rightIcon && (
						<Ionicons
							name={rightIcon as any}
							size={sizeStyle.iconSize}
							color={finalTextColor}
							style={styles.icon}
						/>
					)}
				</>
			)}
		</TouchableOpacity>
	);
};
</file>

<file path="apps/merchant-app/components/ui/Card.tsx">
import React from "react";
import {
	TouchableOpacity,
	StyleSheet,
	TouchableOpacityProps,
	StyleProp,
	ViewStyle,
	View,
} from "react-native";
import { RadiusToken, SpacingToken, useTheme } from "@/hooks/useTheme";
interface CardProps extends TouchableOpacityProps {
	elevation?: "none" | "small" | "medium" | "large";
	padding?: SpacingToken | number;
	rounded?: RadiusToken;
	style?: StyleProp<ViewStyle>;
	children?: React.ReactNode;
}
export const Card: React.FC<CardProps> = ({
	children,
	elevation = "small",
	padding = "md",
	rounded = "card",
	style,
	onPress,
	...props
}) => {
	const theme = useTheme();
	const getElevation = () => {
		if (elevation === "none") return {};
		const shadowStyle = theme.shadows[elevation];
		return { ...shadowStyle, shadowColor: theme.colors.shadow };
	};
	const getPaddingValue = () => {
		return typeof padding === "number" ? padding : theme.spacing[padding];
	};
	const getRadiusValue = () => {
		return theme.radius[rounded];
	};
	const styles = StyleSheet.create({
		card: {
			backgroundColor: theme.colors.card,
			borderRadius: getRadiusValue(),
			padding: getPaddingValue(),
			...getElevation(),
		},
	});
	const ContainerComponent = onPress ? TouchableOpacity : View;
	return (
		<ContainerComponent
			activeOpacity={onPress ? 0.7 : 1}
			style={[styles.card, style]}
			onPress={onPress}
			{...props}
		>
			{children}
		</ContainerComponent>
	);
};
</file>

<file path="apps/merchant-app/components/ui/index.ts">
export * from "./Box";
export * from "./Text";
export * from "./Button";
export * from "./Avatar";
export * from "./Card";
export * from "./Badge";
export * from "./Tabs";
</file>

<file path="apps/merchant-app/components/ui/Tabs.tsx">
import React from "react";
import { Pressable, StyleSheet } from "react-native";
import Animated, { FadeInUp } from "react-native-reanimated";
import { Box } from "./Box";
import { Text } from "./Text";
import { AppTheme } from "@/hooks/useTheme";
import * as Haptics from "expo-haptics";
interface TabsProps {
	tabs: string[];
	selectedTab: string;
	onSelectTab: (tab: string) => void;
	theme: AppTheme;
}
const AnimatedBox = Animated.createAnimatedComponent(Box);
export const Tabs: React.FC<TabsProps> = React.memo(
	({ tabs, selectedTab, onSelectTab, theme }) => {
		const handlePress = (tab: string) => {
			if (tab !== selectedTab) {
				Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
				onSelectTab(tab);
			}
		};
		return (
			<AnimatedBox
				entering={FadeInUp.delay(50).duration(400).springify().damping(15)}
				style={localStyles.tabsContainer}
				bg="backgroundAlt"
				rounded="md"
				padding="xs"
				row
			>
				{tabs.map((tab) => (
					<Pressable
						key={tab}
						style={({ pressed }) => [
							localStyles.tab,
							{ borderRadius: theme.radius.sm },
							tab === selectedTab && [
								localStyles.selectedTab,
								{
									backgroundColor: theme.colors.card,
									shadowColor: theme.colors.shadow,
								},
							],
							pressed && { opacity: 0.5 },
						]}
						onPress={() => handlePress(tab)}
						android_ripple={{ color: theme.colors.overlay, borderless: true }}
					>
						<Text
							variant="sm"
							weight={tab === selectedTab ? "semibold" : "medium"}
							color={tab === selectedTab ? "primary" : "textSecondary"}
						>
							{tab}
						</Text>
					</Pressable>
				))}
			</AnimatedBox>
		);
	},
);
const localStyles = StyleSheet.create({
	tabsContainer: { flexDirection: "row" },
	tab: {
		flex: 1,
		paddingVertical: 8,
		paddingHorizontal: 12,
		alignItems: "center",
		justifyContent: "center",
	},
	selectedTab: {
		shadowOffset: { width: 0, height: 1 },
		shadowOpacity: 0.1,
		shadowRadius: 2,
		elevation: 2,
	},
});
</file>

<file path="apps/merchant-app/components/ui/Text.tsx">
import React from "react";
import {
	Text as RNText,
	TextProps as RNTextProps,
	StyleSheet,
	StyleProp,
	TextStyle,
	I18nManager,
} from "react-native";
import {
	ColorToken,
	FontSizeVariant,
	FontWeightVariant,
	SpacingToken,
	useTheme,
} from "@/hooks/useTheme";
interface TextProps extends RNTextProps {
	variant?: FontSizeVariant;
	weight?: FontWeightVariant;
	color?: ColorToken | string;
	center?: boolean;
	muted?: boolean;
	marginBottom?: SpacingToken | number;
	marginTop?: SpacingToken | number;
	marginLeft?: SpacingToken | number;
	marginRight?: SpacingToken | number;
	marginStart?: SpacingToken | number;
	marginEnd?: SpacingToken | number;
	marginHorizontal?: SpacingToken | number;
	marginVertical?: SpacingToken | number;
	margin?: SpacingToken | number;
	style?: StyleProp<TextStyle>;
}
export const Text: React.FC<TextProps> = ({
	children,
	variant = "md",
	weight = "regular",
	color,
	center,
	muted,
	marginBottom,
	marginTop,
	marginLeft,
	marginRight,
	marginStart,
	marginEnd,
	marginHorizontal,
	marginVertical,
	margin,
	style,
	...props
}) => {
	const theme = useTheme();
	const isRTL = I18nManager.isRTL;
	const getSpacingValue = (
		value: SpacingToken | number | undefined,
	): number | undefined => {
		if (value === undefined) return undefined;
		return typeof value === "number" ? value : theme.spacing[value];
	};
	const getColorValue = (
		colorProp: ColorToken | string | undefined,
	): string => {
		if (colorProp === undefined) {
			return muted ? theme.colors.textSecondary : theme.colors.text;
		}
		if (typeof colorProp === "string" && colorProp in theme.colors) {
			return theme.colors[colorProp as ColorToken];
		}
		return colorProp;
	};
	const finalMarginLeft =
		marginStart !== undefined
			? isRTL
				? undefined
				: getSpacingValue(marginStart)
			: getSpacingValue(marginLeft);
	const finalMarginRight =
		marginEnd !== undefined
			? isRTL
				? undefined
				: getSpacingValue(marginEnd)
			: getSpacingValue(marginRight);
	const finalMarginStart =
		marginStart !== undefined
			? isRTL
				? getSpacingValue(marginStart)
				: undefined
			: undefined;
	const finalMarginEnd =
		marginEnd !== undefined
			? isRTL
				? getSpacingValue(marginEnd)
				: undefined
			: undefined;
	const styles = StyleSheet.create({
		text: {
			fontSize: theme.typography.sizes[variant],
			fontWeight: theme.typography.weights[weight],
			color: getColorValue(color),
			textAlign: center ? "center" : undefined,
			marginBottom: getSpacingValue(marginBottom),
			marginTop: getSpacingValue(marginTop),
			marginLeft: finalMarginLeft,
			marginRight: finalMarginRight,
			marginStart: finalMarginStart,
			marginEnd: finalMarginEnd,
			marginHorizontal: getSpacingValue(marginHorizontal),
			marginVertical: getSpacingValue(marginVertical),
			margin: getSpacingValue(margin),
		},
	});
	return (
		<RNText style={[styles.text, style]} {...props}>
			{children}
		</RNText>
	);
};
export default Text;
</file>

<file path="apps/merchant-app/hooks/useTheme.ts">
import { useColorScheme } from "react-native";
import { theme, ThemeMode } from "@/constants/theme";
import { DarkTheme, DefaultTheme } from "@react-navigation/native";
export const useTheme = () => {
	const colorScheme = useColorScheme() || "light";
	const isDark = colorScheme === "dark";
	const mode: ThemeMode = isDark ? "dark" : "light";
	const navTheme = isDark ? DarkTheme : DefaultTheme;
	return {
		colors: theme.colors[mode],
		isDark,
		mode,
		spacing: theme.spacing,
		radius: theme.radius,
		sizes: theme.sizes,
		typography: theme.typography,
		shadows: theme.shadows,
		platform: theme.platform,
		navTheme: {
			...navTheme,
			colors: {
				...navTheme.colors,
				primary: theme.colors[mode].primary,
				background: theme.colors[mode].background,
				card: theme.colors[mode].card,
				text: theme.colors[mode].text,
				border: theme.colors[mode].divider,
				notification: theme.colors[mode].primary,
			},
		},
	};
};
export type AppTheme = ReturnType<typeof useTheme>;
export type SpacingToken = keyof AppTheme["spacing"];
export type RadiusToken = keyof AppTheme["radius"];
export type ColorToken = keyof AppTheme["colors"];
export type ThemeTokens = {
	spacing: SpacingToken;
	radius: RadiusToken;
	colors: ColorToken;
};
export type FontSizeVariant = keyof AppTheme["typography"]["sizes"];
export type FontWeightVariant = keyof AppTheme["typography"]["weights"];
</file>

<file path="apps/merchant-app/components/dashboard/AlertRow.tsx">
import React from "react";
import { Pressable } from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { Box, Text } from "@/components/ui";
import { AppTheme } from "@/hooks/useTheme";
import { Alert } from "@/types";
interface AlertRowProps {
	alert: Alert;
	theme: AppTheme;
	onPress: () => void;
}
export const AlertRow: React.FC<AlertRowProps> = React.memo(
	({ alert, theme, onPress }) => {
		const iconColor = theme.colors[alert.type];
		return (
			<Pressable
				onPress={onPress}
				style={({ pressed }) => [
					{
						paddingHorizontal: theme.spacing.sm,
						flexDirection: "row",
						alignItems: "center",
						paddingVertical: theme.spacing.md,
						borderRadius: theme.radius.sm,
					},
					pressed && {
						backgroundColor: theme.colors.backgroundAlt,
					},
				]}
				android_ripple={{ color: theme.colors.overlay }}
			>
				<Ionicons
					name={alert.icon as any}
					size={theme.sizes.iconSm}
					color={iconColor}
					style={{ marginRight: theme.spacing.md }}
				/>
				<Box flex={1}>
					<Text variant="sm" numberOfLines={1}>
						{alert.title}
					</Text>
					{alert.timestamp && (
						<Text
							variant="xs"
							color="textMuted"
							marginTop={theme.spacing.xs / 2}
						>
							{alert.timestamp}
						</Text>
					)}
				</Box>
				<Ionicons
					name="chevron-forward"
					size={theme.sizes.iconSm}
					color={theme.colors.textMuted}
				/>
			</Pressable>
		);
	},
);
</file>

<file path="apps/merchant-app/components/layout/SearchOverlay.tsx">
import React, { useRef, useEffect, useState } from "react";
import {
	View,
	TextInput,
	TouchableOpacity,
	StyleSheet,
	Keyboard,
	FlatList,
	StatusBar,
	Platform,
	Pressable,
} from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { useTheme } from "@/hooks/useTheme";
import { Text } from "../ui";
import Animated, {
	useSharedValue,
	useAnimatedStyle,
	withTiming,
	withSpring,
	Easing,
	interpolate,
} from "react-native-reanimated";
interface SearchResult {
	id: string | number;
	title: string;
	subtitle?: string;
	icon?: string;
}
interface SearchOverlayProps {
	isVisible: boolean;
	onClose: () => void;
	placeholder?: string;
	onSearch: (query: string) => void;
	results?: SearchResult[];
	onResultPress?: (item: SearchResult) => void;
	recentSearches?: string[];
	onClearRecents?: () => void;
}
export const SearchOverlay: React.FC<SearchOverlayProps> = ({
	isVisible,
	onClose,
	placeholder = "Search...",
	onSearch,
	results = [],
	onResultPress,
	recentSearches = [],
	onClearRecents,
}) => {
	const theme = useTheme();
	const [searchValue, setSearchValue] = useState("");
	const searchInputRef = useRef<TextInput>(null);
	const translateY = useSharedValue(0);
	const opacity = useSharedValue(0);
	useEffect(() => {
		if (isVisible) {
			setSearchValue("");
			opacity.value = withTiming(1, { duration: 200 });
			translateY.value = withSpring(1, {
				damping: 11,
				stiffness: 65,
				overshootClamping: true,
			});
			const timeoutId = setTimeout(() => {
				searchInputRef.current?.focus();
			}, 300);
			return () => clearTimeout(timeoutId);
		}
		opacity.value = withTiming(0, { duration: 150 });
		translateY.value = withTiming(0, {
			duration: 200,
			easing: Easing.ease,
		});
		Keyboard.dismiss();
	}, [isVisible, opacity, translateY]);
	const handleChangeText = (text: string) => {
		setSearchValue(text);
		onSearch(text);
	};
	const handleItemPress = (item: SearchResult) => {
		onResultPress?.(item);
		onClose();
	};
	const handleRecentPress = (query: string) => {
		setSearchValue(query);
		onSearch(query);
		searchInputRef.current?.focus(); // Keep focus after selecting recent
	};
	const containerStyle = useAnimatedStyle(() => {
		const translateYValue = interpolate(translateY.value, [0, 1], [-50, 0]);
		return {
			opacity: opacity.value,
			transform: [{ translateY: translateYValue }],
		};
	});
	const styles = StyleSheet.create({
		container: {
			position: "absolute",
			top: 0,
			left: 0,
			right: 0,
			bottom: 0,
			zIndex: 1000,
			backgroundColor: theme.colors.background,
		},
		header: {
			flexDirection: "row",
			alignItems: "center",
			paddingTop: theme.platform.topInset,
			paddingHorizontal: theme.spacing.md,
			paddingBottom: theme.spacing.sm,
			borderBottomWidth: StyleSheet.hairlineWidth,
			borderBottomColor: theme.colors.divider,
		},
		backButton: {
			padding: theme.spacing.sm,
			marginRight: theme.spacing.xs,
			borderRadius: theme.radius.round,
		},
		searchBar: {
			flex: 1,
			flexDirection: "row",
			alignItems: "center",
			height: theme.sizes.buttonMd,
			borderRadius: theme.radius.md,
			paddingHorizontal: theme.spacing.sm,
			backgroundColor: theme.colors.backgroundAlt,
		},
		searchIcon: {
			marginRight: theme.spacing.sm,
		},
		input: {
			flex: 1,
			height: "100%",
			fontSize: theme.typography.sizes.md,
			color: theme.colors.text,
			paddingLeft: theme.spacing.xs,
		},
		clearButton: {
			padding: theme.spacing.xs,
		},
		list: {
			paddingBottom: theme.spacing.lg,
		},
		resultItem: {
			flexDirection: "row",
			alignItems: "center",
			paddingVertical: theme.spacing.md,
			paddingHorizontal: theme.spacing.md,
			borderBottomWidth: StyleSheet.hairlineWidth,
			borderBottomColor: theme.colors.divider,
		},
		resultItemPressed: {
			backgroundColor: theme.colors.backgroundAlt,
		},
		resultIconContainer: {
			width: theme.sizes.avatarSm,
			height: theme.sizes.avatarSm,
			borderRadius: theme.radius.round,
			alignItems: "center",
			justifyContent: "center",
			marginRight: theme.spacing.md,
			backgroundColor: theme.colors.primaryLight,
		},
		resultTextContainer: {
			flex: 1,
		},
		emptyContainer: {
			flex: 1,
			padding: theme.spacing.md,
		},
		noResults: {
			flex: 1,
			justifyContent: "center",
			alignItems: "center",
			paddingBottom: theme.spacing.xl,
		},
		noResultsIcon: {
			marginBottom: theme.spacing.md,
		},
		recentsContainer: {
			paddingVertical: theme.spacing.sm,
		},
		recentsHeader: {
			flexDirection: "row",
			justifyContent: "space-between",
			alignItems: "center",
			marginBottom: theme.spacing.sm,
			paddingHorizontal: theme.spacing.sm,
		},
		recentItem: {
			flexDirection: "row",
			alignItems: "center",
			paddingVertical: theme.spacing.sm + 2,
			paddingHorizontal: theme.spacing.md,
			borderRadius: theme.radius.sm,
		},
		recentItemPressed: {
			backgroundColor: theme.colors.backgroundAlt,
		},
		recentIcon: {
			marginRight: theme.spacing.sm,
		},
	});
	if (!isVisible && opacity.value === 0) return null;
	return (
		<Animated.View style={[styles.container, containerStyle]}>
			<StatusBar barStyle={theme.isDark ? "light-content" : "dark-content"} />
			<View style={styles.header}>
				<TouchableOpacity onPress={onClose} style={styles.backButton}>
					<Ionicons
						name="arrow-back"
						size={theme.sizes.iconMd}
						color={theme.colors.text}
					/>
				</TouchableOpacity>
				<View style={styles.searchBar}>
					<Ionicons
						name="search"
						size={theme.sizes.iconSm}
						color={theme.colors.textSecondary}
						style={styles.searchIcon}
					/>
					<TextInput
						ref={searchInputRef}
						style={styles.input}
						placeholder={placeholder}
						placeholderTextColor={theme.colors.textSecondary}
						value={searchValue}
						onChangeText={handleChangeText}
						returnKeyType="search"
						autoCapitalize="none"
						autoCorrect={false}
						clearButtonMode="while-editing"
					/>
					{searchValue.length > 0 && Platform.OS === "android" && (
						<TouchableOpacity
							onPress={() => handleChangeText("")}
							style={styles.clearButton}
						>
							<Ionicons
								name="close-circle"
								size={theme.sizes.iconSm}
								color={theme.colors.textSecondary}
							/>
						</TouchableOpacity>
					)}
				</View>
			</View>
			{results.length > 0 ? (
				<FlatList
					data={results}
					keyExtractor={(item) => item.id.toString()}
					keyboardShouldPersistTaps="handled"
					renderItem={({ item }) => (
						<Pressable
							style={({ pressed }) => [
								styles.resultItem,
								pressed && styles.resultItemPressed,
							]}
							onPress={() => handleItemPress(item)}
							android_ripple={{ color: theme.colors.overlay }}
						>
							{item.icon && (
								<View style={styles.resultIconContainer}>
									<Ionicons
										name={item.icon as any}
										size={theme.sizes.iconSm - 2}
										color={theme.colors.primary}
									/>
								</View>
							)}
							<View style={styles.resultTextContainer}>
								<Text variant="md">{item.title}</Text>
								{item.subtitle && (
									<Text
										variant="sm"
										color="textSecondary"
										marginTop={theme.spacing.xs / 2}
									>
										{item.subtitle}
									</Text>
								)}
							</View>
						</Pressable>
					)}
					contentContainerStyle={styles.list}
				/>
			) : (
				<View style={styles.emptyContainer}>
					{searchValue.length > 0 ? (
						<View style={styles.noResults}>
							<Ionicons
								name="search"
								size={theme.sizes.iconLg}
								color={theme.colors.textSecondary}
								style={styles.noResultsIcon}
							/>
							<Text color="textSecondary" center>
								No results found for "{searchValue}"
							</Text>
						</View>
					) : recentSearches.length > 0 ? (
						<View style={styles.recentsContainer}>
							<View style={styles.recentsHeader}>
								<Text variant="sm" weight="semibold" color="textSecondary">
									Recent Searches
								</Text>
								{onClearRecents && (
									<TouchableOpacity onPress={onClearRecents}>
										<Text variant="sm" color="primary">
											Clear
										</Text>
									</TouchableOpacity>
								)}
							</View>
							{recentSearches.map((query, index) => (
								<Pressable
									key={`recent-${index.toString()}`}
									style={({ pressed }) => [
										styles.recentItem,
										pressed && styles.recentItemPressed,
									]}
									onPress={() => handleRecentPress(query)}
									android_ripple={{ color: theme.colors.overlay }}
								>
									<Ionicons
										name="time-outline"
										size={theme.sizes.iconSm}
										color={theme.colors.textSecondary}
										style={styles.recentIcon}
									/>
									<Text variant="md">{query}</Text>
								</Pressable>
							))}
						</View>
					) : null}
				</View>
			)}
		</Animated.View>
	);
};
export default SearchOverlay;
</file>

<file path="apps/merchant-app/components/ui/Badge.tsx">
import React from "react";
import { View, StyleSheet, ViewProps } from "react-native";
import { useTheme } from "@/hooks/useTheme";
import { Text } from "./Text";
export interface BadgeProps extends ViewProps {
	text: string | number;
	variant?: "primary" | "success" | "warning" | "info" | "error" | "default";
	size?: "sm" | "md";
}
export const Badge: React.FC<BadgeProps> = ({
	text,
	variant = "default",
	size = "md",
	style,
	...props
}) => {
	const theme = useTheme();
	const getBadgeStyles = () => {
		const base = {
			textColor: theme.colors.text,
			bgColor: theme.colors.backgroundAlt,
		};
		switch (variant) {
			case "primary":
				return {
					textColor: theme.colors.background,
					bgColor: theme.colors.primary,
				};
			case "success":
				return {
					textColor: theme.colors.background,
					bgColor: theme.colors.success,
				};
			case "warning":
				return { textColor: theme.colors.text, bgColor: theme.colors.warning };
			case "info":
				return {
					textColor: theme.colors.background,
					bgColor: theme.colors.info,
				};
			case "error":
				return {
					textColor: theme.colors.background,
					bgColor: theme.colors.error,
				};
			default:
				return base;
		}
	};
	const getSizeStyles = () => {
		switch (size) {
			case "sm":
				return {
					paddingHorizontal: theme.spacing.sm,
					paddingVertical: theme.spacing.xs / 2,
					fontSize: "xs" as const,
				};
			default:
				return {
					paddingHorizontal: theme.spacing.sm,
					paddingVertical: theme.spacing.xs / 2 + 1,
					fontSize: "sm" as const,
				};
		}
	};
	const badgeStyle = getBadgeStyles();
	const sizeStyle = getSizeStyles();
	const styles = StyleSheet.create({
		badge: {
			backgroundColor: badgeStyle.bgColor,
			paddingHorizontal: sizeStyle.paddingHorizontal,
			paddingVertical: sizeStyle.paddingVertical,
			borderRadius: theme.radius.badge,
			alignItems: "center",
			justifyContent: "center",
			alignSelf: "flex-start",
		},
	});
	return (
		<View style={[styles.badge, style]} {...props}>
			<Text
				variant={sizeStyle.fontSize}
				weight="medium"
				color={badgeStyle.textColor}
			>
				{text}
			</Text>
		</View>
	);
};
</file>

<file path="apps/merchant-app/components/ui/Box.tsx">
import React from "react";
import {
	View,
	ViewProps,
	StyleSheet,
	StyleProp,
	ViewStyle,
	DimensionValue,
	FlexAlignType,
	Pressable,
	I18nManager,
} from "react-native";
import { useTheme } from "@/hooks/useTheme";
import { SpacingToken, ColorToken, RadiusToken } from "@/hooks/useTheme";
import Animated from "react-native-reanimated";
type JustifyContentType =
	| "flex-start"
	| "flex-end"
	| "center"
	| "space-between"
	| "space-around"
	| "space-evenly";
interface BoxProps extends ViewProps {
	flex?: number;
	row?: boolean;
	center?: boolean;
	alignCenter?: boolean;
	alignItems?: FlexAlignType;
	justifyCenter?: boolean;
	justifyContent?: JustifyContentType;
	card?: boolean;
	padding?: SpacingToken | number;
	margin?: SpacingToken | number;
	marginTop?: SpacingToken | number;
	marginBottom?: SpacingToken | number;
	marginLeft?: SpacingToken | number;
	marginRight?: SpacingToken | number;
	marginStart?: SpacingToken | number;
	marginEnd?: SpacingToken | number;
	marginHorizontal?: SpacingToken | number;
	marginVertical?: SpacingToken | number;
	paddingHorizontal?: SpacingToken | number;
	paddingBottom?: SpacingToken | number;
	paddingTop?: SpacingToken | number;
	paddingVertical?: SpacingToken | number;
	paddingLeft?: SpacingToken | number;
	paddingRight?: SpacingToken | number;
	paddingStart?: SpacingToken | number;
	paddingEnd?: SpacingToken | number;
	rounded?: RadiusToken | number;
	width?: DimensionValue;
	height?: DimensionValue;
	borderWidth?: number;
	borderColor?: ColorToken;
	bg?: ColorToken | string;
	elevation?: "none" | "small" | "medium" | "large";
	style?: StyleProp<ViewStyle>;
	onPress?: () => void;
	activeOpacity?: number;
}
export const Box: React.FC<BoxProps> = ({
	children,
	flex,
	row,
	center,
	alignCenter,
	paddingTop,
	alignItems,
	paddingBottom,
	justifyCenter,
	justifyContent,
	card,
	padding,
	margin,
	marginTop,
	marginBottom,
	marginLeft,
	marginRight,
	marginStart,
	marginEnd,
	marginHorizontal,
	marginVertical,
	paddingHorizontal,
	paddingVertical,
	paddingLeft,
	paddingRight,
	paddingStart,
	paddingEnd,
	rounded,
	width,
	height,
	borderWidth,
	borderColor,
	bg,
	elevation,
	style,
	onPress,
	activeOpacity = 0.7,
	...props
}) => {
	const theme = useTheme();
	const isRTL = I18nManager.isRTL;
	let finalAlignItems: FlexAlignType | undefined;
	let finalJustifyContent: JustifyContentType | undefined;
	if (center) {
		finalAlignItems = "center";
		finalJustifyContent = "center";
	} else {
		finalAlignItems = alignCenter ? "center" : alignItems;
		finalJustifyContent = justifyCenter ? "center" : justifyContent;
	}
	const getSpacingValue = (
		value: SpacingToken | number | undefined,
	): number | undefined => {
		if (value === undefined) return undefined;
		return typeof value === "number" ? value : theme.spacing[value];
	};
	const getRadiusValue = (
		value: RadiusToken | number | undefined,
	): number | undefined => {
		if (value === undefined) return undefined;
		return typeof value === "number" ? value : theme.radius[value];
	};
	const getColorValue = (
		color: ColorToken | string | undefined,
	): string | undefined => {
		if (color === undefined) return undefined;
		if (typeof color === "string" && color in theme.colors) {
			return theme.colors[color as ColorToken];
		}
		return color;
	};
	const getElevation = (level?: "none" | "small" | "medium" | "large") => {
		if (!level || level === "none") return {};
		const shadowStyle = theme.shadows[level];
		return { ...shadowStyle, shadowColor: theme.colors.shadow };
	};
	const finalMarginLeft =
		marginStart !== undefined
			? isRTL
				? undefined
				: getSpacingValue(marginStart)
			: getSpacingValue(marginLeft);
	const finalMarginRight =
		marginEnd !== undefined
			? isRTL
				? undefined
				: getSpacingValue(marginEnd)
			: getSpacingValue(marginRight);
	const finalMarginStart =
		marginStart !== undefined
			? isRTL
				? getSpacingValue(marginStart)
				: undefined
			: undefined;
	const finalMarginEnd =
		marginEnd !== undefined
			? isRTL
				? getSpacingValue(marginEnd)
				: undefined
			: undefined;
	const finalPaddingLeft =
		paddingStart !== undefined
			? isRTL
				? undefined
				: getSpacingValue(paddingStart)
			: getSpacingValue(paddingLeft);
	const finalPaddingRight =
		paddingEnd !== undefined
			? isRTL
				? undefined
				: getSpacingValue(paddingEnd)
			: getSpacingValue(paddingRight);
	const finalPaddingStart =
		paddingStart !== undefined
			? isRTL
				? getSpacingValue(paddingStart)
				: undefined
			: undefined;
	const finalPaddingEnd =
		paddingEnd !== undefined
			? isRTL
				? getSpacingValue(paddingEnd)
				: undefined
			: undefined;
	const styles = StyleSheet.create({
		box: {
			flex: flex,
			flexDirection: row ? (isRTL ? "row-reverse" : "row") : "column",
			alignItems: finalAlignItems,
			justifyContent: finalJustifyContent,
			padding: getSpacingValue(padding),
			margin: getSpacingValue(margin),
			marginTop: getSpacingValue(marginTop),
			marginBottom: getSpacingValue(marginBottom),
			paddingBottom: getSpacingValue(paddingBottom),
			paddingTop: getSpacingValue(paddingTop),
			marginLeft: finalMarginLeft,
			marginRight: finalMarginRight,
			marginStart: finalMarginStart,
			marginEnd: finalMarginEnd,
			marginHorizontal: getSpacingValue(marginHorizontal),
			marginVertical: getSpacingValue(marginVertical),
			paddingHorizontal: getSpacingValue(paddingHorizontal),
			paddingVertical: getSpacingValue(paddingVertical),
			paddingLeft: finalPaddingLeft,
			paddingRight: finalPaddingRight,
			paddingStart: finalPaddingStart,
			paddingEnd: finalPaddingEnd,
			borderRadius: getRadiusValue(rounded),
			width,
			height,
			borderWidth,
			borderColor: getColorValue(borderColor),
			backgroundColor: card ? theme.colors.card : getColorValue(bg),
			...(card ? getElevation("small") : {}),
			...(elevation ? getElevation(elevation) : {}),
		},
	});
	if (onPress) {
		return (
			<Pressable
				onPress={onPress}
				style={({ pressed }) => [
					styles.box,
					{ opacity: pressed ? activeOpacity : 1 },
					style,
				]}
				{...props}
				android_ripple={{ color: theme.colors.overlay }}
			>
				{children}
			</Pressable>
		);
	}
	return (
		<View style={[styles.box, style]} {...props}>
			{children}
		</View>
	);
};
export default Box;
export const AnimatedBox = Animated.createAnimatedComponent(Box);
</file>

<file path=".nvimrc">
23.11.0
</file>

<file path="apps/merchant-app/constants/theme.ts">
import { Platform } from "react-native";
import { DefaultTheme } from "@react-navigation/native";
const colorPalette = {
	primary: {
		50: "#EBFFF9",
		100: "#C3FFF0",
		200: "#9BFFE6",
		300: "#5FF6D8",
		400: "#22E5C8",
		500: "#0AC5AB",
		600: "#09A98F",
		700: "#07866F",
		800: "#056952",
		900: "#034C3A",
	},
	secondary: {
		50: "#F2EFFF",
		100: "#E4DFFF",
		200: "#CABFFF",
		300: "#A799FF",
		400: "#8E7AFF",
		500: "#7559FF",
		600: "#6038FF",
		700: "#4E1AFF",
		800: "#3C00FB",
		900: "#2F00C2",
	},
	neutral: {
		0: "#FFFFFF",
		50: "#F9FAFB",
		100: "#F1F5F9",
		200: "#E2E8F0",
		300: "#CBD5E1",
		400: "#94A3B8",
		500: "#64748B",
		600: "#475569",
		700: "#334155",
		800: "#1E293B",
		900: "#0F172A",
		950: "#0A0D14",
		1000: "#000000",
	},
	semantic: {
		success: "#22C55E",
		warning: "#FFBE0B",
		info: "#3B82F6",
		error: "#FF5E5B",
	},
};
const getRgba = (hex: string, alpha: number) => {
	const r = Number.parseInt(hex.slice(1, 3), 16);
	const g = Number.parseInt(hex.slice(3, 5), 16);
	const b = Number.parseInt(hex.slice(5, 7), 16);
	return `rgba(${r}, ${g}, ${b}, ${alpha})`;
};
export const theme = {
	colors: {
		light: {
			primary: colorPalette.primary[500],
			primaryDark: colorPalette.primary[600],
			primaryLight: getRgba(colorPalette.primary[500], 0.1),
			secondary: colorPalette.secondary[500],
			secondaryLight: getRgba(colorPalette.secondary[500], 0.1),
			background: colorPalette.neutral[50],
			backgroundAlt: colorPalette.neutral[100],
			card: colorPalette.neutral[0],
			cardAlt: colorPalette.neutral[100],
			text: colorPalette.neutral[900],
			textSecondary: colorPalette.neutral[600],
			textMuted: colorPalette.neutral[400],
			success: colorPalette.semantic.success,
			warning: colorPalette.semantic.warning,
			info: colorPalette.semantic.info,
			error: colorPalette.semantic.error,
			divider: colorPalette.neutral[200],
			overlay: getRgba(colorPalette.neutral[950], 0.3),
			shadow: getRgba(colorPalette.neutral[900], 0.08),
			tabBar: colorPalette.neutral[0],
			tabIconDefault: colorPalette.neutral[400],
			tabIconSelected: colorPalette.primary[500],
		},
		dark: {
			primary: colorPalette.primary[400],
			primaryDark: colorPalette.primary[500],
			primaryLight: getRgba(colorPalette.primary[400], 0.15),
			secondary: colorPalette.secondary[400],
			secondaryLight: getRgba(colorPalette.secondary[400], 0.15),
			background: colorPalette.neutral[950],
			backgroundAlt: colorPalette.neutral[800],
			card: colorPalette.neutral[900],
			cardAlt: colorPalette.neutral[800],
			text: colorPalette.neutral[50],
			textSecondary: colorPalette.neutral[300],
			textMuted: colorPalette.neutral[500],
			success: colorPalette.semantic.success,
			warning: colorPalette.semantic.warning,
			info: colorPalette.semantic.info,
			error: colorPalette.semantic.error,
			divider: getRgba(colorPalette.neutral[0], 0.1),
			overlay: getRgba(colorPalette.neutral[950], 0.6),
			shadow: getRgba(colorPalette.neutral[1000], 0.3),
			tabBar: colorPalette.neutral[900],
			tabIconDefault: colorPalette.neutral[500],
			tabIconSelected: colorPalette.primary[400],
		},
	},
	spacing: {
		none: 0,
		xs: 4,
		sm: 8,
		md: 16,
		lg: 24,
		xl: 32,
		xxl: 48,
		screenPadding: 16,
		cardPadding: 16,
		itemSpacing: 12,
		sectionSpacing: 24,
	} as const,
	radius: {
		none: 0,
		xs: 4,
		sm: 8,
		md: 12,
		lg: 16,
		xl: 24,
		round: 999,
		button: 12,
		card: 16,
		input: 12,
		badge: 12,
	} as const,
	sizes: {
		touchTarget: 44,
		smallTouchTarget: 36,
		iconXs: 16,
		iconSm: 20,
		iconMd: 24,
		iconLg: 32,
		buttonSm: 36,
		buttonMd: 44,
		buttonLg: 52,
		inputHeight: 48,
		headerHeight: 56,
		tabBarHeight: 49,
		avatarSm: 32,
		avatarMd: 44,
		avatarLg: 64,
	} as const,
	typography: {
		sizes: {
			xs: 12,
			sm: 14,
			md: 16,
			lg: 18,
			xl: 20,
			xxl: 24,
			xxxl: 30,
		} as const,
		weights: {
			regular: "400",
			medium: "500",
			semibold: "600",
			bold: "700",
			extrabold: "800",
		} as const,
		lineHeights: {
			tight: 1.2,
			normal: 1.5,
			loose: 1.8,
		} as const,
	} as const,
	shadows: {
		small: {
			shadowOffset: { width: 0, height: 1 },
			shadowOpacity: 0.8,
			shadowRadius: 2,
			elevation: 2,
		},
		medium: {
			shadowOffset: { width: 0, height: 2 },
			shadowOpacity: 0.8,
			shadowRadius: 4,
			elevation: 4,
		},
		large: {
			shadowOffset: { width: 0, height: 4 },
			shadowOpacity: 0.8,
			shadowRadius: 8,
			elevation: 8,
		},
	},
	platform: {
		topInset: Platform.OS === "ios" ? (DefaultTheme.dark ? 44 : 50) : 16,
		bottomInset: Platform.OS === "ios" ? 34 : 16,
		isIOS: Platform.OS === "ios",
		isAndroid: Platform.OS === "android",
	},
};
export type ThemeColors = typeof theme.colors.light;
export type ThemeMode = "light" | "dark";
</file>

<file path="pnpm-workspace.yaml">
packages:
  - apps/*
catalog:
  '@biomejs/biome': 1.9.4
  typescript: ~5.8.3
catalogs:
  react18:
    react: 18.3.1
    react-dom: 18.3.1
    '@types/react': ^18.3.3
    '@types/react-dom': ^18.3.0
  react-native:
    react: 19.0.0
    react-dom: 19.0.0
    react-native: 0.79.0
    '@types/react': ~19.0.10
nodeLinker: hoisted
onlyBuiltDependencies:
  - '@biomejs/biome'
</file>

<file path="apps/merchant-app/app/index.tsx">
import { Box, Text } from "@/components/ui";
import { useTheme } from "@/hooks/useTheme";
import * as Haptics from "expo-haptics";
import React, { useState, useCallback, useRef, useMemo } from "react";
import { FlatList, RefreshControl, StyleSheet, View } from "react-native";
import Animated, {
	useSharedValue,
	useAnimatedStyle,
	useAnimatedScrollHandler,
	FadeInUp,
	withTiming,
} from "react-native-reanimated";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { DashboardHeader } from "@/components/dashboard/DashboardHeader";
import { TodayPrepCard } from "@/components/dashboard/PrepCard";
import { StatsGrid } from "@/components/dashboard/StatsGrid";
import { Tabs } from "@/components/ui/Tabs";
import { AlertsCard } from "@/components/dashboard/AlertsCard";
import { Alert, MealPrepSummary, StatItem } from "@/types";
const TODAY_PREP_SUMMARY: MealPrepSummary[] = [
	{
		period: "Breakfast",
		totalMeals: 25,
		mealsToPrep: [
			{ id: "shashuka", name: "Shashuka", count: 15 },
			{ id: "oats", name: "Overnight Oats", count: 7 },
			{ id: "smoothie", name: "Green Smoothie", count: 3 },
		],
	},
	{
		period: "Lunch",
		totalMeals: 32,
		mealsToPrep: [
			{ id: "salad_x", name: "Quinoa Salad", count: 18 },
			{ id: "wrap_y", name: "Falafel Wrap", count: 10 },
			{ id: "soup_z", name: "Lentil Soup", count: 4 },
			{ id: "extra1", name: "Side Salad", count: 2 },
		],
	},
	{
		period: "Dinner",
		totalMeals: 28,
		mealsToPrep: [
			{ id: "salmon", name: "Grilled Salmon", count: 12 },
			{ id: "tofu_stirfry", name: "Tofu Stir-fry", count: 9 },
			{ id: "pasta_veg", name: "Veggie Pasta", count: 7 },
		],
	},
];
const getActivityStats = (tab: string): StatItem[] => {
	switch (tab) {
		case "Week":
			return [
				{ title: "Active Subs", value: 52, icon: "people-outline" },
				{ title: "New This Week", value: "+3", icon: "add-circle-outline" },
			];
		case "Month":
			return [
				{ title: "Active Subs", value: 52, icon: "people-outline" },
				{ title: "New This Month", value: "+12", icon: "add-circle-outline" },
			];
		default:
			return [
				{ title: "Active Subs", value: 52, icon: "people-outline" },
				{ title: "Meals Today", value: 85, icon: "restaurant-outline" },
			];
	}
};
const ALERTS: Alert[] = [
	{
		id: 1,
		type: "info",
		title: "New 'Keto Weekly' subscriber",
		icon: "person-add-outline",
		timestamp: "3h ago",
	},
	{
		id: 2,
		type: "warning",
		title: "Low inventory: Quinoa",
		icon: "cube-outline",
		timestamp: "1h ago",
	},
	{
		id: 3,
		type: "error",
		title: "Delivery issue Order #12345",
		icon: "car-sport-outline",
		timestamp: "Yesterday",
	},
];
const HEADER_HEIGHT = 65;
const PREP_CARD_WIDTH = 170;
const HomeScreen: React.FC = () => {
	const theme = useTheme();
	const insets = useSafeAreaInsets();
	const [refreshing, setRefreshing] = useState(false);
	const [selectedTab, setSelectedTab] = useState("Today");
	const scrollY = useSharedValue(0);
	const scrollRef = useRef<Animated.FlatList<any>>(null);
	const tabItems = ["Today", "Week", "Month"];
	const currentStats = useMemo(
		() => getActivityStats(selectedTab),
		[selectedTab],
	);
	const currentDateString = useMemo(
		() =>
			new Date().toLocaleDateString(undefined, {
				weekday: "long",
				month: "short",
				day: "numeric",
			}),
		[],
	);
	const handleRefresh = useCallback(() => {
		setRefreshing(true);
		Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
		setTimeout(() => setRefreshing(false), 1200);
	}, []);
	const handleSelectTab = useCallback(
		(tab: string) => {
			if (tab !== selectedTab) {
				Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
				setSelectedTab(tab);
			}
		},
		[selectedTab],
	);
	const handleViewSchedule = useCallback((period?: string) => {
		console.log("Navigate to Schedule Screen, Filter:", period || "Full");
	}, []);
	const handleViewAlert = useCallback((id: string | number) => {
		console.log("Navigate to Alert Details Screen, ID:", id);
	}, []);
	const handleViewAllAlerts = useCallback(() => {
		console.log("Navigate to All Alerts Screen");
	}, []);
	const handleSettingsPress = useCallback(() => {
		console.log("Navigate to Settings Screen");
	}, []);
	const scrollHandler = useAnimatedScrollHandler((event) => {
		const offsetY = event.contentOffset.y;
		scrollY.value = withTiming(offsetY, { duration: 150 });
	});
	const headerAnimatedStyle = useAnimatedStyle(() => {
		return {
			backgroundColor: theme.colors.background,
			shadowColor: theme.colors.shadow,
			shadowOffset: { width: 0, height: 1 },
			shadowRadius: 3,
			shadowOpacity: scrollY.value > 2 ? (theme.isDark ? 0.3 : 0.1) : 0,
			borderBottomWidth: scrollY.value > 2 ? StyleSheet.hairlineWidth : 0,
			borderBottomColor: theme.colors.divider,
			elevation: scrollY.value > 2 ? 3 : 0,
			zIndex: 1000,
		};
	});
	const renderHeader = useCallback(
		() => (
			<>
				<Box marginHorizontal="md" marginBottom="lg">
					<Tabs
						tabs={tabItems}
						selectedTab={selectedTab}
						onSelectTab={handleSelectTab}
						theme={theme}
					/>
				</Box>
				<StatsGrid stats={currentStats} theme={theme} key={selectedTab} />
				<Text
					variant="lg"
					weight="semibold"
					marginHorizontal="md"
					marginBottom="sm"
				>
					Today's Prep
				</Text>
				<Animated.View
					entering={FadeInUp.delay(300).duration(400).springify().damping(15)}
				>
					<FlatList<MealPrepSummary>
						horizontal
						data={TODAY_PREP_SUMMARY}
						keyExtractor={(item) => item.period}
						showsHorizontalScrollIndicator={false}
						contentContainerStyle={[
							{
								paddingHorizontal: theme.spacing.md,
								paddingVertical: theme.spacing.sm,
								gap: theme.spacing.sm,
							},
						]}
						snapToInterval={PREP_CARD_WIDTH + theme.spacing.sm}
						decelerationRate="fast"
						renderItem={({ item }) => (
							<TodayPrepCard
								summary={item}
								theme={theme}
								onPress={() => handleViewSchedule(item.period)}
							/>
						)}
					/>
				</Animated.View>
				<AlertsCard
					alerts={ALERTS}
					theme={theme}
					onViewAlert={handleViewAlert}
					onViewAllAlerts={handleViewAllAlerts}
				/>
			</>
		),
		[
			selectedTab,
			currentStats,
			theme,
			handleSelectTab,
			handleViewSchedule,
			handleViewAlert,
			handleViewAllAlerts,
		],
	);
	return (
		<View style={[{ flex: 1, backgroundColor: theme.colors.background }]}>
			<DashboardHeader
				theme={theme}
				insets={insets}
				animatedStyle={headerAnimatedStyle}
				currentDateString={currentDateString}
				onSettingsPress={handleSettingsPress}
				headerHeight={HEADER_HEIGHT}
			/>
			<Animated.FlatList
				ref={scrollRef}
				data={[1]}
				keyExtractor={() => "main"}
				showsVerticalScrollIndicator={false}
				contentContainerStyle={{
					paddingTop: HEADER_HEIGHT + insets.top + theme.spacing.md,
					paddingBottom: insets.bottom + theme.spacing.xxl,
				}}
				renderItem={() => renderHeader()}
				onScroll={scrollHandler}
				scrollEventThrottle={16}
				refreshControl={
					<RefreshControl
						refreshing={refreshing}
						onRefresh={handleRefresh}
						tintColor={theme.colors.primary}
						colors={[theme.colors.primary]}
						progressBackgroundColor={theme.colors.card}
						progressViewOffset={HEADER_HEIGHT + insets.top + theme.spacing.sm}
					/>
				}
			/>
		</View>
	);
};
export default HomeScreen;
</file>

<file path="apps/merchant-app/app/_layout.tsx">
import { ThemeProvider } from "@react-navigation/native";
import { useFonts } from "expo-font";
import { Stack } from "expo-router";
import * as SplashScreen from "expo-splash-screen";
import { StatusBar } from "expo-status-bar";
import { useEffect } from "react";
import "react-native-reanimated";
import { SafeAreaProvider } from "react-native-safe-area-context";
import { useTheme } from "@/hooks/useTheme";
import { LogBox } from "react-native";
LogBox.ignoreLogs([
	"Sending `onAnimatedValueUpdate` with no listeners registered.",
]);
SplashScreen.preventAutoHideAsync();
export default function RootLayout() {
	const { isDark, navTheme, colors } = useTheme();
	const [loaded, error] = useFonts({
		SpaceMono: require("../assets/fonts/SpaceMono-Regular.ttf"),
	});
	useEffect(() => {
		if (error) throw error;
	}, [error]);
	useEffect(() => {
		if (loaded) {
			SplashScreen.hideAsync();
		}
	}, [loaded]);
	if (!loaded) {
		return null;
	}
	return (
		<SafeAreaProvider>
			<ThemeProvider value={navTheme}>
				<Stack
					screenOptions={{
						headerShown: false,
						animation: "slide_from_right",
						contentStyle: {
							backgroundColor: colors.background,
						},
					}}
				>
					<Stack.Screen name="index" />
					<Stack.Screen name="+not-found" />
				</Stack>
				<StatusBar style={isDark ? "light" : "dark"} />
			</ThemeProvider>
		</SafeAreaProvider>
	);
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
node_modules
.pnp
.pnp.js

# testing
coverage

# next.js
.next/
out/
next-env.d.ts
#sveltekit
.svelte-kit
# nitro
.nitro/
.output/

# expo
.expo
expo-env.d.ts
ios/
android/
*.gen.ts

# production
build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# local env files
.env
.env*.local

# typescript
*.tsbuildinfo
dist/

# turbo
.turbo




# Output
.cache
.output
.vercel
/.svelte-kit
/build

# OS
.DS_Store
Thumbs.db

# Env
.env
.env.*
!.env.example
!.env.test

# Vite
vite.config.js.timestamp-*
vite.config.ts.timestamp-*
.maestro/tests/
messages.js
</file>

</files>
