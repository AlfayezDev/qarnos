This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/*.log, tmp/, **/Illustrations/**, **/*.json, **/Localization.ts, **/SVGS/**, **/generated/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
apps/
  merchant-app/
    app/
      (meals)/
        meals/
          [meal-id].tsx
        meals.tsx
      _layout.tsx
      index.tsx
      settings.tsx
    components/
      common/
        BackButton.tsx
        ErrorBoundary.tsx
      compound/
        form/
          Form.tsx
          FormCategory.tsx
          FormInput.tsx
          FormRadio.tsx
          FormSwitch.tsx
          index.tsx
      dashboard/
        AlertRow.tsx
        AlertsCard.tsx
        PrepCard.tsx
        StatsGrid.tsx
      fields/
        CategoryField.tsx
        FocusableInput.tsx
        RadioField.tsx
        SwitchField.tsx
      layouts/
        ResponsiveContainer.tsx
        ScreenContainer.tsx
      meal/
        DeleteButton.tsx
        MealCard.tsx
        MealFormBasicInfo.tsx
        MealFormHeader.tsx
        MealImagePreview.tsx
      navigation/
        FloatingTabBar.tsx
      ui/
        Avatar.tsx
        Badge.tsx
        Box.tsx
        Button.tsx
        Card.tsx
        index.ts
        Tabs.tsx
        Text.tsx
      LanguageSelector.tsx
    constants/
      theme/
        animations.ts
        colors.ts
        index.ts
        platform.ts
        radius.ts
        shadows.ts
        sizes.ts
        spacing.ts
        typography.ts
      i18n.ts
    hooks/
      useColorScheme/
        index.ts
        useColorScheme.web.ts
      useLanguage.ts
      useMealForm.ts
      useMemoizedCallback.ts
      useResponsiveLayout.ts
      useResponsiveStyles.ts
      useZodForm.ts
    schemas/
      mealSchema.ts
    stores/
      mealStore.ts
      themeStore.ts
      translationStore.ts
    utils/
      validation.ts
    .gitignore
    data.ts
    style.d.ts
    types.ts
.gitignore
.npmrc
.nvimrc
.repomixignore
pnpm-workspace.yaml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="apps/merchant-app/app/(meals)/meals/[meal-id].tsx">
import React, { useState } from "react";
import { KeyboardAvoidingView, Platform, ScrollView, View } from "react-native";
import { Stack, useLocalSearchParams, useRouter } from "expo-router";
import Animated, { FadeInRight, FadeInUp } from "react-native-reanimated";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { Ionicons } from "@expo/vector-icons";
import { AnimatedBox, Box, Button, Text } from "@/components/ui";
import { TabType, Tabs } from "@/components/ui/Tabs";
import { ErrorBoundary } from "@/components/common/ErrorBoundary";
import { MealFormHeader } from "@/components/meal/MealFormHeader";
import { MealImagePreview } from "@/components/meal/MealImagePreview";
import {
	Form,
	FormCategory,
	FormInput,
	FormRadio,
	FormSwitch,
} from "@/components/compound/form";
import { mealSchema } from "@/schemas/mealSchema";
import {
	caloriesSchema,
	descriptionSchema,
	nameSchema,
	priceSchema,
} from "@/utils/validation";
import { useResponsiveLayout } from "@/hooks/useResponsiveLayout";
import { useMealForm } from "@/hooks/useMealForm";
import { useTheme } from "@/stores/themeStore";
import { useTranslation } from "@/stores/translationStore";
const MealFormScreen = () => {
	const { "meal-id": mealId } = useLocalSearchParams<{ "meal-id": string }>();
	const theme = useTheme();
	const { t, language } = useTranslation();
	const insets = useSafeAreaInsets();
	const router = useRouter();
	const { isTablet, isLandscape } = useResponsiveLayout();
	const isArabic = language === "ar";
	const useTwoColumnLayout = isTablet && isLandscape;
	const [activeSection, setActiveSection] = useState<string>("basic");
	const {
		meal,
		loading,
		isEdit,
		handleFormSubmit,
		handleDelete,
		handleSelectImage,
	} = useMealForm(mealId);
	const periodOptions = [
		{ value: "Breakfast", label: t("periods.breakfast"), icon: "cafe-outline" },
		{ value: "Lunch", label: t("periods.lunch"), icon: "restaurant-outline" },
		{ value: "Dinner", label: t("periods.dinner"), icon: "fast-food-outline" },
	];
	const dietaryOptions = [
		{ value: "none", label: "Regular", description: "No dietary restrictions" },
		{
			value: "vegetarian",
			label: "Vegetarian",
			description: "No meat, may include dairy and eggs",
		},
		{ value: "vegan", label: "Vegan", description: "No animal products" },
		{
			value: "glutenFree",
			label: "Gluten Free",
			description: "No wheat or gluten",
		},
	];
	const sectionTabs: TabType[] = [
		{
			key: "basic",
			label: t("meals.basicInfo"),
			iconLeft: "information-circle-outline",
		},
		{
			key: "settings",
			label: t("common.settings"),
			iconLeft: "settings-outline",
		},
	];
	return (
		<ErrorBoundary>
			<KeyboardAvoidingView
				style={{ flex: 1 }}
				behavior={Platform.OS === "ios" ? "padding" : "height"}
			>
				<View
					style={{
						flex: 1,
						backgroundColor: theme.colors.background,
						paddingTop: insets.top,
					}}
				>
					<Stack.Screen options={{ headerShown: false }} />
					<MealFormHeader
						title={t("meals.addNew")}
						isEdit={isEdit}
						mealName={meal?.name}
						mealNameAr={meal?.name_ar}
						onDelete={handleDelete}
					/>
					<ScrollView
						style={{ flex: 1 }}
						contentContainerStyle={{
							padding: theme.spacing.md,
							paddingBottom: insets.bottom + theme.spacing.xxl,
							gap: theme.spacing.md,
						}}
						showsVerticalScrollIndicator={false}
						keyboardShouldPersistTaps="handled"
					>
						<MealImagePreview
							image={meal?.image}
							name={meal?.name}
							nameAr={meal?.name_ar}
							calories={meal?.calories}
							prepTime={meal?.prepTime}
							onSelectImage={handleSelectImage}
						/>
						<AnimatedBox
							entering={FadeInUp.delay(200).duration(400)}
							bg="backgroundAlt"
							rounded="lg"
						>
							<Tabs
								tabs={sectionTabs}
								selectedTab={activeSection}
								onSelectTab={setActiveSection}
								accessibilityLabel="Section Tabs"
							/>
						</AnimatedBox>
						<Form
							schema={mealSchema}
							initialValues={meal}
							onSubmit={handleFormSubmit}
						>
							{activeSection === "basic" && (
								<Animated.View
									entering={FadeInRight.delay(100).duration(100)}
									key={activeSection}
									style={
										useTwoColumnLayout
											? {
													flexDirection: "row",
													flexWrap: "wrap",
													justifyContent: "space-between",
												}
											: { gap: theme.spacing.md }
									}
								>
									<View
										style={[
											useTwoColumnLayout ? { width: "48%" } : { width: "100%" },
										]}
									>
										<Box
											card
											rounded="md"
											padding="lg"
											elevation="small"
											gap={"md"}
										>
											<Box row alignItems="center">
												<Ionicons
													name="information-circle-outline"
													size={theme.sizes.iconSm}
													color={theme.colors.primary}
													style={{ marginEnd: theme.spacing.sm }}
												/>
												<Text variant="lg" weight="semibold">
													{t("meals.basicInfo")}
												</Text>
											</Box>
											<Box gap={"md"}>
												<FormInput
													name="name"
													label={t("meals.mealName")}
													required
													placeholder={t("meals.mealName")}
													schema={nameSchema}
												/>
												<FormInput
													name="name_ar"
													label={`${t("meals.mealName")} (العربية)`}
													placeholder={`${t("meals.mealName")} (العربية)`}
													textAlign={isArabic ? "right" : "left"}
												/>
											</Box>
											<Box>
												<FormInput
													name="description"
													label={t("meals.description")}
													required
													placeholder={t("meals.description")}
													multiline={true}
													numberOfLines={4}
													textAlignVertical="top"
													schema={descriptionSchema}
												/>
												<FormInput
													name="description_ar"
													label={`${t("meals.description")} (العربية)`}
													placeholder={`${t("meals.description")} (العربية)`}
													multiline={true}
													numberOfLines={4}
													textAlign={isArabic ? "right" : "left"}
													textAlignVertical="top"
												/>
											</Box>
											<FormCategory
												name="period"
												label={t("meals.mealPeriod")}
												options={periodOptions}
												required
											/>
											<FormRadio
												name="dietaryRestriction"
												label="Dietary Restrictions"
												options={dietaryOptions}
											/>
										</Box>
									</View>
									<View
										style={
											useTwoColumnLayout
												? { width: "48%", marginTop: 0 }
												: { width: "100%", marginTop: theme.spacing.md }
										}
									>
										<Box
											card
											rounded="md"
											padding="lg"
											elevation="small"
											gap={"md"}
										>
											<Box row alignItems="center">
												<Ionicons
													name="list-outline"
													size={theme.sizes.iconSm}
													color={theme.colors.primary}
													style={{ marginEnd: theme.spacing.sm }}
												/>
												<Text variant="lg" weight="semibold">
													{t("meals.details")}
												</Text>
											</Box>
											<Box row gap="md">
												<Box flex={1}>
													<FormInput
														name="price"
														label={t("meals.price")}
														required
														placeholder="0.00"
														keyboardType="numeric"
														schema={priceSchema}
														style={{
															paddingLeft: 36,
															fontSize: theme.typography.sizes.lg,
															fontWeight: theme.typography.weights.semibold,
														}}
													/>
													<Box
														style={{
															position: "absolute",
															left: theme.spacing.md,
															top: 20,
															bottom: 0,
															justifyContent: "center",
															zIndex: 1,
														}}
													>
														<Text variant="md" color="textSecondary">
															$
														</Text>
													</Box>
												</Box>
												<Box flex={1}>
													<FormInput
														name="calories"
														label={t("meals.calories")}
														placeholder="0"
														keyboardType="numeric"
														schema={caloriesSchema}
													/>
													<Box
														style={{
															position: "absolute",
															right: theme.spacing.md,
															top: 20,
															bottom: 0,
															justifyContent: "center",
															zIndex: 1,
														}}
													>
														<Text variant="md" color="textSecondary">
															cal
														</Text>
													</Box>
												</Box>
											</Box>
										</Box>
									</View>
								</Animated.View>
							)}
							{activeSection === "settings" && (
								<AnimatedBox
									entering={FadeInRight.delay(100).duration(100)}
									key={activeSection}
									gap={"md"}
								>
									<Box
										card
										rounded="md"
										padding="lg"
										elevation="small"
										gap={"md"}
									>
										<Box row alignItems="center">
											<Ionicons
												name="settings-outline"
												size={theme.sizes.iconSm}
												color={theme.colors.primary}
												style={{ marginEnd: theme.spacing.sm }}
											/>
											<Text variant="lg" weight="semibold">
												{t("common.settings")}
											</Text>
										</Box>
										<FormSwitch
											name="available"
											label={
												meal?.available
													? t("meals.available")
													: t("meals.unavailable")
											}
											description={
												meal?.available
													? t("meals.availableDesc")
													: t("meals.unavailableDesc")
											}
											leftIcon={
												meal?.available
													? "checkmark-circle-outline"
													: "close-circle-outline"
											}
										/>
										<FormSwitch
											name="featured"
											label={t("meals.featured")}
											description={t("meals.featuredDesc")}
											leftIcon="star-outline"
										/>
										<FormSwitch
											name="isVegan"
											label="Vegan"
											description="This meal contains no animal products"
											leftIcon="leaf-outline"
										/>
									</Box>
									{isEdit && (
										<Box
											bg="error"
											padding="md"
											rounded="md"
											style={{ opacity: 0.9 }}
											gap={"xs"}
										>
											<Box row alignItems="center">
												<Ionicons
													name="warning-outline"
													size={theme.sizes.iconMd}
													color="#fff"
													style={{ marginEnd: theme.spacing.sm }}
												/>
												<Text variant="md" weight="semibold" color="#fff">
													{t("meals.dangerZone")}
												</Text>
											</Box>
											<Text variant="sm" color="#fff">
												{t("meals.deleteMealWarning")}
											</Text>
											<Button
												title={t("common.delete")}
												variant="outline"
												size="md"
												style={{ borderColor: "#fff" }}
												textColor="#fff"
												onPress={handleDelete}
												accessibilityLabel={t("common.delete")}
											/>
										</Box>
									)}
								</AnimatedBox>
							)}
							<AnimatedBox
								entering={FadeInUp.delay(300).duration(400)}
								marginTop="lg"
							>
								<Form.SubmitButton>
									{({ onPress, isValid, isDirty }) => (
										<Button
											title={
												isEdit ? t("meals.saveChanges") : t("meals.createMeal")
											}
											variant="primary"
											size="lg"
											loading={loading}
											fullWidth
											rounded
											leftIcon="save-outline"
											onPress={onPress}
											disabled={!isValid || !isDirty}
											accessibilityLabel={
												isEdit ? t("meals.saveChanges") : t("meals.createMeal")
											}
										/>
									)}
								</Form.SubmitButton>
								{!isEdit && (
									<Button
										title={t("common.cancel")}
										variant="ghost"
										size="lg"
										fullWidth
										style={{ marginTop: theme.spacing.md }}
										onPress={() => router.back()}
										accessibilityLabel={t("common.cancel")}
									/>
								)}
							</AnimatedBox>
						</Form>
					</ScrollView>
				</View>
			</KeyboardAvoidingView>
		</ErrorBoundary>
	);
};
export default MealFormScreen;
</file>

<file path="apps/merchant-app/app/(meals)/meals.tsx">
import React, { useState, useCallback } from "react";
import { FlatList, View } from "react-native";
import { Ionicons } from "@expo/vector-icons";
import Animated, { FadeInUp } from "react-native-reanimated";
import * as Haptics from "expo-haptics";
import { AnimatedBox, Box, Text } from "@/components/ui";
import { Tabs } from "@/components/ui/Tabs";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import MealCard from "@/components/meal/MealCard";
import { useMealStore } from "@/stores/mealStore";
import { useTheme } from "@/stores/themeStore";
import { useTranslation } from "@/stores/translationStore";
const MealScreen = () => {
	const theme = useTheme();
	const { t } = useTranslation();
	const [selectedPeriod, setSelectedPeriod] = useState<string>("Breakfast");
	const insets = useSafeAreaInsets();
	const { meals } = useMealStore();
	const periods = ["Breakfast", "Lunch", "Dinner"];
	const filteredMeals = meals.filter((meal) => meal.period === selectedPeriod);
	const handleSelectPeriod = useCallback(
		(period: string) => {
			if (period !== selectedPeriod) {
				Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
				setSelectedPeriod(period);
			}
		},
		[selectedPeriod],
	);
	function renderEmptyList() {
		return (
			<View
				style={{
					flex: 1,
					alignItems: "center",
					justifyContent: "center",
					padding: theme.spacing.xl,
				}}
			>
				<Ionicons
					name="restaurant-outline"
					size={theme.sizes.iconLg}
					color={theme.colors.textMuted}
					style={{ marginBottom: theme.spacing.md }}
				/>
				<Text variant="lg" weight="semibold" color="textSecondary" center>
					{t("meals.noMeals")}
				</Text>
				<Text variant="md" color="textMuted" center marginTop="xs">
					{t("meals.addFirstMeal")}
				</Text>
			</View>
		);
	}
	return (
		<View
			style={{
				flex: 1,
				backgroundColor: theme.colors.background,
				paddingTop: insets.top,
			}}
		>
			<Box
				row
				alignItems="center"
				paddingHorizontal="md"
				paddingVertical="sm"
				style={{
					height: theme.sizes.headerHeight,
				}}
			>
				<Text variant="xl" weight="semibold" numberOfLines={1}>
					{t("meals.title")}
				</Text>
			</Box>
			<AnimatedBox
				marginHorizontal="md"
				gap="lg"
				entering={FadeInUp.delay(50).duration(400).springify().damping(15)}
			>
				<Tabs
					tabs={periods}
					selectedTab={selectedPeriod}
					onSelectTab={handleSelectPeriod}
					labelRender={(tab) => t(`periods.${tab.toLowerCase()}`)}
				/>
			</AnimatedBox>
			<Animated.View style={{ flex: 1 }}>
				{filteredMeals.length > 0 ? (
					<FlatList
						data={filteredMeals}
						keyExtractor={(item) => item.id}
						renderItem={({ item }) => <MealCard item={item} />}
						showsVerticalScrollIndicator={false}
						contentContainerStyle={{
							padding: theme.spacing.md,
							paddingBottom: theme.spacing.xxl,
							gap: theme.spacing.md,
						}}
					/>
				) : (
					renderEmptyList()
				)}
			</Animated.View>
		</View>
	);
};
export default MealScreen;
</file>

<file path="apps/merchant-app/components/navigation/FloatingTabBar.tsx">
import React, {
	PropsWithChildren,
	forwardRef,
	ForwardRefRenderFunction,
} from "react";
import { Pressable, StyleSheet, View } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { Ionicons } from "@expo/vector-icons";
import { Box, Text } from "@/components/ui";
import { useTheme } from "@/stores/themeStore";
type TabButtonProps = {
	icon: string;
	label: string;
	isFocused?: boolean;
	onPress?: () => void;
	route?: string;
};
export const TabButton = ({
	icon,
	label,
	isFocused,
	onPress,
}: TabButtonProps) => {
	const { colors, radius } = useTheme();
	return (
		<Pressable style={[styles.tabItem]} onPress={onPress}>
			<Box
				alignCenter
				style={[
					styles.tabItem,
					isFocused && {
						backgroundColor: colors.primaryLight,
						borderRadius: radius.lg,
					},
				]}
			>
				<Ionicons
					name={icon as any}
					size={24}
					color={isFocused ? colors.primary : colors.textMuted}
				/>
				<Text
					variant="xs"
					weight={isFocused ? "medium" : "regular"}
					color={isFocused ? "primary" : "textMuted"}
					marginTop="xs"
				>
					{label}
				</Text>
			</Box>
		</Pressable>
	);
};
type FloatingTabBarLayoutProps = PropsWithChildren<{
	style?: React.ComponentProps<typeof View>["style"];
}>;
const FloatingTabBarLayoutComponent: ForwardRefRenderFunction<
	View,
	FloatingTabBarLayoutProps
> = ({ children, style }, ref) => {
	const { colors, radius } = useTheme();
	const insets = useSafeAreaInsets();
	return (
		<View
			ref={ref}
			style={[
				styles.container,
				{ paddingBottom: insets.bottom ? insets.bottom : 16 },
				style,
			]}
		>
			<Box
				style={[
					styles.tabBarContainer,
					{
						backgroundColor: colors.card,
						borderRadius: radius.xl,
						shadowColor: colors.shadow,
						shadowOffset: { width: 0, height: 4 },
						shadowOpacity: 0.15,
						shadowRadius: 16,
						elevation: 8,
						borderWidth: 1,
						borderColor: colors.divider,
					},
				]}
			>
				{children}
			</Box>
		</View>
	);
};
export const FloatingTabBarLayout = forwardRef(FloatingTabBarLayoutComponent);
const styles = StyleSheet.create({
	container: {
		position: "absolute",
		bottom: 16,
		left: 16,
		right: 16,
	},
	tabBarContainer: {
		flexDirection: "row",
		paddingVertical: 10,
		paddingHorizontal: 16,
		width: "100%",
	},
	tabItem: {
		flex: 1,
		paddingVertical: 8,
		paddingHorizontal: 12,
		alignItems: "center",
		width: "100%",
	},
});
</file>

<file path="apps/merchant-app/components/ui/index.ts">
export * from "./Box";
export * from "./Text";
export * from "./Button";
export * from "./Avatar";
export * from "./Card";
export * from "./Badge";
export * from "./Tabs";
</file>

<file path="apps/merchant-app/constants/i18n.ts">
export const translations = {
	en: {
		common: {
			settings: "Settings",
			dashboard: "Dashboard",
			meals: "Meals",
			cancel: "Cancel",
			save: "Save",
			delete: "Delete",
			edit: "Edit",
			loading: "Loading...",
			total: "Total",
			more: "more",
			back: "Back",
			version: "Version",
		},
		search: {
			title: "Search",
			placeholder: "Search...",
			noResults: "No results found for",
			recentSearches: "Recent Searches",
			clear: "Clear",
		},
		settings: {
			title: "Settings",
			language: "Language",
			theme: "Appearance",
			notifications: "Notifications",
			about: "About",
			logout: "Logout",
			lightMode: "Light",
			darkMode: "Dark",
			systemTheme: "System",
			signedInAs: "Signed in as",
			appInfo: "App Information",
		},
		dashboard: {
			title: "Dashboard",
			todaysPrep: "Today's Prep",
			activeSubscriptions: "Active Subs",
			newThisWeek: "New This Week",
			newThisMonth: "New This Month",
			mealsToday: "Meals Today",
			alerts: "Alerts",
			viewAll: "View all",
			allCaughtUp: "You're all caught up!",
			noAlerts: "No pressing alerts at the moment",
			prepList: "Prep List:",
			today: "Today",
			week: "Week",
			month: "Month",
		},
		meals: {
			title: "Meal Management",
			addNew: "Add New Meal",
			noMeals: "No meals found",
			addFirstMeal: "Add your first meal to get started",
			mealName: "Meal Name",
			description: "Description",
			price: "Price ($)",
			calories: "Calories",
			prepTime: "Prep Time (min)",
			ingredients: "Ingredients (comma separated)",
			mealPeriod: "Meal Period",
			createMeal: "Create Meal",
			saveChanges: "Save Changes",
			confirmDelete: "Are you sure you want to delete this meal?",
			basicInfo: "Basic Information",
			details: "Details",
			available: "Available",
			unavailable: "Unavailable",
			availableDesc: "This meal is visible to customers",
			unavailableDesc: "This meal is hidden from customers",
			featured: "Featured Meal",
			featuredDesc: "Show this meal in featured sections",
			dangerZone: "Danger Zone",
			deleteMealWarning: "Once deleted, this meal cannot be recovered.",
			addImage: "Add Image",
		},
		periods: {
			breakfast: "Breakfast",
			lunch: "Lunch",
			dinner: "Dinner",
		},
		alerts: {
			warning: "Warning",
			info: "Info",
			error: "Error",
		},
	},
	ar: {
		common: {
			settings: "الإعدادات",
			dashboard: "لوحة التحكم",
			meals: "الوجبات",
			cancel: "إلغاء",
			save: "حفظ",
			delete: "حذف",
			edit: "تعديل",
			loading: "جاري التحميل...",
			total: "المجموع",
			more: "المزيد",
			back: "رجوع",
			version: "الإصدار",
		},
		search: {
			title: "بحث",
			placeholder: "بحث...",
			noResults: "لا توجد نتائج لـ",
			recentSearches: "عمليات البحث الأخيرة",
			clear: "مسح",
		},
		settings: {
			title: "الإعدادات",
			language: "اللغة",
			theme: "المظهر",
			notifications: "الإشعارات",
			about: "حول",
			logout: "تسجيل الخروج",
			lightMode: "فاتح",
			darkMode: "داكن",
			systemTheme: "النظام",
			signedInAs: "مسجل الدخول كـ",
			appInfo: "معلومات التطبيق",
		},
		dashboard: {
			title: "لوحة التحكم",
			todaysPrep: "تحضير اليوم",
			activeSubscriptions: "الاشتراكات النشطة",
			newThisWeek: "جديد هذا الأسبوع",
			newThisMonth: "جديد هذا الشهر",
			mealsToday: "وجبات اليوم",
			alerts: "التنبيهات",
			viewAll: "عرض الكل",
			allCaughtUp: "أنت على اطلاع بكل شيء!",
			noAlerts: "لا توجد تنبيهات ملحة في الوقت الحالي",
			prepList: "قائمة التحضير:",
			today: "اليوم",
			week: "الأسبوع",
			month: "الشهر",
		},
		meals: {
			title: "إدارة الوجبات",
			addNew: "إضافة وجبة جديدة",
			noMeals: "لم يتم العثور على وجبات",
			addFirstMeal: "أضف وجبتك الأولى للبدء",
			mealName: "اسم الوجبة",
			description: "الوصف",
			price: "السعر ($)",
			calories: "السعرات الحرارية",
			prepTime: "وقت التحضير (دقيقة)",
			ingredients: "المكونات (مفصولة بفواصل)",
			mealPeriod: "فترة الوجبة",
			createMeal: "إنشاء وجبة",
			saveChanges: "حفظ التغييرات",
			confirmDelete: "هل أنت متأكد من حذف هذه الوجبة؟",
			basicInfo: "المعلومات الأساسية",
			details: "التفاصيل",
			available: "متاح",
			unavailable: "غير متاح",
			availableDesc: "هذه الوجبة مرئية للعملاء",
			unavailableDesc: "هذه الوجبة مخفية عن العملاء",
			featured: "وجبة مميزة",
			featuredDesc: "عرض هذه الوجبة في الأقسام المميزة",
			dangerZone: "منطقة الخطر",
			deleteMealWarning: "بمجرد الحذف، لا يمكن استعادة هذه الوجبة.",
			addImage: "إضافة صورة",
		},
		periods: {
			breakfast: "الإفطار",
			lunch: "الغداء",
			dinner: "العشاء",
		},
		alerts: {
			warning: "تحذير",
			info: "معلومات",
			error: "خطأ",
		},
	},
};
export type Language = keyof typeof translations;
</file>

<file path="apps/merchant-app/hooks/useColorScheme/index.ts">
export { useColorScheme } from 'react-native';
</file>

<file path="apps/merchant-app/hooks/useColorScheme/useColorScheme.web.ts">
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);
  useEffect(() => {
    setHasHydrated(true);
  }, []);
  const colorScheme = useRNColorScheme();
  if (hasHydrated) {
    return colorScheme;
  }
  return 'light';
}
</file>

<file path="apps/merchant-app/.gitignore">
# @generated expo-cli sync-2b81b286409207a5da26e14c78851eb30d8ccbdb
# The following patterns were generated by expo-cli

expo-env.d.ts
# @end expo-cli
</file>

<file path="apps/merchant-app/data.ts">
import { Feather } from "@expo/vector-icons";
import { Alert, Meal, MealPrepSummary } from "./types";
export const TODAY_PREP_SUMMARY: MealPrepSummary[] = [
	{
		period: "Breakfast",
		totalMeals: 25,
		mealsToPrep: [
			{ id: "shashuka", name: "Shashuka", count: 15 },
			{ id: "oats", name: "Overnight Oats", count: 7 },
			{ id: "smoothie", name: "Green Smoothie", count: 3 },
		],
	},
	{
		period: "Lunch",
		totalMeals: 32,
		mealsToPrep: [
			{ id: "salad_x", name: "Quinoa Salad", count: 18 },
			{ id: "wrap_y", name: "Falafel Wrap", count: 10 },
			{ id: "soup_z", name: "Lentil Soup", count: 4 },
			{ id: "extra1", name: "Side Salad", count: 2 },
		],
	},
	{
		period: "Dinner",
		totalMeals: 28,
		mealsToPrep: [
			{ id: "salmon", name: "Grilled Salmon", count: 12 },
			{ id: "tofu_stirfry", name: "Tofu Stir-fry", count: 9 },
			{ id: "pasta_veg", name: "Veggie Pasta", count: 7 },
		],
	},
];
export const ALERTS: Alert[] = [
	{
		id: 1,
		type: "info",
		title: "New 'Keto Weekly' subscriber",
		icon: "person-add-outline",
		timestamp: "3h ago",
	},
	{
		id: 2,
		type: "warning",
		title: "Low inventory: Quinoa",
		icon: "cube-outline",
		timestamp: "1h ago",
	},
	{
		id: 3,
		type: "error",
		title: "Delivery issue Order #12345",
		icon: "car-sport-outline",
		timestamp: "Yesterday",
	},
];
export const MEALS: Meal[] = [
	{
		featured: false,
		isVegan: false,
		id: "b1",
		name: "Shakshuka",
		name_ar: "شكشوكة",
		description: "Eggs poached in spiced tomato sauce",
		description_ar: "بيض مطبوخ في صلصة طماطم متبلة",
		price: 12.99,
		ingredients: ["Eggs", "Tomatoes", "Bell Peppers", "Onions", "Spices"],
		ingredients_ar: ["بيض", "طماطم", "فلفل حلو", "بصل", "توابل"],
		calories: 380,
		prepTime: 25,
		period: "Breakfast",
		available: true,
		image:
			"https://images.unsplash.com/photo-1590412200988-a436970781fa?w=800&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8Mnx8c2hha3NodWthfGVufDB8fDB8fHww",
	},
	{
		featured: false,
		isVegan: false,
		id: "b2",
		name: "Overnight Oats",
		name_ar: "شوفان مبيت",
		description: "Oats soaked with yogurt and fruits",
		description_ar: "شوفان منقوع مع الزبادي والفواكه",
		price: 8.99,
		ingredients: ["Oats", "Yogurt", "Berries", "Honey", "Nuts"],
		ingredients_ar: ["شوفان", "زبادي", "توت", "عسل", "مكسرات"],
		calories: 320,
		prepTime: 10,
		period: "Breakfast",
		available: true,
		image:
			"https://images.unsplash.com/photo-1614961233913-a5113a4a34ed?w=800&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MTB8fG92ZXJuaWdodCUyMG9hdHN8ZW58MHx8MHx8fDA%3D",
	},
	{
		featured: false,
		isVegan: false,
		id: "l1",
		name: "Quinoa Salad",
		name_ar: "سلطة الكينوا",
		description: "Fresh salad with quinoa and vegetables",
		description_ar: "سلطة طازجة مع الكينوا والخضروات",
		price: 14.99,
		ingredients: ["Quinoa", "Cucumber", "Tomato", "Avocado", "Lemon Dressing"],
		ingredients_ar: ["كينوا", "خيار", "طماطم", "أفوكادو", "صلصة ليمون"],
		calories: 420,
		prepTime: 20,
		period: "Lunch",
		available: true,
		image:
			"https://images.unsplash.com/photo-1505253716362-afaea1d3d1af?w=800&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8NXx8cXVpbm9hJTIwc2FsYWR8ZW58MHx8MHx8fDA%3D",
	},
	{
		featured: false,
		isVegan: false,
		id: "l2",
		name: "Falafel Wrap",
		name_ar: "لفائف الفلافل",
		description: "Falafel with vegetables in a whole wheat wrap",
		description_ar: "فلافل مع الخضروات في خبز القمح الكامل",
		price: 10.99,
		ingredients: ["Falafel", "Lettuce", "Tomato", "Cucumber", "Tahini"],
		ingredients_ar: ["فلافل", "خس", "طماطم", "خيار", "طحينة"],
		calories: 480,
		prepTime: 15,
		period: "Lunch",
		available: true,
		image:
			"https://images.unsplash.com/photo-1565299624946-b28f40a0ae38?w=800&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8M3x8ZmFsYWZlbHxlbnwwfHwwfHx8MA%3D%3D",
	},
	{
		featured: false,
		isVegan: false,
		id: "d1",
		name: "Grilled Salmon",
		name_ar: "سلمون مشوي",
		description: "Fresh salmon with herbs and lemon",
		description_ar: "سلمون طازج مع الأعشاب والليمون",
		price: 18.99,
		ingredients: ["Salmon", "Lemon", "Herbs", "Olive Oil", "Garlic"],
		ingredients_ar: ["سلمون", "ليمون", "أعشاب", "زيت زيتون", "ثوم"],
		calories: 520,
		prepTime: 30,
		period: "Dinner",
		available: true,
		image:
			"https://images.unsplash.com/photo-1519708227418-c8fd9a32b7a2?w=800&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8Mnx8Z3JpbGxlZCUyMHNhbG1vbnxlbnwwfHwwfHx8MA%3D%3D",
	},
	{
		featured: false,
		isVegan: false,
		id: "d2",
		name: "Tofu Stir-fry",
		name_ar: "توفو مقلي",
		description: "Tofu and vegetables in a savory sauce",
		description_ar: "توفو وخضروات في صلصة لذيذة",
		price: 13.99,
		ingredients: ["Tofu", "Broccoli", "Carrots", "Bell Peppers", "Soy Sauce"],
		ingredients_ar: ["توفو", "بروكلي", "جزر", "فلفل حلو", "صلصة الصويا"],
		calories: 380,
		prepTime: 25,
		period: "Dinner",
		available: true,
		image:
			"https://images.unsplash.com/photo-1512003867696-6d5ce6835040?w=800&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8Mnx8dG9mdSUyMHN0aXIlMjBmcnl8ZW58MHx8MHx8fDA%3D",
	},
];
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
node_modules
.pnp
.pnp.js

# testing
coverage

# next.js
.next/
out/
next-env.d.ts
#sveltekit
.svelte-kit
# nitro
.nitro/
.output/

# expo
.expo
expo-env.d.ts
ios/
android/
*.gen.ts

# production
build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# local env files
.env
.env*.local

# typescript
*.tsbuildinfo
dist/

# turbo
.turbo




# Output
.cache
.output
.vercel
/.svelte-kit
/build

# OS
.DS_Store
Thumbs.db

# Env
.env
.env.*
!.env.example
!.env.test

# Vite
vite.config.js.timestamp-*
vite.config.ts.timestamp-*
.maestro/tests/
messages.js
</file>

<file path=".npmrc">
node-linker=hoisted
engine-strict=true
</file>

<file path=".nvimrc">
23.11.0
</file>

<file path="pnpm-workspace.yaml">
packages:
  - apps/*
catalog:
  '@biomejs/biome': 1.9.4
  typescript: ~5.8.3
catalogs:
  react18:
    react: 18.3.1
    react-dom: 18.3.1
    '@types/react': ^18.3.3
    '@types/react-dom': ^18.3.0
  react-native:
    react: 19.0.0
    react-dom: 19.0.0
    react-native: 0.79.0
    '@types/react': ~19.0.10
nodeLinker: hoisted
onlyBuiltDependencies:
  - '@biomejs/biome'
</file>

<file path="apps/merchant-app/components/compound/form/Form.tsx">
import { useZodForm } from "@/hooks/useZodForm";
import React, { createContext, useContext, useMemo } from "react";
import { StyleSheet, View, ViewStyle } from "react-native";
import { z, AnyZodObject } from "zod";
type ZodFormInfer<T extends AnyZodObject> = z.infer<T>;
interface FormContextType<T extends AnyZodObject> {
	values: Partial<ZodFormInfer<T>>;
	errors: Partial<Record<keyof ZodFormInfer<T>, string>>;
	touched: Partial<Record<keyof ZodFormInfer<T>, boolean>>;
	setValue: (field: keyof ZodFormInfer<T>, value: any) => void;
	handleBlur: (field: keyof ZodFormInfer<T>) => void;
	validateForm: () => boolean;
	handleSubmit?: () => void;
	resetForm: (newValues?: Partial<ZodFormInfer<T>>) => void;
	isDirty: boolean;
	isValid: boolean;
}
const FormContext = createContext<FormContextType<any> | null>(null);
interface FormProps<T extends AnyZodObject> {
	schema: T;
	initialValues?: Partial<ZodFormInfer<T>>;
	onSubmit?: (values: ZodFormInfer<T>) => void;
	children:
		| React.ReactNode
		| ((props: {
				values: Partial<ZodFormInfer<T>>;
				errors: Partial<Record<keyof ZodFormInfer<T>, string>>;
				touched: Partial<Record<keyof ZodFormInfer<T>, boolean>>;
				handleSubmit: () => void;
				isValid: boolean;
				isDirty: boolean;
		  }) => React.ReactNode);
	style?: ViewStyle;
}
function Form<T extends AnyZodObject>({
	schema,
	initialValues = {},
	onSubmit,
	children,
	style,
}: FormProps<T>) {
	const {
		values,
		errors,
		touched,
		setValue,
		handleBlur,
		validateForm,
		resetForm,
		isDirty,
		isValid,
	} = useZodForm(schema, initialValues);
	const contextValue = useMemo(
		(): FormContextType<T> => ({
			values,
			errors,
			touched,
			setValue,
			handleBlur,
			validateForm,
			resetForm,
			isDirty,
			isValid,
		}),
		[
			values,
			errors,
			touched,
			setValue,
			handleBlur,
			validateForm,
			resetForm,
			isDirty,
			isValid,
		],
	);
	const handleSubmit = () => {
		if (validateForm()) {
			const result = schema.safeParse(values);
			if (result.success && onSubmit) {
				onSubmit(result.data as ZodFormInfer<T>);
			} else {
				console.error(
					"Form validation passed but schema parsing failed.",
					result.error,
				);
			}
		}
	};
	return (
		<FormContext.Provider value={contextValue}>
			<View style={[styles.container, style]}>
				{typeof children === "function"
					? children({
							values,
							errors,
							touched,
							handleSubmit,
							isValid,
							isDirty,
						})
					: children}
			</View>
		</FormContext.Provider>
	);
}
export function useForm<T extends AnyZodObject>() {
	const context = useContext<FormContextType<T> | null>(FormContext);
	if (!context) {
		throw new Error("useForm must be used within a Form component");
	}
	return context;
}
interface FieldProps<T extends AnyZodObject> {
	name: keyof ZodFormInfer<T>;
	children: (fieldProps: {
		value: any;
		error?: string;
		onChange: (value: any) => void;
		onBlur: () => void;
		touched: boolean;
	}) => React.ReactNode;
}
function Field<T extends AnyZodObject>({ name, children }: FieldProps<T>) {
	const { values, errors, touched, setValue, handleBlur } = useForm<T>();
	const fieldProps = {
		value: values[name],
		error: errors[name],
		onChange: (value: any) => setValue(name, value),
		onBlur: () => handleBlur(name),
		touched: !!touched[name],
	};
	return <>{children(fieldProps)}</>;
}
interface SubmitButtonProps {
	children: (props: {
		onPress: () => void;
		isValid: boolean;
		isDirty: boolean;
	}) => React.ReactNode;
}
function SubmitButton({ children }: SubmitButtonProps) {
	const { handleSubmit, isValid, isDirty } = useForm();
	const handlePress = () => {
		handleSubmit?.();
	};
	return <>{children({ onPress: handlePress, isValid, isDirty })}</>;
}
const styles = StyleSheet.create({
	container: {
		width: "100%",
	},
});
Form.Field = Field;
Form.SubmitButton = SubmitButton;
export { Form };
</file>

<file path="apps/merchant-app/components/compound/form/FormCategory.tsx">
import React from "react";
import { Form } from "./Form";
import {
	CategoryField,
	CategoryOption,
} from "@/components/fields/CategoryField";
interface FormCategoryProps {
	name: string;
	label?: string;
	options: CategoryOption[];
	required?: boolean;
	disabled?: boolean;
	accessibilityLabel?: string;
	accessibilityHint?: string;
}
export const FormCategory: React.FC<FormCategoryProps> = ({
	name,
	label,
	options,
	required = false,
	disabled = false,
	accessibilityLabel,
	accessibilityHint,
}) => {
	return (
		<Form.Field name={name}>
			{({ value, error, onChange }) => (
				<CategoryField
					options={options}
					value={value || ""}
					onChange={onChange}
					label={label}
					error={error}
					required={required}
					disabled={disabled}
					accessibilityLabel={accessibilityLabel || label}
					accessibilityHint={accessibilityHint}
				/>
			)}
		</Form.Field>
	);
};
</file>

<file path="apps/merchant-app/components/compound/form/FormRadio.tsx">
import React from "react";
import { Form } from "./Form";
import { RadioField, RadioOption } from "@/components/fields/RadioField";
interface FormRadioProps {
	name: string;
	label?: string;
	options: RadioOption[];
	horizontal?: boolean;
	required?: boolean;
	disabled?: boolean;
	accessibilityLabel?: string;
	accessibilityHint?: string;
}
export const FormRadio: React.FC<FormRadioProps> = ({
	name,
	label,
	options,
	horizontal = false,
	required = false,
	disabled = false,
	accessibilityLabel,
	accessibilityHint,
}) => {
	return (
		<Form.Field name={name}>
			{({ value, error, onChange }) => (
				<RadioField
					options={options}
					value={value || ""}
					onChange={onChange}
					label={label}
					horizontal={horizontal}
					error={error}
					required={required}
					disabled={disabled}
					accessibilityLabel={accessibilityLabel || label}
					accessibilityHint={accessibilityHint}
				/>
			)}
		</Form.Field>
	);
};
</file>

<file path="apps/merchant-app/components/compound/form/FormSwitch.tsx">
import React from "react";
import { Form } from "./Form";
import { SwitchField } from "@/components/fields/SwitchField";
interface FormSwitchProps {
	name: string;
	label?: string;
	description?: string;
	leftIcon?: string;
	disabled?: boolean;
	accessibilityLabel?: string;
	accessibilityHint?: string;
}
export const FormSwitch: React.FC<FormSwitchProps> = ({
	name,
	label,
	description,
	leftIcon,
	disabled = false,
	accessibilityLabel,
	accessibilityHint,
}) => {
	return (
		<Form.Field name={name}>
			{({ value, error, onChange }) => (
				<SwitchField
					value={value || false}
					onValueChange={onChange}
					label={label}
					description={description}
					leftIcon={leftIcon}
					disabled={disabled}
					error={error}
					accessibilityLabel={accessibilityLabel || label}
					accessibilityHint={accessibilityHint}
				/>
			)}
		</Form.Field>
	);
};
</file>

<file path="apps/merchant-app/components/compound/form/index.tsx">
export * from "./FormInput";
export * from "./FormSwitch";
export * from "./FormRadio";
export * from "./FormCategory";
export * from "./Form";
</file>

<file path="apps/merchant-app/components/ui/Avatar.tsx">
import { useTheme } from "@/stores/themeStore";
import React from "react";
import { Image, ImageSourcePropType, View, ViewProps } from "react-native";
import { Text } from "./Text";
interface AvatarProps extends ViewProps {
	size?: "sm" | "md" | "lg" | number;
	source?: ImageSourcePropType;
	text?: string;
	color?: string;
	backgroundColor?: string;
}
export const Avatar = React.memo(
	({
		size = "md",
		source,
		text,
		color,
		backgroundColor,
		style,
		...props
	}: AvatarProps) => {
		const theme = useTheme();
		const getSize = () => {
			if (typeof size === "number") return size;
			switch (size) {
				case "sm":
					return theme.sizes.avatarSm;
				case "md":
					return theme.sizes.avatarMd;
				case "lg":
					return theme.sizes.avatarLg;
				default:
					return theme.sizes.avatarMd;
			}
		};
		const getFontVariant = () => {
			if (typeof size === "number") return "md";
			switch (size) {
				case "sm":
					return "sm";
				case "md":
					return "lg";
				case "lg":
					return "xl";
				default:
					return "lg";
			}
		};
		const avatarSize = getSize();
		const bgColor = backgroundColor
			? theme.colors[backgroundColor as ColorToken] || backgroundColor
			: theme.colors.primaryLight;
		const textColor = color
			? theme.colors[color as ColorToken] || color
			: theme.colors.primary;
		const containerStyle = {
			width: avatarSize,
			height: avatarSize,
			borderRadius: avatarSize / 2,
			backgroundColor: bgColor,
			alignItems: "center" as const,
			justifyContent: "center" as const,
			overflow: "hidden" as const,
		};
		const imageStyle = {
			width: avatarSize,
			height: avatarSize,
		};
		return (
			<View style={[containerStyle, style]} {...props}>
				{source ? (
					<Image source={source} style={imageStyle} resizeMode="cover" />
				) : (
					<Text variant={getFontVariant()} weight="bold" color={textColor}>
						{text ? text.charAt(0).toUpperCase() : "?"}
					</Text>
				)}
			</View>
		);
	},
);
</file>

<file path="apps/merchant-app/components/ui/Box.tsx">
import { useTheme } from "@/stores/themeStore";
import React, { memo } from "react";
import {
	DimensionValue,
	FlexAlignType,
	Pressable,
	StyleProp,
	View,
	ViewProps,
	ViewStyle,
} from "react-native";
import Animated from "react-native-reanimated";
type JustifyContentType =
	| "flex-start"
	| "flex-end"
	| "center"
	| "space-between"
	| "space-around"
	| "space-evenly";
interface BoxProps extends ViewProps {
	flex?: number;
	row?: boolean;
	center?: boolean;
	alignCenter?: boolean;
	alignItems?: FlexAlignType;
	justifyCenter?: boolean;
	justifyContent?: JustifyContentType;
	card?: boolean;
	padding?: SpacingToken | number;
	gap?: SpacingToken | number;
	margin?: SpacingToken | number;
	marginTop?: SpacingToken | number;
	marginBottom?: SpacingToken | number;
	marginStart?: SpacingToken | number;
	marginEnd?: SpacingToken | number;
	marginHorizontal?: SpacingToken | number;
	marginVertical?: SpacingToken | number;
	paddingHorizontal?: SpacingToken | number;
	paddingBottom?: SpacingToken | number;
	paddingTop?: SpacingToken | number;
	paddingVertical?: SpacingToken | number;
	paddingStart?: SpacingToken | number;
	paddingEnd?: SpacingToken | number;
	rounded?: RadiusToken | number;
	width?: DimensionValue;
	height?: DimensionValue;
	borderWidth?: number;
	borderColor?: ColorToken;
	bg?: ColorToken | string;
	elevation?: "none" | "small" | "medium" | "large";
	style?: StyleProp<ViewStyle>;
	onPress?: () => void;
	activeOpacity?: number;
}
export const Box: React.FC<BoxProps> = memo(
	({
		children,
		flex,
		row,
		gap,
		center,
		alignCenter,
		paddingTop,
		alignItems,
		paddingBottom,
		justifyCenter,
		justifyContent,
		card,
		padding,
		margin,
		marginTop,
		marginBottom,
		marginStart,
		marginEnd,
		marginHorizontal,
		marginVertical,
		paddingHorizontal,
		paddingVertical,
		paddingStart,
		paddingEnd,
		rounded,
		width,
		height,
		borderWidth,
		borderColor,
		bg,
		elevation,
		style,
		onPress,
		activeOpacity = 0.7,
		...props
	}) => {
		const theme = useTheme();
		let finalAlignItems: FlexAlignType | undefined;
		let finalJustifyContent: JustifyContentType | undefined;
		if (center) {
			finalAlignItems = "center";
			finalJustifyContent = "center";
		} else {
			finalAlignItems = alignCenter ? "center" : alignItems;
			finalJustifyContent = justifyCenter ? "center" : justifyContent;
		}
		const getSpacingValue = (
			value: SpacingToken | number | undefined,
		): number | undefined => {
			if (value === undefined) return undefined;
			return typeof value === "number" ? value : theme.spacing[value];
		};
		const getRadiusValue = (
			value: RadiusToken | number | undefined,
		): number | undefined => {
			if (value === undefined) return undefined;
			return typeof value === "number" ? value : theme.radius[value];
		};
		const getColorValue = (
			color: ColorToken | string | undefined,
		): string | undefined => {
			if (color === undefined) return undefined;
			if (typeof color === "string" && color in theme.colors) {
				return theme.colors[color as ColorToken];
			}
			return color;
		};
		const getElevation = (level?: "none" | "small" | "medium" | "large") => {
			if (!level || level === "none") return {};
			const shadowStyle = theme.shadows[level];
			return { ...shadowStyle, shadowColor: theme.colors.shadow };
		};
		const boxStyle: ViewStyle = {
			flex,
			flexDirection: row ? "row" : "column",
			alignItems: finalAlignItems,
			justifyContent: finalJustifyContent,
			padding: getSpacingValue(padding),
			margin: getSpacingValue(margin),
			marginTop: getSpacingValue(marginTop),
			marginBottom: getSpacingValue(marginBottom),
			marginStart: getSpacingValue(marginStart),
			marginEnd: getSpacingValue(marginEnd),
			marginHorizontal: getSpacingValue(marginHorizontal),
			marginVertical: getSpacingValue(marginVertical),
			paddingHorizontal: getSpacingValue(paddingHorizontal),
			paddingVertical: getSpacingValue(paddingVertical),
			gap: getSpacingValue(gap),
			paddingTop: getSpacingValue(paddingTop),
			paddingBottom: getSpacingValue(paddingBottom),
			paddingStart: getSpacingValue(paddingStart),
			paddingEnd: getSpacingValue(paddingEnd),
			borderRadius: getRadiusValue(rounded),
			width,
			height,
			borderWidth,
			borderColor: getColorValue(borderColor),
			backgroundColor: card ? theme.colors.card : getColorValue(bg),
			...(card ? getElevation("small") : {}),
			...(elevation ? getElevation(elevation) : {}),
		};
		if (onPress) {
			return (
				<Pressable
					onPress={onPress}
					style={({ pressed }) => [
						boxStyle,
						{ opacity: pressed ? activeOpacity : 1 },
						style,
					]}
					{...props}
					android_ripple={{ color: theme.colors.overlay }}
				>
					{children}
				</Pressable>
			);
		}
		return (
			<View style={[boxStyle, style]} {...props}>
				{children}
			</View>
		);
	},
);
export default Box;
export const AnimatedBox = Animated.createAnimatedComponent(Box);
</file>

<file path="apps/merchant-app/constants/theme/animations.ts">
export const animations = {
	duration: {
		fast: 100,
		medium: 200,
		slow: 300,
		extraSlow: 400,
	},
	scale: {
		pressed: 0.98,
		pressedSmall: 0.95,
		selected: 1.1,
	},
	spring: {
		damping: {
			light: 15,
			medium: 10,
			heavy: 5,
		},
		stiffness: {
			soft: 100,
			medium: 200,
			rigid: 300,
		},
	},
	delay: {
		staggered: {
			short: 50,
			medium: 100,
			long: 200,
		},
	},
};
</file>

<file path="apps/merchant-app/constants/theme/platform.ts">
import { Platform } from "react-native";
import { DefaultTheme } from "@react-navigation/native";
export const platform = {
	topInset: Platform.OS === "ios" ? (DefaultTheme.dark ? 44 : 50) : 16,
	bottomInset: Platform.OS === "ios" ? 34 : 16,
	isIOS: Platform.OS === "ios",
	isAndroid: Platform.OS === "android",
};
</file>

<file path="apps/merchant-app/constants/theme/radius.ts">
export const radius = {
	none: 0,
	xs: 4,
	sm: 8,
	md: 12,
	lg: 16,
	xl: 24,
	round: 999,
	button: 12,
	card: 16,
	input: 12,
	badge: 12,
} as const;
</file>

<file path="apps/merchant-app/constants/theme/typography.ts">
export const typography = {
	sizes: {
		xs: 12,
		sm: 14,
		md: 16,
		lg: 18,
		xl: 20,
		xxl: 24,
		xxxl: 30,
	} as const,
	weights: {
		regular: "400",
		medium: "500",
		semibold: "600",
		bold: "700",
		extrabold: "800",
	} as const,
	lineHeights: {
		tight: 1.2,
		normal: 1.5,
		loose: 1.8,
	} as const,
};
</file>

<file path="apps/merchant-app/hooks/useLanguage.ts">
import { useState, useEffect } from "react";
import { I18nManager } from "react-native";
import * as Expo from "expo";
import { Language } from "@/constants/i18n";
import { useMMKV } from "react-native-mmkv";
export function useLanguage() {
	const storage = useMMKV();
	const [language, setLanguage] = useState<Language>(
		(storage.getString("language") as Language) ?? "en",
	);
	useEffect(() => {
		const loadLanguage = async () => {
			const savedLanguage = storage.getString("language");
			if (savedLanguage === "en" || savedLanguage === "ar") {
				setLanguage(savedLanguage);
				const shouldBeRTL = savedLanguage === "ar";
				if (shouldBeRTL !== I18nManager.isRTL) {
					I18nManager.forceRTL(shouldBeRTL);
					Expo.reloadAppAsync();
				} else if (!shouldBeRTL && I18nManager.isRTL) {
					I18nManager.forceRTL(false);
				}
			}
		};
		loadLanguage();
	}, []);
	const changeLanguage = async (newLanguage: Language) => {
		setLanguage(newLanguage);
		storage.set("language", newLanguage);
		const shouldBeRTL = newLanguage === "ar";
		if (shouldBeRTL !== I18nManager.isRTL) {
			I18nManager.allowRTL(shouldBeRTL);
			I18nManager.forceRTL(shouldBeRTL);
		}
		Expo.reloadAppAsync();
	};
	return { language, changeLanguage };
}
</file>

<file path="apps/merchant-app/hooks/useMemoizedCallback.ts">
import { useCallback, useRef } from "react";
export function useMemoizedCallback<T extends (...args: any[]) => any>(
	callback: T,
	dependencies: React.DependencyList,
) {
	const callbackRef = useRef(callback);
	callbackRef.current = callback;
	return useCallback((...args: Parameters<T>) => {
		return callbackRef.current(...args);
	}, dependencies);
}
</file>

<file path="apps/merchant-app/hooks/useResponsiveLayout.ts">
import { useEffect, useState } from "react";
import { Dimensions, ScaledSize } from "react-native";
export type DeviceType = "phone" | "tablet" | "desktop";
export type OrientationType = "portrait" | "landscape";
export const BREAKPOINTS = {
	PHONE_MAX_WIDTH: 767,
	TABLET_MIN_WIDTH: 768,
	TABLET_MAX_WIDTH: 1023,
	DESKTOP_MIN_WIDTH: 1024,
};
interface ResponsiveLayout {
	deviceType: DeviceType;
	orientation: OrientationType;
	isPhone: boolean;
	isTablet: boolean;
	isLandscape: boolean;
	isPortrait: boolean;
	windowWidth: number;
	windowHeight: number;
	scale: number;
	fontScale: number;
}
export function useResponsiveLayout(): ResponsiveLayout {
	const [layout, setLayout] = useState<ResponsiveLayout>(() => {
		const window = Dimensions.get("window");
		return getLayoutInfo(window);
	});
	useEffect(() => {
		function handleDimensionsChange({ window }: { window: ScaledSize }) {
			setLayout(getLayoutInfo(window));
		}
		const subscription = Dimensions.addEventListener(
			"change",
			handleDimensionsChange,
		);
		return () => {
			if (typeof subscription?.remove === "function") {
				subscription.remove();
			}
		};
	}, []);
	return layout;
}
function getLayoutInfo(window: ScaledSize): ResponsiveLayout {
	const { width, height, scale, fontScale } = window;
	const isPortrait = height > width;
	const isLandscape = !isPortrait;
	let deviceType: DeviceType = "phone";
	if (
		width >= BREAKPOINTS.TABLET_MIN_WIDTH &&
		width <= BREAKPOINTS.TABLET_MAX_WIDTH
	) {
		deviceType = "tablet";
	} else if (width > BREAKPOINTS.DESKTOP_MIN_WIDTH) {
		deviceType = "desktop";
	}
	return {
		deviceType,
		orientation: isPortrait ? "portrait" : "landscape",
		isPhone: deviceType === "phone",
		isTablet: deviceType === "tablet",
		isLandscape,
		isPortrait,
		windowWidth: width,
		windowHeight: height,
		scale,
		fontScale,
	};
}
</file>

<file path="apps/merchant-app/hooks/useResponsiveStyles.ts">
import { useMemo } from "react";
import { StyleSheet, ViewStyle, TextStyle, ImageStyle } from "react-native";
import { useResponsiveLayout } from "./useResponsiveLayout";
import { useTheme } from "./useTheme";
type NamedStyles<T> = { [P in keyof T]: ViewStyle | TextStyle | ImageStyle };
interface ResponsiveStyleOptions<T extends NamedStyles<T>> {
	base: T;
	tablet?: Partial<T>;
	phone?: Partial<T>;
	landscape?: Partial<T>;
	portrait?: Partial<T>;
	tabletLandscape?: Partial<T>;
	tabletPortrait?: Partial<T>;
	phoneLandscape?: Partial<T>;
	phonePortrait?: Partial<T>;
}
export function useResponsiveStyles<T extends NamedStyles<T>>(
	styleOptions: ResponsiveStyleOptions<T>,
): T {
	const { deviceType, orientation } = useResponsiveLayout();
	const theme = useTheme();
	return useMemo(() => {
		const {
			base,
			tablet,
			phone,
			landscape,
			portrait,
			tabletLandscape,
			tabletPortrait,
			phoneLandscape,
			phonePortrait,
		} = styleOptions;
		let combinedStyles = { ...base };
		if (deviceType === "tablet" && tablet) {
			combinedStyles = mergeStyles(combinedStyles, tablet);
		} else if (deviceType === "phone" && phone) {
			combinedStyles = mergeStyles(combinedStyles, phone);
		}
		if (orientation === "landscape" && landscape) {
			combinedStyles = mergeStyles(combinedStyles, landscape);
		} else if (orientation === "portrait" && portrait) {
			combinedStyles = mergeStyles(combinedStyles, portrait);
		}
		if (
			deviceType === "tablet" &&
			orientation === "landscape" &&
			tabletLandscape
		) {
			combinedStyles = mergeStyles(combinedStyles, tabletLandscape);
		} else if (
			deviceType === "tablet" &&
			orientation === "portrait" &&
			tabletPortrait
		) {
			combinedStyles = mergeStyles(combinedStyles, tabletPortrait);
		} else if (
			deviceType === "phone" &&
			orientation === "landscape" &&
			phoneLandscape
		) {
			combinedStyles = mergeStyles(combinedStyles, phoneLandscape);
		} else if (
			deviceType === "phone" &&
			orientation === "portrait" &&
			phonePortrait
		) {
			combinedStyles = mergeStyles(combinedStyles, phonePortrait);
		}
		return StyleSheet.create(combinedStyles);
	}, [styleOptions, deviceType, orientation, theme]);
}
function mergeStyles<T extends NamedStyles<T>>(
	base: T,
	overrides: Partial<T>,
): T {
	const merged = { ...base };
	Object.keys(overrides).forEach((key) => {
		const baseStyle = base[key as keyof T];
		const overrideStyle = overrides[key as keyof T];
		if (baseStyle && overrideStyle) {
			merged[key as keyof T] = {
				...baseStyle,
				...overrideStyle,
			};
		}
	});
	return merged;
}
</file>

<file path="apps/merchant-app/hooks/useZodForm.ts">
import { useState, useCallback, useMemo } from "react";
import { z, ZodObject, AnyZodObject } from "zod";
const createFormSchema = <T extends AnyZodObject>(schema: T) => {
	type SchemaOutputType = z.infer<T>;
	return {
		validateField: (field: keyof SchemaOutputType, value: any) => {
			if (!(schema instanceof ZodObject)) {
				console.error("Schema provided to createFormSchema is not a ZodObject");
				return {
					valid: false,
					error: "Invalid schema type for field validation.",
				};
			}
			const fieldSchema = schema.shape[field as string];
			if (!fieldSchema) {
				console.warn(`Field "${String(field)}" not found in schema shape.`);
				return { valid: true };
			}
			const result = fieldSchema.safeParse(value);
			if (!result.success) {
				return {
					valid: false,
					error: result.error.errors[0]?.message ?? "Invalid value",
				};
			}
			return { valid: true };
		},
		validateForm: (values: Partial<SchemaOutputType>) => {
			const result = schema.safeParse(values);
			if (!result.success) {
				const errors: Record<string, string> = {};
				result.error.errors.forEach((err) => {
					if (err.path.length > 0) {
						const fieldKey = err.path[0] as string;
						if (!errors[fieldKey]) {
							errors[fieldKey] = err.message;
						}
					}
				});
				return { valid: false, errors };
			}
			return { valid: true, errors: {} };
		},
	};
};
export function useZodForm<T extends AnyZodObject>(
	schema: T,
	initialValues: Partial<z.infer<T>> = {},
) {
	type SchemaOutputType = z.infer<T>;
	const [values, setValues] =
		useState<Partial<SchemaOutputType>>(initialValues);
	const [errors, setErrors] = useState<
		Partial<Record<keyof SchemaOutputType, string>>
	>({});
	const [touched, setTouched] = useState<
		Partial<Record<keyof SchemaOutputType, boolean>>
	>({});
	const formSchema = useMemo(() => createFormSchema(schema), [schema]);
	const setValue = useCallback(
		(field: keyof SchemaOutputType, value: any) => {
			setValues((prev) => ({ ...prev, [field]: value }));
			const validation = formSchema.validateField(field, value);
			if (!validation.valid && validation.error) {
				setErrors((prev) => ({ ...prev, [field]: validation.error }));
			} else {
				setErrors((prev) => {
					const newErrors = { ...prev };
					delete newErrors[field];
					return newErrors;
				});
			}
		},
		[formSchema],
	);
	const handleBlur = useCallback(
		(field: keyof SchemaOutputType) => {
			setTouched((prev) => ({ ...prev, [field]: true }));
			const value = values[field];
			const validation = formSchema.validateField(field, value);
			if (!validation.valid && validation.error) {
				setErrors((prev) => ({ ...prev, [field]: validation.error }));
			} else {
				setErrors((prev) => {
					const newErrors = { ...prev };
					if (validation.valid && newErrors[field]) {
						delete newErrors[field];
					}
					return newErrors;
				});
			}
		},
		[values, formSchema],
	);
	const validateForm = useCallback(() => {
		const result = formSchema.validateForm(values);
		setErrors(result.errors as Partial<Record<keyof SchemaOutputType, string>>);
		return result.valid;
	}, [values, formSchema]);
	const resetForm = useCallback(
		(newValues: Partial<SchemaOutputType> = initialValues) => {
			setValues(newValues);
			setErrors({});
			setTouched({});
		},
		[initialValues],
	);
	const isValid = useMemo(() => Object.keys(errors).length === 0, [errors]);
	const isDirty = useMemo(() => Object.keys(touched).length > 0, [touched]);
	return {
		values,
		errors,
		touched,
		setValue,
		handleBlur,
		validateForm,
		resetForm,
		isDirty,
		isValid,
	};
}
</file>

<file path="apps/merchant-app/schemas/mealSchema.ts">
import { z } from "zod";
import {
	nameSchema,
	priceSchema,
	caloriesSchema,
	descriptionSchema,
	imageUrlSchema,
	createFormSchema,
} from "@/utils/validation";
export const mealSchema = z.object({
	id: z.string().optional(),
	name: nameSchema,
	name_ar: z.string().optional(),
	description: descriptionSchema,
	description_ar: z.string().optional(),
	price: priceSchema,
	calories: caloriesSchema,
	prepTime: z
		.number()
		.positive("Prep time must be greater than 0")
		.int("Prep time must be a whole number")
		.or(z.string().regex(/^\d+$/).transform(Number)),
	period: z.enum(["Breakfast", "Lunch", "Dinner"], {
		errorMap: () => ({ message: "Please select a valid meal period" }),
	}),
	available: z.boolean().default(true),
	featured: z.boolean().default(false),
	isVegan: z.boolean().default(false),
	image: imageUrlSchema.optional(),
	dietaryRestriction: z
		.enum(["none", "vegetarian", "vegan", "glutenFree", "dairyFree"])
		.optional(),
});
export type MealSchemaType = z.infer<typeof mealSchema>;
export const mealFormSchema = createFormSchema(mealSchema);
</file>

<file path="apps/merchant-app/stores/mealStore.ts">
import { create } from "zustand";
import { immer } from "zustand/middleware/immer";
import { Meal } from "@/types";
import { MEALS } from "@/data";
interface MealState {
	meals: Meal[];
	selectedMeal: Meal | null;
	loading: boolean;
	setLoading: (loading: boolean) => void;
	setSelectedMeal: (id: string) => void;
	addMeal: (meal: Meal) => void;
	updateMeal: (meal: Meal) => void;
	deleteMeal: (id: string) => void;
}
export const useMealStore = create<MealState>()(
	immer((set, get) => ({
		meals: MEALS,
		selectedMeal: null,
		loading: false,
		setLoading: (loading) => set({ loading }),
		setSelectedMeal: (id) => {
			const meal = get().meals.find((m) => m.id === id) || null;
			set({ selectedMeal: meal });
		},
		addMeal: (meal) =>
			set((state) => {
				state.meals.push(meal);
			}),
		updateMeal: (meal) =>
			set((state) => {
				const index = state.meals.findIndex((m) => m.id === meal.id);
				if (index !== -1) {
					state.meals[index] = meal;
				}
			}),
		deleteMeal: (id) =>
			set((state) => {
				state.meals = state.meals.filter((m) => m.id !== id);
			}),
	})),
);
</file>

<file path="apps/merchant-app/stores/themeStore.ts">
import { create } from "zustand";
import { MMKV } from "react-native-mmkv";
import { DarkTheme, DefaultTheme } from "@react-navigation/native";
import { theme } from "@/constants/theme";
import { Appearance } from "react-native";
const storage = new MMKV();
export type ThemeMode = "light" | "dark" | "system";
interface ThemeState {
	mode: ThemeMode;
	setTheme: (mode: ThemeMode) => void;
}
const getSystemTheme = (): "light" | "dark" =>
	Appearance.getColorScheme() || "light";
export const useThemeStore = create<ThemeState>()((set) => {
	const savedMode = (storage.getString("theme") as ThemeMode) || "system";
	return {
		mode: savedMode,
		setTheme: (mode: ThemeMode) => {
			storage.set("theme", mode);
			set({ mode });
			if (mode !== "system") {
				Appearance.setColorScheme(mode === "dark" ? "dark" : "light");
			} else {
				Appearance.setColorScheme(null);
			}
		},
	};
});
export const useTheme = () => {
	const { mode } = useThemeStore();
	const systemColorScheme = getSystemTheme();
	const effectiveMode = mode === "system" ? systemColorScheme : mode;
	const isDark = effectiveMode === "dark";
	const navTheme = isDark ? DarkTheme : DefaultTheme;
	return {
		colors: theme.colors[effectiveMode],
		isDark,
		mode: effectiveMode,
		spacing: theme.spacing,
		radius: theme.radius,
		sizes: theme.sizes,
		typography: theme.typography,
		shadows: theme.shadows,
		platform: theme.platform,
		animations: theme.animations,
		navTheme: {
			...navTheme,
			colors: {
				...navTheme.colors,
				primary: theme.colors[effectiveMode].primary,
				background: theme.colors[effectiveMode].background,
				card: theme.colors[effectiveMode].card,
				text: theme.colors[effectiveMode].text,
				border: theme.colors[effectiveMode].divider,
				notification: theme.colors[effectiveMode].primary,
			} as const,
		} as const,
	} as const;
};
Appearance.addChangeListener(() => {
	const currentMode = (storage.getString("theme") as ThemeMode) || "system";
	if (currentMode === "system") {
		useThemeStore.setState({});
	}
});
</file>

<file path="apps/merchant-app/utils/validation.ts">
import { z, AnyZodObject, ZodTypeAny } from "zod";
export const createFormSchema = <T extends AnyZodObject>(schema: T) => {
	type SchemaOutputType = z.infer<T>;
	return {
		schema,
		validateField: (
			field: keyof SchemaOutputType,
			value: any,
		): { valid: boolean; error?: string } => {
			const fieldSchema = schema.shape[field as string] as
				| ZodTypeAny
				| undefined;
			if (!fieldSchema) {
				console.warn(`Schema not found for field: ${String(field)}`);
				return { valid: true };
			}
			const result = fieldSchema.safeParse(value);
			if (result.success) {
				return { valid: true };
			}
			const [error] = result.error.errors;
			return {
				valid: false,
				error: error?.message,
			};
		},
		validateForm: (
			values: Partial<SchemaOutputType>,
		): {
			valid: boolean;
			errors: Partial<Record<keyof SchemaOutputType, string>>;
		} => {
			const result = schema.safeParse(values);
			if (result.success) {
				return { valid: true, errors: {} };
			}
			const errors: Partial<Record<keyof SchemaOutputType, string>> = {};
			result.error.errors.forEach((error) => {
				if (error.path.length > 0) {
					const field = error.path[0] as keyof SchemaOutputType;
					if (!errors[field]) {
						errors[field] = error.message;
					}
				}
			});
			return { valid: false, errors };
		},
	};
};
export const nameSchema = z
	.string()
	.min(1, "Name is required")
	.max(100, "Name is too long");
export const priceSchema = z.preprocess(
	(val) => (val === "" ? undefined : val),
	z.coerce
		.number({
			invalid_type_error: "Price must be a number",
			required_error: "Price is required",
		})
		.positive("Price must be greater than 0")
		.finite("Price must be a finite number"),
);
export const caloriesSchema = z.preprocess(
	(val) => (val === "" ? undefined : val),
	z.coerce
		.number({
			invalid_type_error: "Calories must be a number",
			required_error: "Calories are required",
		})
		.nonnegative("Calories cannot be negative")
		.int("Calories must be a whole number"),
);
export const descriptionSchema = z
	.string()
	.trim()
	.min(1, "Description is required")
	.min(10, "Description must be at least 10 characters")
	.max(1000, "Description must be less than 1000 characters");
export const ingredientsSchema = z
	.array(z.string().trim().min(1, "Ingredient cannot be empty"))
	.min(1, "At least one ingredient is required");
export const imageUrlSchema = z
	.string()
	.trim()
	.url("Image must be a valid URL")
	.optional()
	.or(z.literal(""));
</file>

<file path="apps/merchant-app/style.d.ts">
import { theme } from "@/constants/theme";
declare global {
	type SpacingToken = keyof typeof theme.spacing;
	type RadiusToken = keyof typeof theme.radius;
	type ColorToken = keyof typeof theme.colors.light;
	type SizeToken = keyof typeof theme.sizes;
	type ShadowToken = keyof typeof theme.shadows;
	type FontSizeVariant = keyof typeof theme.typography.sizes;
	type FontWeightVariant = keyof typeof theme.typography.weights;
	type LineHeightVariant = keyof typeof theme.typography.lineHeights;
	type ThemeTokens = {
		spacing: SpacingToken;
		radius: RadiusToken;
		colors: ColorToken;
		sizes: SizeToken;
		shadows: ShadowToken;
		typography: {
			sizes: FontSizeVariant;
			weights: FontWeightVariant;
			lineHeights: LineHeightVariant;
		};
	};
}
export {};
</file>

<file path=".repomixignore">
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
**/*.log,tmp/
**/Illustrations/**
**/*.json
**/Localization.ts
**/SVGS/**
**/generated/**
/**/svgs/**
</file>

<file path="apps/merchant-app/components/common/ErrorBoundary.tsx">
import React, { Component, ErrorInfo, ReactNode } from "react";
import { View, StyleSheet } from "react-native";
import { Text, Button } from "@/components/ui";
import { useTheme } from "@/stores/themeStore";
interface Props {
	children: ReactNode;
	fallback?: ReactNode;
	onError?: (error: Error, errorInfo: ErrorInfo) => void;
}
interface State {
	hasError: boolean;
	error?: Error;
}
export class ErrorBoundary extends Component<Props, State> {
	constructor(props: Props) {
		super(props);
		this.state = { hasError: false };
	}
	static getDerivedStateFromError(error: Error): State {
		return { hasError: true, error };
	}
	componentDidCatch(error: Error, errorInfo: ErrorInfo) {
		if (this.props.onError) {
			this.props.onError(error, errorInfo);
		}
		console.error("Error caught by ErrorBoundary:", error, errorInfo);
	}
	resetError = () => {
		this.setState({ hasError: false, error: undefined });
	};
	render() {
		if (this.state.hasError) {
			if (this.props.fallback) {
				return this.props.fallback;
			}
			return (
				<ErrorFallback error={this.state.error} resetError={this.resetError} />
			);
		}
		return this.props.children;
	}
}
interface ErrorFallbackProps {
	error?: Error;
	resetError: () => void;
}
const ErrorFallback: React.FC<ErrorFallbackProps> = ({ error, resetError }) => {
	const theme = useTheme();
	return (
		<View
			style={[styles.container, { backgroundColor: theme.colors.background }]}
		>
			<Text variant="lg" weight="semibold" color="error" marginBottom="md">
				Something went wrong
			</Text>
			<Text variant="md" color="textSecondary" marginBottom="lg">
				{error?.message || "An unexpected error occurred"}
			</Text>
			<Button
				title="Try Again"
				onPress={resetError}
				accessibilityLabel="Try again button"
			/>
		</View>
	);
};
const styles = StyleSheet.create({
	container: {
		flex: 1,
		justifyContent: "center",
		alignItems: "center",
		padding: 20,
	},
});
</file>

<file path="apps/merchant-app/components/compound/form/FormInput.tsx">
import React from "react";
import { z } from "zod";
import { Form } from "./Form";
import FocusableInput, {
	FocusableInputProps,
} from "@/components/fields/FocusableInput";
import { useTheme } from "@/stores/themeStore";
interface FormInputProps {
	name: string;
	label?: string;
	placeholder?: string;
	required?: boolean;
	multiline?: boolean;
	numberOfLines?: number;
	keyboardType?: "default" | "numeric" | "email-address" | "phone-pad";
	secureTextEntry?: boolean;
	schema?: z.ZodType<any, any>;
	inputRef?: React.RefObject<any>;
	onSubmitEditing?: () => void;
	autoCapitalize?: "none" | "sentences" | "words" | "characters";
	textAlign?: "left" | "center" | "right";
	textAlignVertical?: "top" | "center" | "bottom";
	accessibilityLabel?: string;
	accessibilityHint?: string;
	style?: FocusableInputProps["style"];
}
export const FormInput: React.FC<FormInputProps> = ({
	name,
	label,
	placeholder,
	required = false,
	multiline = false,
	numberOfLines = 1,
	keyboardType = "default",
	secureTextEntry = false,
	schema,
	inputRef,
	onSubmitEditing,
	autoCapitalize = "sentences",
	textAlign,
	textAlignVertical,
	accessibilityLabel,
	accessibilityHint,
	style,
}) => {
	const theme = useTheme();
	return (
		<Form.Field name={name}>
			{({ value, error, onChange, onBlur, touched }) => (
				<FocusableInput
					inputRef={inputRef}
					label={label}
					required={required}
					value={value || ""}
					onChangeText={onChange}
					placeholder={placeholder}
					placeholderTextColor={theme.colors.textMuted}
					multiline={multiline}
					numberOfLines={numberOfLines}
					keyboardType={keyboardType}
					secureTextEntry={secureTextEntry}
					onSubmitEditing={onSubmitEditing}
					onBlur={onBlur}
					error={touched && error ? error : undefined}
					autoCapitalize={autoCapitalize}
					textAlign={textAlign}
					textAlignVertical={textAlignVertical}
					accessibilityLabel={accessibilityLabel || label}
					accessibilityHint={accessibilityHint}
					schema={schema}
					style={style}
				/>
			)}
		</Form.Field>
	);
};
</file>

<file path="apps/merchant-app/components/dashboard/AlertRow.tsx">
import React from "react";
import { Pressable } from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { Box, Text } from "@/components/ui";
import { useTheme } from "@/stores/themeStore";
import { Alert } from "@/types";
interface AlertRowProps {
	alert: Alert;
	onPress: () => void;
}
export const AlertRow = React.memo(
	({ alert, onPress }: AlertRowProps) => {
		const theme = useTheme();
		const iconColor = theme.colors[alert.type];
		return (
			<Pressable
				onPress={onPress}
				style={({ pressed }) => ({
					paddingHorizontal: theme.spacing.sm,
					flexDirection: "row",
					alignItems: "center",
					paddingVertical: theme.spacing.md,
					borderRadius: theme.radius.sm,
					backgroundColor: pressed ? theme.colors.backgroundAlt : undefined,
				})}
				android_ripple={{ color: theme.colors.overlay }}
				accessibilityRole="button"
				accessibilityLabel={alert.title}
			>
				<Ionicons
					name={alert.icon as any}
					size={theme.sizes.iconSm}
					color={iconColor}
					style={{ marginStart: theme.spacing.md }}
				/>
				<Box flex={1}>
					<Text variant="sm" numberOfLines={1}>
						{alert.title}
					</Text>
					{alert.timestamp && (
						<Text
							variant="xs"
							color="textMuted"
							marginTop={theme.spacing.xs / 2}
						>
							{alert.timestamp}
						</Text>
					)}
				</Box>
				<Ionicons
					name="chevron-back"
					size={theme.sizes.iconSm}
					color={theme.colors.textMuted}
				/>
			</Pressable>
		);
	},
	(prevProps, nextProps) => {
		return (
			prevProps.alert.id === nextProps.alert.id &&
			prevProps.alert.title === nextProps.alert.title &&
			prevProps.alert.type === nextProps.alert.type &&
			prevProps.alert.timestamp === nextProps.alert.timestamp &&
			prevProps.alert.icon === nextProps.alert.icon
		);
	},
);
</file>

<file path="apps/merchant-app/components/fields/RadioField.tsx">
import React from "react";
import { View, TouchableOpacity, StyleProp, ViewStyle } from "react-native";
import * as Haptics from "expo-haptics";
import { Text } from "@/components/ui";
import { useTheme } from "@/stores/themeStore";
import { Ionicons } from "@expo/vector-icons";
import Animated, {
	useSharedValue,
	useAnimatedStyle,
	withTiming,
	withSpring,
	FadeInUp,
} from "react-native-reanimated";
export interface RadioOption {
	value: string;
	label: string;
	icon?: string;
	description?: string;
}
export interface RadioFieldProps {
	options: RadioOption[];
	value: string;
	onChange: (value: string) => void;
	label?: string;
	horizontal?: boolean;
	style?: StyleProp<ViewStyle>;
	error?: string;
	required?: boolean;
	disabled?: boolean;
	accessibilityLabel?: string;
	accessibilityHint?: string;
}
export const RadioField = React.memo(
	({
		options,
		value,
		onChange,
		label,
		horizontal = false,
		style,
		error,
		required,
		disabled = false,
	}: RadioFieldProps) => {
		const theme = useTheme();
		const [errorShake, setErrorShake] = React.useState(false);
		const hasError = !!error;
		const errorAnimation = useSharedValue(0);
		React.useEffect(() => {
			if (hasError) {
				setErrorShake(true);
				errorAnimation.value = withTiming(1, { duration: 300 });
				Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
				setTimeout(() => {
					setErrorShake(false);
				}, 800);
			} else {
				errorAnimation.value = withTiming(0, { duration: 200 });
			}
		}, [error, hasError]);
		const containerAnimatedStyle = useAnimatedStyle(() => {
			const translateX = errorShake
				? withSpring(0, {
						velocity: 10,
						damping: 3,
						stiffness: 200,
					})
				: 0;
			const borderColor = hasError ? theme.colors.error : "transparent";
			const borderWidth = hasError ? 2 : 0;
			const backgroundColor = hasError
				? `${theme.colors.error}08`
				: "transparent";
			return {
				transform: [{ translateX }],
				borderColor,
				borderWidth,
				backgroundColor,
				borderRadius: theme.radius.md,
				padding: hasError ? 4 : 0,
			};
		});
		const handleSelect = (optionValue: string) => {
			if (!disabled && optionValue !== value) {
				Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
				onChange(optionValue);
			}
		};
		return (
			<View style={[{ width: "100%" }, style]}>
				{label && (
					<View
						style={{ flexDirection: "row", marginBottom: theme.spacing.sm }}
					>
						<Text
							variant="sm"
							weight="semibold"
							color={hasError ? "error" : "textSecondary"}
						>
							{label}
						</Text>
						{required && (
							<Text
								variant="sm"
								weight="semibold"
								color="error"
								style={{ marginStart: theme.spacing.xs / 2 }}
							>
								*
							</Text>
						)}
					</View>
				)}
				<Animated.View
					style={[
						{
							width: "100%",
							flexDirection: horizontal ? "row" : "column",
						},
						containerAnimatedStyle,
					]}
				>
					{options.map((option, index) => (
						<RadioOption
							key={option.value}
							option={option}
							isSelected={option.value === value}
							onSelect={() => handleSelect(option.value)}
							isLast={index === options.length - 1}
							horizontal={horizontal}
							disabled={disabled}
							hasError={hasError}
						/>
					))}
				</Animated.View>
				{hasError && (
					<Animated.View
						entering={FadeInUp.duration(200).springify()}
						style={{ marginTop: theme.spacing.xs }}
					>
						<Text variant="xs" color="error">
							{error}
						</Text>
					</Animated.View>
				)}
			</View>
		);
	},
);
interface RadioOptionProps {
	option: RadioOption;
	isSelected: boolean;
	onSelect: () => void;
	isLast: boolean;
	horizontal: boolean;
	disabled?: boolean;
	hasError?: boolean;
}
const RadioOption = React.memo(
	({
		option,
		isSelected,
		onSelect,
		isLast,
		horizontal,
		disabled,
		hasError = false,
	}: RadioOptionProps) => {
		const theme = useTheme();
		const selectedValue = useSharedValue(isSelected ? 1 : 0);
		const pressedValue = useSharedValue(0);
		React.useEffect(() => {
			selectedValue.value = withTiming(isSelected ? 1 : 0, { duration: 200 });
		}, [isSelected]);
		const handlePressIn = () => {
			if (!disabled) {
				pressedValue.value = withTiming(1, { duration: 100 });
			}
		};
		const handlePressOut = () => {
			if (!disabled) {
				pressedValue.value = withTiming(0, { duration: 150 });
			}
		};
		const animatedStyle = useAnimatedStyle(() => {
			const scale = 0.98 + (1 - 0.98) * (1 - pressedValue.value);
			return {
				transform: [{ scale }],
				opacity: disabled ? 0.6 : 1,
				backgroundColor: isSelected
					? withTiming(theme.colors.card, { duration: 200 })
					: withTiming(theme.colors.backgroundAlt, { duration: 200 }),
				borderColor: isSelected
					? withTiming(theme.colors.primary, { duration: 200 })
					: hasError
						? theme.colors.error
						: withTiming(theme.colors.divider, { duration: 200 }),
				borderWidth: hasError && !isSelected ? 1.5 : 1,
			};
		});
		const checkAnimatedStyle = useAnimatedStyle(() => {
			return {
				opacity: withTiming(isSelected ? 1 : 0, { duration: 150 }),
				transform: [{ scale: withSpring(isSelected ? 1 : 0, { damping: 15 }) }],
			};
		});
		const iconAnimatedStyle = useAnimatedStyle(() => {
			return {
				opacity: withTiming(isSelected ? 1 : 0.6, { duration: 150 }),
				transform: [
					{ scale: withSpring(isSelected ? 1.1 : 1, { damping: 15 }) },
				],
				color: isSelected ? theme.colors.primary : theme.colors.textSecondary,
			};
		});
		const textAnimatedStyle = useAnimatedStyle(() => {
			return {
				color: isSelected
					? withTiming(theme.colors.primary, { duration: 200 })
					: withTiming(theme.colors.text, { duration: 200 }),
				fontWeight: isSelected ? "600" : "500",
			};
		});
		const containerStyle = {
			marginBottom: horizontal ? 0 : isLast ? 0 : theme.spacing.xs,
			marginEnd: horizontal ? (isLast ? 0 : theme.spacing.xs) : 0,
			paddingVertical: horizontal ? theme.spacing.sm : theme.spacing.md,
			paddingHorizontal: theme.spacing.md,
			borderRadius: theme.radius.sm,
			flex: horizontal ? 1 : undefined,
		};
		return (
			<Animated.View style={[containerStyle, animatedStyle]}>
				<TouchableOpacity
					activeOpacity={1}
					onPress={onSelect}
					onPressIn={handlePressIn}
					onPressOut={handlePressOut}
					disabled={disabled}
					style={{ flex: 1 }}
				>
					<View style={{ flexDirection: "row", alignItems: "center" }}>
						<View style={{ marginEnd: 12 }}>
							{option.icon ? (
								<Animated.View style={iconAnimatedStyle}>
									<Ionicons
										name={option.icon as any}
										size={theme.sizes.iconSm}
										color={
											isSelected
												? theme.colors.primary
												: theme.colors.textSecondary
										}
									/>
								</Animated.View>
							) : (
								<View
									style={{
										width: 20,
										height: 20,
										borderRadius: 10,
										justifyContent: "center",
										alignItems: "center",
										borderColor: isSelected
											? theme.colors.primary
											: hasError
												? theme.colors.error
												: theme.colors.divider,
										borderWidth: isSelected ? 2 : 1,
									}}
								>
									<Animated.View
										style={[
											{
												width: 10,
												height: 10,
												borderRadius: 5,
												backgroundColor: theme.colors.primary,
											},
											checkAnimatedStyle,
										]}
									/>
								</View>
							)}
						</View>
						<View style={{ flex: 1 }}>
							<Animated.Text
								style={[
									{
										fontSize: theme.typography.sizes.md,
										color: isSelected
											? theme.colors.primary
											: theme.colors.text,
										fontWeight: isSelected ? "600" : "500",
									},
									textAnimatedStyle,
								]}
							>
								{option.label}
							</Animated.Text>
							{option.description && (
								<Text
									variant="sm"
									color="textSecondary"
									style={{ marginTop: theme.spacing.xs / 2 }}
								>
									{option.description}
								</Text>
							)}
						</View>
						{isSelected && !option.icon && (
							<Animated.View style={checkAnimatedStyle}>
								<Ionicons
									name="checkmark"
									size={theme.sizes.iconSm}
									color={theme.colors.primary}
									style={{ marginStart: theme.spacing.sm }}
								/>
							</Animated.View>
						)}
					</View>
				</TouchableOpacity>
			</Animated.View>
		);
	},
);
</file>

<file path="apps/merchant-app/components/fields/SwitchField.tsx">
import React, { useEffect } from "react";
import {
	View,
	Switch as RNSwitch,
	TouchableWithoutFeedback,
	StyleProp,
	ViewStyle,
	Platform,
} from "react-native";
import Animated, {
	useSharedValue,
	useAnimatedStyle,
	withTiming,
	interpolate,
	withSpring,
} from "react-native-reanimated";
import * as Haptics from "expo-haptics";
import { useTheme } from "@/stores/themeStore";
import { Text, Box } from "@/components/ui";
import { Ionicons } from "@expo/vector-icons";
export interface SwitchFieldProps {
	value: boolean;
	onValueChange: (value: boolean) => void;
	label?: string;
	description?: string;
	disabled?: boolean;
	leftIcon?: string;
	style?: StyleProp<ViewStyle>;
	error?: string;
	accessibilityLabel?: string;
	accessibilityHint?: string;
}
export const SwitchField = React.memo(
	({
		value,
		onValueChange,
		label,
		description,
		disabled = false,
		leftIcon,
		style,
		error,
	}: SwitchFieldProps) => {
		const theme = useTheme();
		const animatedValue = useSharedValue(value ? 1 : 0);
		const pressedValue = useSharedValue(0);
		const hasError = !!error;
		useEffect(() => {
			animatedValue.value = withTiming(value ? 1 : 0, { duration: 150 });
		}, [value]);
		useEffect(() => {
			if (hasError) {
				Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
				pressedValue.value = withTiming(1, { duration: 100 });
				setTimeout(() => {
					pressedValue.value = withTiming(0, { duration: 200 });
				}, 300);
			}
		}, [error]);
		const toggleSwitch = () => {
			if (!disabled) {
				Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
				onValueChange(!value);
			}
		};
		const handlePressIn = () => {
			if (!disabled) {
				pressedValue.value = withTiming(1, { duration: 100 });
			}
		};
		const handlePressOut = () => {
			if (!disabled) {
				pressedValue.value = withTiming(0, { duration: 200 });
			}
		};
		const containerAnimatedStyle = useAnimatedStyle(() => {
			const scale = interpolate(pressedValue.value, [0, 1], [1, 0.98]);
			const translateX = hasError
				? withSpring(0, {
						velocity: pressedValue.value > 0.5 ? 0 : 5,
						damping: 8,
					})
				: 0;
			const backgroundColor = hasError
				? `${theme.colors.error}10`
				: "transparent";
			const borderColor = hasError ? theme.colors.error : "transparent";
			const borderWidth = hasError ? 1 : 0;
			const borderRadius = theme.radius.md;
			return {
				transform: [{ scale }, { translateX }],
				opacity: disabled ? 0.6 : 1,
				backgroundColor,
				borderColor,
				borderWidth,
				borderRadius,
				padding: hasError ? theme.spacing.xs : 0,
			};
		});
		const handleSwitchValueChange = () => {
			if (!disabled) {
				Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
				handlePressIn();
				setTimeout(() => handlePressOut(), 200);
				onValueChange(!value);
			}
		};
		return (
			<TouchableWithoutFeedback
				onPress={toggleSwitch}
				onPressIn={handlePressIn}
				onPressOut={handlePressOut}
				disabled={disabled}
			>
				<Animated.View
					style={[
						{
							flexDirection: "row",
							alignItems: "center",
							justifyContent: "space-between",
							paddingVertical: 12,
						},
						containerAnimatedStyle,
						style,
					]}
				>
					<View
						style={{
							flexDirection: "row",
							alignItems: "center",
							flex: 1,
							marginEnd: 12,
						}}
					>
						{leftIcon && (
							<Box
								width={theme.sizes.buttonSm}
								height={theme.sizes.buttonSm}
								rounded="sm"
								bg="primaryLight"
								alignItems="center"
								justifyContent="center"
								marginEnd="sm"
							>
								<Ionicons
									name={leftIcon as any}
									size={theme.sizes.iconSm}
									color={theme.colors.primary}
								/>
							</Box>
						)}
						<View style={{ flex: 1 }}>
							{label && (
								<Text
									variant="md"
									weight="semibold"
									color={disabled ? "textMuted" : "text"}
								>
									{label}
								</Text>
							)}
							{description && (
								<Text
									variant="sm"
									color={disabled ? "textMuted" : "textSecondary"}
									style={{ marginTop: theme.spacing.xs / 2 }}
								>
									{description}
								</Text>
							)}
							{hasError && (
								<Text
									variant="xs"
									color="error"
									style={{ marginTop: theme.spacing.xs }}
								>
									{error}
								</Text>
							)}
						</View>
					</View>
					<RNSwitch
						value={value}
						onValueChange={handleSwitchValueChange}
						disabled={disabled}
						trackColor={{
							false: theme.colors.backgroundAlt,
							true: theme.colors.primary,
						}}
						thumbColor={
							Platform.OS === "ios"
								? undefined
								: value
									? theme.colors.background
									: theme.colors.card
						}
						ios_backgroundColor={
							hasError ? `${theme.colors.error}40` : theme.colors.backgroundAlt
						}
						style={
							hasError &&
							Platform.OS === "android" && {
								borderWidth: 1,
								borderColor: theme.colors.error,
								borderRadius: 16,
							}
						}
					/>
				</Animated.View>
			</TouchableWithoutFeedback>
		);
	},
);
</file>

<file path="apps/merchant-app/components/layouts/ResponsiveContainer.tsx">
import React from "react";
import { View } from "react-native";
import { useResponsiveLayout } from "@/hooks/useResponsiveLayout";
import { useTheme } from "@/stores/themeStore";
interface ResponsiveContainerProps {
	children: React.ReactNode;
	padded?: boolean;
	centered?: boolean;
	maxWidth?: number;
	style?: any;
}
export const ResponsiveContainer: React.FC<ResponsiveContainerProps> = ({
	children,
	padded = true,
	centered = false,
	maxWidth,
	style,
}) => {
	const { isTablet, deviceType } = useResponsiveLayout();
	const theme = useTheme();
	const getMaxWidth = () => {
		if (maxWidth) return maxWidth;
		if (deviceType === "tablet") return 700;
		return undefined;
	};
	const containerStyle = {
		flex: 1,
		width: "100%",
		maxWidth: getMaxWidth(),
		paddingHorizontal: padded ? theme.spacing.md : 0,
		alignSelf: isTablet ? "center" : undefined,
		alignItems: centered ? "center" : undefined,
	};
	return <View style={[containerStyle, style]}>{children}</View>;
};
</file>

<file path="apps/merchant-app/components/layouts/ScreenContainer.tsx">
import { useTheme } from "@/stores/themeStore";
import { Screen } from "expo-router/build/views/Screen";
import React from "react";
import { RefreshControlProps, ScrollView, StatusBar, View } from "react-native";
import {
	SafeAreaView,
	useSafeAreaInsets,
} from "react-native-safe-area-context";
interface ScreenContainerProps {
	children: React.ReactNode;
	scrollable?: boolean;
	screenOptions?: any;
	header?: React.ReactNode;
	padded?: boolean;
	refreshControl?: React.ReactElement<RefreshControlProps>;
	contentContainerStyle?: any;
	bottomInset?: boolean;
}
export const ScreenContainer = React.memo(
	({
		children,
		scrollable = true,
		screenOptions = { headerShown: false },
		header,
		padded = true,
		refreshControl,
		contentContainerStyle,
		bottomInset = true,
	}: ScreenContainerProps) => {
		const theme = useTheme();
		const insets = useSafeAreaInsets();
		const containerStyle = {
			flex: 1,
			backgroundColor: theme.colors.background,
		};
		const contentStyle = {
			flex: 1,
			paddingHorizontal: padded ? theme.spacing.screenPadding : 0,
		};
		const scrollContentStyle = {
			flexGrow: 1,
			paddingBottom: bottomInset
				? insets.bottom || theme.spacing.xl
				: theme.spacing.xl,
		};
		const Container = header ? View : SafeAreaView;
		return (
			<>
				<Screen options={screenOptions} />
				<StatusBar
					barStyle={theme.isDark ? "light-content" : "dark-content"}
					backgroundColor={theme.colors.background}
				/>
				<Container style={containerStyle}>
					{header}
					{scrollable ? (
						<ScrollView
							style={contentStyle}
							contentContainerStyle={[
								scrollContentStyle,
								contentContainerStyle,
							]}
							showsVerticalScrollIndicator={false}
							refreshControl={refreshControl}
							keyboardShouldPersistTaps="handled"
						>
							{children}
						</ScrollView>
					) : (
						<View style={contentStyle}>{children}</View>
					)}
				</Container>
			</>
		);
	},
);
</file>

<file path="apps/merchant-app/components/ui/Card.tsx">
import React from "react";
import {
	TouchableOpacity,
	TouchableOpacityProps,
	StyleProp,
	ViewStyle,
	View,
} from "react-native";
import { useTheme } from "@/stores/themeStore";
import { getRgba } from "@/constants/theme/colors";
interface CardProps extends TouchableOpacityProps {
	elevation?: "none" | "small" | "medium" | "large";
	padding?: string | number | SpacingToken;
	rounded?: string | RadiusToken;
	style?: StyleProp<ViewStyle>;
	children?: React.ReactNode;
	variant?:
		| "default"
		| "sage"
		| "peach"
		| "lavender"
		| "coral"
		| "mint"
		| "cream"
		| "sky"
		| "rose";
}
export const Card = React.memo(
	({
		children,
		elevation = "small",
		padding = "md",
		rounded = "md",
		style,
		onPress,
		variant = "default",
		...props
	}: CardProps) => {
		const theme = useTheme();
		const getElevation = () => {
			if (elevation === "none") return {};
			const shadowStyle = theme.shadows[elevation];
			return { ...shadowStyle, shadowColor: theme.colors.shadow };
		};
		const getPaddingValue = () => {
			return typeof padding === "number"
				? padding
				: theme.spacing[padding as SpacingToken];
		};
		const getRadiusValue = () => {
			return theme.radius[rounded as RadiusToken];
		};
		const getBackgroundColor = () => {
			if (variant === "default") return theme.colors.card;
			const accentKey =
				`accent${variant.charAt(0).toUpperCase() + variant.slice(1)}` as keyof typeof theme.colors;
			const color = theme.colors[accentKey];
			if (color) {
				return getRgba(color, 0.08);
			}
			return theme.colors.card;
		};
		const cardStyle = {
			backgroundColor: getBackgroundColor(),
			borderRadius: getRadiusValue(),
			padding: getPaddingValue(),
			borderWidth: 1,
			borderColor: theme.colors.divider,
			...getElevation(),
		};
		const ContainerComponent = onPress ? TouchableOpacity : View;
		return (
			<ContainerComponent
				activeOpacity={onPress ? 0.85 : 1}
				style={[cardStyle, style]}
				onPress={onPress}
				{...props}
			>
				{children}
			</ContainerComponent>
		);
	},
);
</file>

<file path="apps/merchant-app/components/LanguageSelector.tsx">
import React, { useCallback } from "react";
import { TouchableOpacity, View } from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { Text } from "@/components/ui/Text";
import { useLanguage } from "@/hooks/useLanguage";
import { useTheme } from "@/stores/themeStore";
export const LanguageSelector = React.memo(() => {
	const { changeLanguage, language } = useLanguage();
	const theme = useTheme();
	const handleLanguageChange = useCallback(
		(newLanguage: "en" | "ar") => {
			changeLanguage(newLanguage);
		},
		[changeLanguage],
	);
	return (
		<View style={{ alignItems: "flex-start" }}>
			<View
				style={{
					flexDirection: "row",
					justifyContent: "space-between",
				}}
			>
				<TouchableOpacity
					style={{
						flex: 1,
						margin: theme.spacing.xs,
						padding: theme.spacing.sm,
						borderRadius: theme.radius.sm,
						borderWidth: 1,
						borderColor: theme.colors.primary,
						alignItems: "center",
						justifyContent: "center",
						backgroundColor:
							language === "en" ? theme.colors.primary : "transparent",
					}}
					onPress={() => handleLanguageChange("en")}
					accessible={true}
					accessibilityRole="button"
					accessibilityLabel="Switch to English"
				>
					<View
						style={{
							flexDirection: "row",
							alignItems: "center",
							justifyContent: "center",
						}}
					>
						<Ionicons
							name="globe-outline"
							size={theme.sizes.iconSm}
							color={
								language === "en"
									? theme.colors.background
									: theme.colors.primary
							}
							style={{ marginEnd: theme.spacing.xs }}
						/>
						<Text
							variant="md"
							weight="medium"
							color={language === "en" ? "background" : "primary"}
						>
							English
						</Text>
					</View>
				</TouchableOpacity>
				<TouchableOpacity
					style={{
						flex: 1,
						margin: theme.spacing.xs,
						padding: theme.spacing.sm,
						borderRadius: theme.radius.sm,
						borderWidth: 1,
						borderColor: theme.colors.primary,
						alignItems: "center",
						justifyContent: "center",
						backgroundColor:
							language === "ar" ? theme.colors.primary : "transparent",
					}}
					onPress={() => handleLanguageChange("ar")}
					accessible={true}
					accessibilityRole="button"
					accessibilityLabel="Switch to Arabic"
				>
					<View
						style={{
							flexDirection: "row",
							alignItems: "center",
							justifyContent: "center",
						}}
					>
						<Ionicons
							name="globe-outline"
							size={theme.sizes.iconSm}
							color={
								language === "ar"
									? theme.colors.background
									: theme.colors.primary
							}
							style={{ marginEnd: theme.spacing.xs }}
						/>
						<Text
							variant="md"
							weight="medium"
							color={language === "ar" ? "background" : "primary"}
						>
							العربية
						</Text>
					</View>
				</TouchableOpacity>
			</View>
		</View>
	);
});
</file>

<file path="apps/merchant-app/constants/theme/shadows.ts">
export const shadows = {
	small: {
		shadowOffset: { width: 0, height: 1 },
		shadowOpacity: 0.03,
		shadowRadius: 2,
		elevation: 1,
	},
	medium: {
		shadowOffset: { width: 0, height: 1 },
		shadowOpacity: 0.04,
		shadowRadius: 3,
		elevation: 1,
	},
	large: {
		shadowOffset: { width: 0, height: 2 },
		shadowOpacity: 0.06,
		shadowRadius: 4,
		elevation: 2,
	},
};
</file>

<file path="apps/merchant-app/constants/theme/sizes.ts">
export const sizes = {
	touchTarget: 44,
	smallTouchTarget: 36,
	iconXs: 16,
	iconSm: 20,
	iconMd: 24,
	iconLg: 32,
	buttonSm: 36,
	buttonMd: 44,
	buttonLg: 52,
	inputHeight: 48,
	headerHeight: 56,
	tabBarHeight: 49,
	avatarSm: 32,
	avatarMd: 44,
	avatarLg: 64,
	mealImageHeight: 240,
	mealCardImageHeight: 140,
	mealImageOverlayHeight: 80,
	categoryOptionScale: 1.1,
	categoryMargin: 2,
} as const;
</file>

<file path="apps/merchant-app/constants/theme/spacing.ts">
export const spacing = {
	none: 0,
	xs: 4,
	sm: 8,
	md: 16,
	lg: 24,
	xl: 32,
	xxl: 48,
	screenPadding: 20,
	cardPadding: 16,
	itemSpacing: 12,
	sectionSpacing: 24,
} as const;
</file>

<file path="apps/merchant-app/hooks/useMealForm.ts">
import { useCallback, useEffect } from "react";
import { Keyboard } from "react-native";
import { useRouter } from "expo-router";
import * as Haptics from "expo-haptics";
import { useMealStore } from "@/stores/mealStore";
import { MealSchemaType } from "@/schemas/mealSchema";
import { Meal } from "@/types";
export const useMealForm = (mealId?: string) => {
	const router = useRouter();
	const {
		selectedMeal,
		loading,
		setSelectedMeal,
		setLoading,
		addMeal,
		updateMeal,
		deleteMeal,
	} = useMealStore();
	const isEdit = mealId !== "new" && !!mealId;
	useEffect(() => {
		if (isEdit && mealId) {
			setSelectedMeal(mealId);
		} else {
			setSelectedMeal("");
		}
	}, [mealId, isEdit, setSelectedMeal]);
	const handleFormSubmit = useCallback(
		(values: MealSchemaType) => {
			Keyboard.dismiss();
			Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
			setLoading(true);
			setTimeout(() => {
				if (isEdit && values.id) {
					updateMeal(values as Meal);
				} else {
					const newMeal = {
						...values,
						id: values.id || `meal-${Date.now()}`,
					} as Meal;
					addMeal(newMeal);
				}
				setLoading(false);
				router.back();
			}, 500);
		},
		[isEdit, router, setLoading, updateMeal, addMeal],
	);
	const handleDelete = useCallback(() => {
		if (isEdit && mealId) {
			Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);
			deleteMeal(mealId);
		}
		router.back();
	}, [isEdit, mealId, deleteMeal, router]);
	const handleSelectImage = useCallback(() => {
		console.log("Select image");
	}, []);
	return {
		meal: selectedMeal || {
			id: `meal-${Date.now()}`,
			name: "",
			name_ar: "",
			description: "",
			description_ar: "",
			price: 0,
			calories: 0,
			prepTime: 0,
			period: "Breakfast",
			available: true,
			image: "",
			isVegan: false,
			featured: false,
		},
		loading,
		isEdit,
		handleFormSubmit,
		handleDelete,
		handleSelectImage,
	};
};
</file>

<file path="apps/merchant-app/types.ts">
export interface BaseModel {
	id: string;
	createdAt?: string;
	updatedAt?: string;
}
export type Period = "Breakfast" | "Lunch" | "Dinner";
export type AlertType = "warning" | "info" | "error" | "success";
export type DietaryRestriction =
	| "none"
	| "vegetarian"
	| "vegan"
	| "glutenFree"
	| "dairyFree";
export interface MealCount {
	name: string;
	count: number;
	id: string;
}
export interface MealPrepSummary {
	period: Period;
	totalMeals: number;
	mealsToPrep: MealCount[];
}
export interface Alert extends BaseModel {
	type: AlertType;
	title: string;
	icon: string;
	timestamp?: string;
	message?: string;
	read?: boolean;
}
export interface StatItem {
	title: string;
	value: string | number;
	icon: string;
	change?: number;
	changeDirection?: "up" | "down" | "neutral";
}
export interface OverviewStats {
	activeSubscriptions: number;
	newThisWeek: number;
	newThisMonth?: number;
	totalMeals?: number;
	revenue?: {
		daily?: number;
		weekly?: number;
		monthly?: number;
	};
}
export interface QuickActionItem {
	label: string;
	icon: string;
	action: () => void;
	accessibilityLabel?: string;
	accessibilityHint?: string;
}
export interface Ingredient {
	name: string;
	quantity?: number;
	unit?: string;
}
export interface Meal extends BaseModel {
	dietaryRestriction?: DietaryRestriction;
	featured: boolean;
	isVegan: boolean;
	name: string;
	name_ar?: string;
	description: string;
	description_ar?: string;
	price: number;
	calories: number;
	prepTime: number;
	period: Period;
	available: boolean;
	image?: string;
	nutritionalInfo?: {
		protein?: number;
		carbs?: number;
		fat?: number;
		sugar?: number;
		sodium?: number;
	};
	allergens?: string[];
	tags?: string[];
}
export type RootStackParamList = {
	Home: undefined;
	Meals: undefined;
	MealDetails: {
		mealId: string;
	};
	Settings: undefined;
};
export interface ThemeTypography {
	sizes: {
		xs: number;
		sm: number;
		md: number;
		lg: number;
		xl: number;
		xxl: number;
		xxxl: number;
	};
	weights: {
		regular: string;
		medium: string;
		semibold: string;
		bold: string;
		extrabold: string;
	};
	lineHeights: {
		tight: number;
		normal: number;
		loose: number;
	};
}
export interface FieldCommonProps {
	label?: string;
	error?: string;
	required?: boolean;
	disabled?: boolean;
	accessibilityLabel?: string;
	accessibilityHint?: string;
}
export interface InputFieldProps extends FieldCommonProps {
	value: string;
	onChangeText: (text: string) => void;
	placeholder?: string;
	keyboardType?: "default" | "numeric" | "email-address" | "phone-pad";
	secureTextEntry?: boolean;
	multiline?: boolean;
	numberOfLines?: number;
	autoCapitalize?: "none" | "sentences" | "words" | "characters";
	rightIcon?: string;
	leftIcon?: string;
}
export interface SelectOption {
	value: string;
	label: string;
	icon?: string;
	description?: string;
}
export interface UserProfile {
	id: string;
	email: string;
	name: string;
	role: "admin" | "staff" | "cook";
	avatarUrl?: string;
	preferences?: {
		language?: "en" | "ar";
		theme?: "light" | "dark" | "system";
		notifications?: boolean;
	};
}
export type MealId = Meal["id"];
export type AlertId = Alert["id"];
export {};
</file>

<file path="apps/merchant-app/app/_layout.tsx">
import { ThemeProvider } from "@react-navigation/native";
import { useFonts } from "expo-font";
import * as SplashScreen from "expo-splash-screen";
import { StatusBar } from "expo-status-bar";
import { useEffect } from "react";
import "react-native-reanimated";
import { SafeAreaProvider } from "react-native-safe-area-context";
import { LogBox, StyleSheet } from "react-native";
import { useTranslation } from "@/stores/translationStore";
import { useTheme } from "@/stores/themeStore";
import { Tabs, TabList, TabTrigger, TabSlot } from "expo-router/ui";
import {
	FloatingTabBarLayout,
	TabButton,
} from "@/components/navigation/FloatingTabBar";
LogBox.ignoreLogs([
	"Sending `onAnimatedValueUpdate` with no listeners registered.",
]);
SplashScreen.preventAutoHideAsync();
export default function RootLayout() {
	const { isDark, navTheme } = useTheme();
	const { t } = useTranslation();
	const [loaded, error] = useFonts({
		SpaceMono: require("../assets/fonts/SpaceMono-Regular.ttf"),
	});
	useEffect(() => {
		if (error) throw error;
	}, [error]);
	useEffect(() => {
		if (loaded) {
			SplashScreen.hideAsync();
		}
	}, [loaded]);
	if (!loaded) {
		return null;
	}
	return (
		<SafeAreaProvider>
			<ThemeProvider value={navTheme}>
				<Tabs>
					<TabSlot />
					<TabList asChild>
						<FloatingTabBarLayout>
							<TabTrigger name="home" href="/" asChild>
								<TabButton icon="home-outline" label={t("common.dashboard")} />
							</TabTrigger>
							<TabTrigger name="menu" href="/meals" asChild>
								<TabButton
									icon="restaurant-outline"
									label={t("common.meals")}
								/>
							</TabTrigger>
							<TabTrigger name="settings" href="/settings" asChild>
								<TabButton
									icon="settings-outline"
									label={t("common.settings")}
								/>
							</TabTrigger>
						</FloatingTabBarLayout>
					</TabList>
				</Tabs>
				<StatusBar style={isDark ? "light" : "dark"} />
			</ThemeProvider>
		</SafeAreaProvider>
	);
}
const styles = StyleSheet.create({
	container: {
		position: "absolute",
		bottom: 16,
		left: 16,
		right: 16,
		zIndex: 10,
	},
	tabBarContainer: {
		flexDirection: "row",
		paddingVertical: 10,
		paddingHorizontal: 10,
	},
	tabItem: {
		flex: 1,
		paddingVertical: 8,
		paddingHorizontal: 12,
		alignItems: "center",
	},
});
</file>

<file path="apps/merchant-app/components/common/BackButton.tsx">
import React from "react";
import { TouchableOpacity } from "react-native";
import { useTheme } from "@/stores/themeStore";
import { Ionicons } from "@expo/vector-icons";
import Animated, {
	useSharedValue,
	useAnimatedStyle,
	withTiming,
	withSpring,
	interpolateColor,
} from "react-native-reanimated";
import * as Haptics from "expo-haptics";
import { useTranslation } from "@/stores/translationStore";
interface BackButtonProps {
	onPress: () => void;
	accessibilityLabel?: string;
}
export const BackButton = React.memo(
	({ onPress, accessibilityLabel }: BackButtonProps) => {
		const theme = useTheme();
		const { t, isRTL } = useTranslation();
		const pressed = useSharedValue(0);
		const handlePressIn = () => {
			pressed.value = withTiming(1, {
				duration: theme.animations.duration.fast,
			});
			Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
		};
		const handlePressOut = () => {
			pressed.value = withTiming(0, {
				duration: theme.animations.duration.fast,
			});
		};
		const animatedStyle = useAnimatedStyle(() => {
			return {
				transform: [
					{
						scale: withSpring(pressed.value === 1 ? 0.9 : 1, {
							damping: theme.animations.spring.damping.light,
						}),
					},
				],
				backgroundColor: interpolateColor(
					pressed.value,
					[0, 1],
					["transparent", theme.colors.primaryLight],
				),
				borderRadius: theme.radius.sm,
				padding: theme.spacing.xs,
				marginEnd: theme.spacing.sm,
			};
		});
		return (
			<Animated.View style={animatedStyle}>
				<TouchableOpacity
					onPress={onPress}
					onPressIn={handlePressIn}
					onPressOut={handlePressOut}
					style={{
						width: theme.sizes.touchTarget,
						height: theme.sizes.touchTarget,
						alignItems: "center",
						justifyContent: "center",
					}}
					activeOpacity={1}
					accessibilityLabel={accessibilityLabel || t("common.back")}
					accessibilityRole="button"
				>
					<Ionicons
						name={isRTL ? "chevron-forward" : "chevron-back"}
						size={theme.sizes.iconMd}
						color={theme.colors.primary}
					/>
				</TouchableOpacity>
			</Animated.View>
		);
	},
);
</file>

<file path="apps/merchant-app/components/meal/DeleteButton.tsx">
import React from "react";
import { TouchableOpacity } from "react-native";
import { useTheme } from "@/stores/themeStore";
import { Ionicons } from "@expo/vector-icons";
import Animated, {
	useSharedValue,
	useAnimatedStyle,
	withTiming,
	withSpring,
	interpolateColor,
} from "react-native-reanimated";
import * as Haptics from "expo-haptics";
import { useTranslation } from "@/stores/translationStore";
interface DeleteButtonProps {
	onPress: () => void;
	accessibilityLabel?: string;
}
export const DeleteButton = React.memo(
	({ onPress, accessibilityLabel }: DeleteButtonProps) => {
		const theme = useTheme();
		const { t } = useTranslation();
		const pressed = useSharedValue(0);
		const handlePressIn = () => {
			pressed.value = withTiming(1, {
				duration: theme.animations.duration.fast,
			});
			Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
		};
		const handlePressOut = () => {
			pressed.value = withTiming(0, {
				duration: theme.animations.duration.medium,
			});
		};
		const animatedStyle = useAnimatedStyle(() => {
			return {
				transform: [
					{
						scale: withSpring(pressed.value === 1 ? 0.9 : 1, {
							damping: theme.animations.spring.damping.light,
						}),
					},
				],
				backgroundColor: interpolateColor(
					pressed.value,
					[0, 1],
					["transparent", `${theme.colors.error}15`],
				),
				borderRadius: theme.radius.round,
				padding: theme.spacing.xs,
			};
		});
		return (
			<Animated.View style={animatedStyle}>
				<TouchableOpacity
					onPress={onPress}
					onPressIn={handlePressIn}
					onPressOut={handlePressOut}
					style={{
						width: theme.sizes.touchTarget,
						height: theme.sizes.touchTarget,
						alignItems: "center",
						justifyContent: "center",
					}}
					activeOpacity={1}
					accessibilityLabel={accessibilityLabel || t("common.delete")}
					accessibilityRole="button"
				>
					<Ionicons
						name="trash-outline"
						size={theme.sizes.iconMd}
						color={theme.colors.error}
					/>
				</TouchableOpacity>
			</Animated.View>
		);
	},
);
</file>

<file path="apps/merchant-app/components/meal/MealCard.tsx">
import React, { useCallback } from "react";
import { Pressable } from "react-native";
import { Ionicons } from "@expo/vector-icons";
import Animated, {
	FadeIn,
	LinearTransition,
	useAnimatedStyle,
	useSharedValue,
	withSpring,
	withTiming,
} from "react-native-reanimated";
import * as Haptics from "expo-haptics";
import { Link } from "expo-router";
import { Box, Text } from "@/components/ui";
import { Card } from "@/components/ui/Card";
import { Meal } from "@/types";
import { useTheme } from "@/stores/themeStore";
import { useTranslation } from "@/stores/translationStore";
interface MealCardProps {
	item: Meal;
}
const MealCard = React.memo(
	({ item }: MealCardProps) => {
		const theme = useTheme();
		const { language } = useTranslation();
		const isArabic = language === "ar";
		const pressed = useSharedValue(0);
		const handlePressIn = useCallback(() => {
			pressed.value = withTiming(1, {
				duration: theme.animations.duration.fast,
			});
			Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
		}, []);
		const handlePressOut = useCallback(() => {
			pressed.value = withTiming(0, {
				duration: theme.animations.duration.medium,
			});
		}, []);
		const cardAnimatedStyle = useAnimatedStyle(() => ({
			transform: [
				{
					scale: withSpring(
						pressed.value === 1 ? theme.animations.scale.pressed : 1,
						{ damping: theme.animations.spring.damping.light },
					),
				},
			],
		}));
		return (
			<Animated.View
				layout={LinearTransition.springify().damping(
					theme.animations.spring.damping.light,
				)}
				entering={FadeIn.duration(theme.animations.duration.slow)}
				style={cardAnimatedStyle}
			>
				<Link asChild href={`/meals/${item.id}`}>
					<Pressable onPressIn={handlePressIn} onPressOut={handlePressOut}>
						<Card
							elevation="small"
							style={{
								overflow: "hidden",
								marginBottom: theme.spacing.md,
								marginHorizontal: theme.spacing.xs,
							}}
						>
							{item.image && (
								<Animated.Image
									source={{ uri: item.image }}
									style={{
										height: theme.sizes.mealCardImageHeight - 20,
										width: "100%",
										borderTopLeftRadius: theme.radius.md,
										borderTopRightRadius: theme.radius.md,
									}}
									resizeMode="cover"
								/>
							)}
							<Box padding="md" gap="xs" alignItems="flex-start">
								<Text
									variant="lg"
									weight="medium"
									style={{ letterSpacing: 0.3 }}
								>
									{isArabic && item.name_ar ? item.name_ar : item.name}
								</Text>
								<Text
									variant="sm"
									color="textSecondary"
									marginBottom="sm"
									numberOfLines={2}
									style={{ lineHeight: 20 }}
								>
									{isArabic && item.description_ar
										? item.description_ar
										: item.description}
								</Text>
								<Box row marginTop="xs">
									<Box row alignCenter>
										<Ionicons
											name="flame-outline"
											size={theme.sizes.iconXs}
											color={theme.colors.textSecondary}
											style={{ marginEnd: theme.spacing.xs }}
										/>
										<Text variant="xs" color="textSecondary">
											{item.calories} cal
										</Text>
									</Box>
								</Box>
							</Box>
						</Card>
					</Pressable>
				</Link>
			</Animated.View>
		);
	},
	(prev, next) =>
		prev.item.id === next.item.id &&
		prev.item.name === next.item.name &&
		prev.item.name_ar === next.item.name_ar &&
		prev.item.description === next.item.description &&
		prev.item.description_ar === next.item.description_ar &&
		prev.item.calories === next.item.calories &&
		prev.item.image === next.item.image,
);
export default MealCard;
</file>

<file path="apps/merchant-app/components/meal/MealFormBasicInfo.tsx">
import React from "react";
import { TextInput } from "react-native";
import { Box, Text } from "@/components/ui";
import { Ionicons } from "@expo/vector-icons";
import { useTheme } from "@/stores/themeStore";
import FocusableInput from "@/components/fields/FocusableInput";
import { CategoryField } from "@/components/fields/CategoryField";
import { RadioField } from "@/components/fields/RadioField";
import { Meal } from "@/types";
import { useTranslation } from "@/stores/translationStore";
interface MealFormBasicInfoProps {
	meal: Partial<Meal>;
	errors: Record<string, string>;
	updateField: (field: keyof Meal, value: any) => void;
	nameInputRef: React.RefObject<TextInput>;
	nameArInputRef: React.RefObject<TextInput>;
	descInputRef: React.RefObject<TextInput>;
	descArInputRef: React.RefObject<TextInput>;
	handleSubmitEditing: (nextInput: React.RefObject<TextInput | null>) => void;
	periodOptions: Array<{
		value: string;
		label: string;
		icon: string;
	}>;
	dietaryOptions: Array<{
		value: string;
		label: string;
		description: string;
	}>;
}
export const MealFormBasicInfo: React.FC<MealFormBasicInfoProps> = ({
	meal,
	errors,
	updateField,
	nameInputRef,
	nameArInputRef,
	descInputRef,
	descArInputRef,
	handleSubmitEditing,
	periodOptions,
	dietaryOptions,
}) => {
	const theme = useTheme();
	const { t, language } = useTranslation();
	const isArabic = language === "ar";
	return (
		<Box card rounded="md" padding="lg" elevation="small">
			<Box row alignItems="center" marginBottom="md">
				<Ionicons
					name="information-circle-outline"
					size={theme.sizes.iconSm}
					color={theme.colors.primary}
					style={{ marginEnd: theme.spacing.sm }}
				/>
				<Text variant="lg" weight="semibold">
					{t("meals.basicInfo")}
				</Text>
			</Box>
			<Box marginBottom="md">
				<FocusableInput
					inputRef={nameInputRef}
					label={t("meals.mealName")}
					required
					value={meal.name}
					onChangeText={(text) => updateField("name", text)}
					placeholder={t("meals.mealName")}
					placeholderTextColor={theme.colors.textMuted}
					returnKeyType="next"
					onSubmitEditing={() => handleSubmitEditing(nameArInputRef)}
					style={{ marginBottom: theme.spacing.sm }}
					error={errors.name}
					accessibilityLabel={t("meals.mealName")}
					accessibilityRole="none"
				/>
				<FocusableInput
					inputRef={nameArInputRef}
					label={`${t("meals.mealName")} (العربية)`}
					value={meal.name_ar}
					onChangeText={(text) => updateField("name_ar", text)}
					placeholder={`${t("meals.mealName")} (العربية)`}
					placeholderTextColor={theme.colors.textMuted}
					returnKeyType="next"
					onSubmitEditing={() => handleSubmitEditing(descInputRef)}
					textAlign={isArabic ? "right" : "left"}
					accessibilityLabel={`${t("meals.mealName")} (العربية)`}
					accessibilityRole="none"
				/>
			</Box>
			<Box marginBottom="md">
				<FocusableInput
					inputRef={descInputRef}
					label={t("meals.description")}
					required
					value={meal.description}
					onChangeText={(text) => updateField("description", text)}
					placeholder={t("meals.description")}
					placeholderTextColor={theme.colors.textMuted}
					multiline={true}
					numberOfLines={4}
					returnKeyType="next"
					onSubmitEditing={() => handleSubmitEditing(descArInputRef)}
					textAlignVertical="top"
					style={{ marginBottom: theme.spacing.sm }}
					error={errors.description}
					accessibilityLabel={t("meals.description")}
					accessibilityRole="none"
				/>
				<FocusableInput
					inputRef={descArInputRef}
					label={`${t("meals.description")} (العربية)`}
					value={meal.description_ar}
					onChangeText={(text) => updateField("description_ar", text)}
					placeholder={`${t("meals.description")} (العربية)`}
					placeholderTextColor={theme.colors.textMuted}
					multiline={true}
					numberOfLines={4}
					returnKeyType="done"
					textAlign={isArabic ? "right" : "left"}
					textAlignVertical="top"
					accessibilityLabel={`${t("meals.description")} (العربية)`}
					accessibilityRole="none"
				/>
			</Box>
			<Box marginBottom="md">
				<CategoryField
					label={t("meals.mealPeriod")}
					options={periodOptions}
					value={meal.period || "Breakfast"}
					onChange={(value) => updateField("period", value)}
					error={errors.period}
					required
				/>
			</Box>
			<Box marginBottom="md">
				<RadioField
					label="Dietary Restrictions"
					options={dietaryOptions}
					value={meal.dietaryRestriction || "none"}
					onChange={(value) => updateField("dietaryRestriction", value)}
					error={errors.dietaryRestriction}
				/>
			</Box>
		</Box>
	);
};
</file>

<file path="apps/merchant-app/components/ui/Badge.tsx">
import React from "react";
import { View, ViewProps, AccessibilityState, ViewStyle } from "react-native";
import { useTheme } from "@/stores/themeStore";
import { Text } from "./Text";
export interface BadgeProps extends ViewProps {
	text: string | number;
	variant?:
		| "primary"
		| "success"
		| "warning"
		| "info"
		| "error"
		| "default"
		| "sage"
		| "peach"
		| "lavender"
		| "coral"
		| "mint"
		| "cream"
		| "sky"
		| "rose";
	size?: "sm" | "md";
	accessibilityLabel?: string;
}
export const Badge = React.memo(
	({
		text,
		variant = "default",
		size = "md",
		style,
		accessibilityLabel,
		...props
	}: BadgeProps) => {
		const theme = useTheme();
		const getBadgeStyles = () => {
			const base = {
				textColor: theme.colors.text,
				bgColor: theme.colors.backgroundAlt,
			};
			const accentVariants = [
				"sage",
				"peach",
				"lavender",
				"coral",
				"mint",
				"cream",
				"sky",
				"rose",
			];
			if (accentVariants.includes(variant)) {
				const accentKey =
					`accent${variant.charAt(0).toUpperCase() + variant.slice(1)}` as keyof typeof theme.colors;
				return {
					textColor: theme.colors.text,
					bgColor: theme.colors[accentKey],
				};
			}
			switch (variant) {
				case "primary":
					return {
						textColor: theme.colors.background,
						bgColor: theme.colors.primary,
					};
				case "success":
					return {
						textColor: theme.colors.background,
						bgColor: theme.colors.success,
					};
				case "warning":
					return {
						textColor: theme.colors.text,
						bgColor: theme.colors.warning,
					};
				case "info":
					return {
						textColor: theme.colors.background,
						bgColor: theme.colors.info,
					};
				case "error":
					return {
						textColor: theme.colors.background,
						bgColor: theme.colors.error,
					};
				default:
					return base;
			}
		};
		const getSizeStyles = () => {
			switch (size) {
				case "sm":
					return {
						paddingHorizontal: theme.spacing.sm,
						paddingVertical: theme.spacing.xs / 2,
						fontSize: "xs" as const,
					};
				default:
					return {
						paddingHorizontal: theme.spacing.sm,
						paddingVertical: theme.spacing.xs / 2 + 1,
						fontSize: "sm" as const,
					};
			}
		};
		const badgeStyle = getBadgeStyles();
		const sizeStyle = getSizeStyles();
		const badgeStyles: ViewStyle = {
			backgroundColor: badgeStyle.bgColor as string,
			paddingHorizontal: sizeStyle.paddingHorizontal,
			paddingVertical: sizeStyle.paddingVertical,
			borderRadius: theme.radius.badge,
			borderWidth: 1,
			borderColor: theme.colors.divider,
			alignItems: "center" as const,
			justifyContent: "center" as const,
			alignSelf: "flex-start" as const,
		};
		const accessibilityState: AccessibilityState = {};
		return (
			<View
				style={[badgeStyles, style]}
				accessibilityRole="text"
				accessibilityLabel={accessibilityLabel || `${text} ${variant}`}
				accessibilityState={accessibilityState}
				{...props}
			>
				<Text
					variant={sizeStyle.fontSize}
					weight="medium"
					color={badgeStyle.textColor}
				>
					{text}
				</Text>
			</View>
		);
	},
	(prevProps, nextProps) => {
		return (
			prevProps.text === nextProps.text &&
			prevProps.variant === nextProps.variant &&
			prevProps.size === nextProps.size
		);
	},
);
</file>

<file path="apps/merchant-app/components/ui/Button.tsx">
import { useTheme } from "@/stores/themeStore";
import { Ionicons } from "@expo/vector-icons";
import React from "react";
import {
	ActivityIndicator,
	TouchableOpacity,
	TouchableOpacityProps,
	AccessibilityState,
} from "react-native";
import { Text } from "./Text";
interface ButtonProps extends TouchableOpacityProps {
	title: string;
	variant?:
		| "primary"
		| "secondary"
		| "outline"
		| "ghost"
		| "sage"
		| "peach"
		| "lavender"
		| "coral"
		| "mint"
		| "cream"
		| "sky"
		| "rose";
	size?: "sm" | "md" | "lg";
	leftIcon?: string;
	rightIcon?: string;
	loading?: boolean;
	rounded?: boolean;
	fullWidth?: boolean;
	textColor?: string;
	accessibilityLabel?: string;
	accessibilityHint?: string;
}
export const Button = React.memo(
	({
		title,
		variant = "primary",
		size = "md",
		leftIcon,
		rightIcon,
		loading = false,
		rounded = false,
		fullWidth = false,
		style,
		textColor: textColorOverride,
		accessibilityLabel,
		accessibilityHint,
		...props
	}: ButtonProps) => {
		const theme = useTheme();
		const getVariantStyles = () => {
			const accentVariants = [
				"sage",
				"peach",
				"lavender",
				"coral",
				"mint",
				"cream",
				"sky",
				"rose",
			];
			if (accentVariants.includes(variant)) {
				const accentKey =
					`accent${variant.charAt(0).toUpperCase() + variant.slice(1)}` as keyof typeof theme.colors;
				return {
					backgroundColor: theme.colors[accentKey],
					textColorToken: theme.colors.text,
				};
			}
			switch (variant) {
				case "primary":
					return {
						backgroundColor: theme.colors.primary,
						textColorToken: theme.colors.background,
					};
				case "secondary":
					return {
						backgroundColor: theme.colors.cardAlt,
						textColorToken: theme.colors.text,
					};
				case "outline":
					return {
						backgroundColor: "transparent",
						borderWidth: 1,
						borderColor: theme.colors.primary,
						textColorToken: theme.colors.primary,
					};
				case "ghost":
					return {
						backgroundColor: "transparent",
						textColorToken: theme.colors.primary,
					};
				default:
					return {
						backgroundColor: theme.colors.primary,
						textColorToken: theme.colors.background,
					};
			}
		};
		const getSizeStyles = () => {
			switch (size) {
				case "sm":
					return {
						height: theme.sizes.buttonSm,
						paddingHorizontal: theme.spacing.md,
						fontSize: "sm" as const,
						iconSize: theme.sizes.iconXs,
					};
				case "md":
					return {
						height: theme.sizes.buttonMd,
						paddingHorizontal: theme.spacing.md,
						fontSize: "md" as const,
						iconSize: theme.sizes.iconSm,
					};
				case "lg":
					return {
						height: theme.sizes.buttonLg,
						paddingHorizontal: theme.spacing.lg,
						fontSize: "md" as const,
						iconSize: theme.sizes.iconMd,
					};
				default:
					return {
						height: theme.sizes.buttonMd,
						paddingHorizontal: theme.spacing.md,
						fontSize: "md" as const,
						iconSize: theme.sizes.iconSm,
					};
			}
		};
		const variantStyle = getVariantStyles();
		const sizeStyle = getSizeStyles();
		const finalTextColor = textColorOverride || variantStyle.textColorToken;
		const iconStyle = {
			marginEnd: leftIcon && title ? theme.spacing.xs : 0,
			marginStart: rightIcon && title ? theme.spacing.xs : 0,
		};
		const accessibilityState: AccessibilityState = {
			disabled: loading || props.disabled,
		};
		return (
			<TouchableOpacity
				style={[
					{
						height: sizeStyle.height,
						paddingHorizontal: sizeStyle.paddingHorizontal,
						borderRadius: rounded ? theme.radius.round : theme.radius.button,
						backgroundColor: variantStyle.backgroundColor,
						borderWidth: variantStyle.borderWidth || 0,
						borderColor: variantStyle.borderColor,
						flexDirection: "row",
						alignItems: "center",
						justifyContent: "center",
						width: fullWidth ? "100%" : undefined,
					} as TouchableOpacityProps["style"],
					style,
				]}
				activeOpacity={0.8}
				disabled={loading || props.disabled}
				accessibilityRole="button"
				accessibilityLabel={accessibilityLabel || title}
				accessibilityHint={accessibilityHint}
				accessibilityState={accessibilityState}
				{...props}
			>
				{loading ? (
					<ActivityIndicator color={finalTextColor} size="small" />
				) : (
					<>
						{leftIcon && (
							<Ionicons
								name={leftIcon as any}
								size={sizeStyle.iconSize}
								color={finalTextColor}
								style={iconStyle}
							/>
						)}
						<Text
							variant={sizeStyle.fontSize}
							weight="medium"
							color={finalTextColor}
						>
							{title}
						</Text>
						{rightIcon && (
							<Ionicons
								name={rightIcon as any}
								size={sizeStyle.iconSize}
								color={finalTextColor}
								style={iconStyle}
							/>
						)}
					</>
				)}
			</TouchableOpacity>
		);
	},
	(prevProps, nextProps) => {
		return (
			prevProps.title === nextProps.title &&
			prevProps.variant === nextProps.variant &&
			prevProps.size === nextProps.size &&
			prevProps.leftIcon === nextProps.leftIcon &&
			prevProps.rightIcon === nextProps.rightIcon &&
			prevProps.loading === nextProps.loading &&
			prevProps.disabled === nextProps.disabled &&
			prevProps.rounded === nextProps.rounded &&
			prevProps.fullWidth === nextProps.fullWidth
		);
	},
);
</file>

<file path="apps/merchant-app/constants/theme/colors.ts">
export const colorPalette = {
	primary: {
		50: "#F7F9FB",
		100: "#EFF3F8",
		200: "#DEE6F1",
		300: "#BFCFDF",
		400: "#9FB9CD",
		500: "#7FA2BB",
		600: "#6A8BA3",
		700: "#55748C",
		800: "#405C74",
		900: "#2A445C",
	},
	secondary: {
		50: "#F9F6F2",
		100: "#F1EDE8",
		200: "#E6E0D8",
		300: "#D2C8BD",
		400: "#BFB2A3",
		500: "#A59985",
		600: "#8C7F6B",
		700: "#665C4E",
		800: "#4D4639",
		900: "#332F26",
	},
	neutral: {
		0: "#FFFCF8",
		50: "#F9F6F2",
		100: "#F1EDE8",
		200: "#E6E0D8",
		300: "#D2C8BD",
		400: "#BFB2A3",
		500: "#A59985",
		600: "#8C7F6B",
		700: "#665C4E",
		800: "#4D4639",
		900: "#332F26",
		950: "#1F1C17",
		1000: "#000000",
	},
	accent: {
		sage: "#E2E5DC",
		peach: "#F1E5DC",
		lavender: "#E2E1E5",
		coral: "#EBE1DC",
		mint: "#E0E5E2",
		cream: "#F7F4ED",
		sky: "#E2E7EB",
		rose: "#E5E1E2",
	},
	semantic: {
		success: "#B7C9BB",
		warning: "#D7CCB8",
		info: "#B8C4D0",
		error: "#D7C0C0",
	},
};
export const getRgba = (hex: string, alpha: number): string => {
	const r = Number.parseInt(hex.slice(1, 3), 16);
	const g = Number.parseInt(hex.slice(3, 5), 16);
	const b = Number.parseInt(hex.slice(5, 7), 16);
	return `rgba(${r}, ${g}, ${b}, ${alpha})`;
};
export const colors = {
	light: {
		primary: colorPalette.primary[500],
		primaryDark: colorPalette.primary[600],
		primaryLight: getRgba(colorPalette.primary[300], 0.2),
		secondary: colorPalette.secondary[500],
		secondaryLight: getRgba(colorPalette.secondary[300], 0.2),
		background: colorPalette.neutral[0],
		backgroundAlt: colorPalette.neutral[50],
		card: colorPalette.neutral[0],
		cardAlt: colorPalette.neutral[100],
		text: colorPalette.neutral[800],
		textSecondary: colorPalette.neutral[600],
		textMuted: colorPalette.neutral[400],
		success: colorPalette.semantic.success,
		warning: colorPalette.semantic.warning,
		info: colorPalette.semantic.info,
		error: colorPalette.semantic.error,
		divider: getRgba(colorPalette.neutral[200], 0.5),
		overlay: getRgba(colorPalette.neutral[950], 0.1),
		overlayLight: getRgba(colorPalette.neutral[950], 0.1),
		overlayMedium: getRgba(colorPalette.neutral[950], 0.2),
		overlayDark: getRgba(colorPalette.neutral[950], 0.3),
		shadow: getRgba(colorPalette.neutral[900], 0.03),
		tabBar: colorPalette.neutral[0],
		tabIconDefault: colorPalette.neutral[400],
		tabIconSelected: colorPalette.primary[500],
		animationErrorShake: getRgba(colorPalette.semantic.error, 0.1),
		accentSage: colorPalette.accent.sage,
		accentPeach: colorPalette.accent.peach,
		accentLavender: colorPalette.accent.lavender,
		accentCoral: colorPalette.accent.coral,
		accentMint: colorPalette.accent.mint,
		accentCream: colorPalette.accent.cream,
		accentSky: colorPalette.accent.sky,
		accentRose: colorPalette.accent.rose,
	},
	dark: {
		primary: colorPalette.primary[400],
		primaryDark: colorPalette.primary[500],
		primaryLight: getRgba(colorPalette.primary[400], 0.15),
		secondary: colorPalette.secondary[400],
		secondaryLight: getRgba(colorPalette.secondary[400], 0.15),
		background: "#2A2A30",
		backgroundAlt: "#323238",
		card: "#2E2E34",
		cardAlt: "#36363C",
		text: "#E6E0D8",
		textSecondary: "#C2B6A6",
		textMuted: "#A59985",
		success: colorPalette.semantic.success,
		warning: colorPalette.semantic.warning,
		info: colorPalette.semantic.info,
		error: colorPalette.semantic.error,
		divider: getRgba(colorPalette.neutral[0], 0.05),
		overlay: getRgba(colorPalette.neutral[950], 0.3),
		overlayLight: getRgba(colorPalette.neutral[950], 0.15),
		overlayMedium: getRgba(colorPalette.neutral[950], 0.2),
		overlayDark: getRgba(colorPalette.neutral[950], 0.3),
		shadow: getRgba(colorPalette.neutral[1000], 0.08),
		tabBar: "#2E2E34",
		tabIconDefault: colorPalette.neutral[500],
		tabIconSelected: colorPalette.primary[400],
		animationErrorShake: getRgba(colorPalette.semantic.error, 0.15),
		accentSage: getRgba(colorPalette.accent.sage, 0.15),
		accentPeach: getRgba(colorPalette.accent.peach, 0.15),
		accentLavender: getRgba(colorPalette.accent.lavender, 0.15),
		accentCoral: getRgba(colorPalette.accent.coral, 0.15),
		accentMint: getRgba(colorPalette.accent.mint, 0.15),
		accentCream: getRgba(colorPalette.accent.cream, 0.15),
		accentSky: getRgba(colorPalette.accent.sky, 0.15),
		accentRose: getRgba(colorPalette.accent.rose, 0.15),
	},
};
</file>

<file path="apps/merchant-app/constants/theme/index.ts">
import { colors } from "./colors";
import { animations } from "./animations";
import { spacing } from "./spacing";
import { radius } from "./radius";
import { typography } from "./typography";
import { sizes } from "./sizes";
import { shadows } from "./shadows";
import { platform } from "./platform";
export type ThemeColors = typeof colors.light;
export type ThemeMode = "light" | "dark";
export const theme = {
	colors,
	spacing,
	radius,
	typography,
	sizes,
	shadows,
	platform,
	animations,
} as const;
</file>

<file path="apps/merchant-app/stores/translationStore.ts">
import { create } from "zustand";
import { translations } from "@/constants/i18n";
import { I18nManager, Platform } from "react-native";
import * as Expo from "expo";
import { MMKV } from "react-native-mmkv";
export type Language = keyof typeof translations;
export type TranslationsType = typeof translations.en;
const storage = new MMKV();
type TranslationCache = Record<string, string>;
interface TranslationState {
	language: Language;
	isRTL: boolean;
	translationCache: TranslationCache;
	setLanguage: (lang: Language) => Promise<void>;
	t: (path: string, params?: Record<string, string | number>) => string;
}
function buildTranslationCache(): TranslationCache {
	const cache: TranslationCache = {};
	const languages = Object.keys(translations) as Language[];
	function extractPaths(
		obj: Record<string, unknown>,
		prefix: string = "",
	): string[] {
		return Object.entries(obj).flatMap(([key, value]) => {
			const currentPath = prefix ? `${prefix}.${key}` : key;
			if (typeof value === "object" && value !== null) {
				return extractPaths(value as Record<string, unknown>, currentPath);
			}
			return [currentPath];
		});
	}
	const allPaths = extractPaths(translations.en);
	languages.forEach((lang) => {
		allPaths.forEach((path) => {
			const cacheKey = `${lang}:${path}`;
			const keys = path.split(".");
			let value: unknown = translations[lang];
			for (const key of keys) {
				if (typeof value !== "object" || value === null) {
					value = undefined;
					break;
				}
				value = (value as Record<string, unknown>)[key];
			}
			if (typeof value === "string") {
				cache[cacheKey] = value;
			} else if (lang !== "en") {
				let fallback: unknown = translations.en;
				for (const key of keys) {
					if (typeof fallback !== "object" || fallback === null) {
						fallback = undefined;
						break;
					}
					fallback = (fallback as Record<string, unknown>)[key];
				}
				if (typeof fallback === "string") {
					cache[cacheKey] = fallback as string;
				}
			}
		});
	});
	return cache;
}
export const useTranslation = create<TranslationState>()((set, get) => ({
	language: (storage.getString("language") as "ar" | "en") ?? "en",
	isRTL: I18nManager.isRTL,
	translationCache: buildTranslationCache(),
	setLanguage: async (lang: Language) => {
		storage.set("language", lang);
		const shouldBeRTL = lang === "ar";
		if (shouldBeRTL !== I18nManager.isRTL) {
			I18nManager.allowRTL(shouldBeRTL);
			I18nManager.forceRTL(shouldBeRTL);
			if (Platform.OS !== "web") await Expo.reloadAppAsync();
		}
		set({ language: lang, isRTL: shouldBeRTL });
	},
	t: (path: string): string => {
		const language = get().language;
		const cache = get().translationCache;
		const cacheKey = `${language}:${path}`;
		let value = cache[cacheKey];
		if (!value && language !== "en") {
			const enCacheKey = `en:${path}`;
			value = cache[enCacheKey];
		}
		if (!value) {
			return path;
		}
		return value;
	},
}));
</file>

<file path="apps/merchant-app/app/settings.tsx">
import React, { useCallback } from "react";
import {
	Appearance,
	Pressable,
	ScrollView,
	TouchableOpacity,
	View,
} from "react-native";
import { Stack } from "expo-router";
import Animated, {
	FadeInUp,
	FadeOutDown,
	LinearTransition,
	useAnimatedStyle,
	withTiming,
} from "react-native-reanimated";
import * as Haptics from "expo-haptics";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { Ionicons } from "@expo/vector-icons";
import { LanguageSelector } from "@/components/LanguageSelector";
import { AnimatedBox, Avatar, Box, Text } from "@/components/ui";
import { useMemoizedCallback } from "@/hooks/useMemoizedCallback";
import { useTheme } from "@/stores/themeStore";
import { useTranslation } from "@/stores/translationStore";
const AnimatedPressable = Animated.createAnimatedComponent(Pressable);
const SettingsScreen = React.memo(() => {
	const theme = useTheme();
	const insets = useSafeAreaInsets();
	const { t } = useTranslation();
	const restaurantName = "The Gourmet Spot";
	const handleThemeChange = useMemoizedCallback(
		(newTheme: "light" | "dark") => {
			Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
			Appearance.setColorScheme(newTheme);
			console.log("Theme changed to:", newTheme);
		},
		[],
	);
	const ThemeOption = React.memo(
		({
			option,
		}: {
			option: { key: "light" | "dark"; icon: string; label: string };
		}) => {
			const theme = useTheme();
			const isSelected = theme.mode === option.key;
			const animatedStyle = useAnimatedStyle(() => ({
				backgroundColor: withTiming(
					isSelected ? theme.colors.primaryLight : theme.colors.backgroundAlt,
					{ duration: 200 },
				),
				borderColor: withTiming(
					isSelected ? theme.colors.primary : theme.colors.divider,
					{ duration: 200 },
				),
				transform: [
					{ scale: withTiming(isSelected ? 1.0 : 0.98, { duration: 150 }) },
				],
				opacity: withTiming(isSelected ? 1 : 0.8, { duration: 200 }),
			}));
			const iconColor = isSelected
				? theme.colors.primary
				: theme.colors.textSecondary;
			const textColor = isSelected
				? theme.colors.primary
				: theme.colors.textSecondary;
			return (
				<AnimatedPressable
					key={option.key}
					style={[
						{
							flex: 1,
							marginHorizontal: theme.spacing.xs,
							paddingVertical: theme.spacing.md,
							paddingHorizontal: theme.spacing.sm,
							borderRadius: theme.radius.lg,
							borderWidth: 2,
							alignItems: "center",
							justifyContent: "center",
							minHeight: theme.sizes.buttonLg * 1.8,
						},
						animatedStyle,
					]}
					onPress={() => handleThemeChange(option.key)}
					accessible={true}
					accessibilityRole="button"
					accessibilityLabel={`Set theme to ${option.label}`}
					accessibilityState={{ selected: isSelected }}
				>
					<Ionicons
						name={option.icon as any}
						size={theme.sizes.iconLg}
						color={iconColor}
						style={{ marginBottom: theme.spacing.sm }}
					/>
					<Text variant="sm" weight="semibold" color={textColor}>
						{option.label}
					</Text>
				</AnimatedPressable>
			);
		},
	);
	const themeOptions = [
		{ key: "light", icon: "sunny-outline", label: t("settings.lightMode") },
		{ key: "dark", icon: "moon-outline", label: t("settings.darkMode") },
	] as const;
	const SettingsSection = useCallback(
		({
			title,
			icon,
			children,
		}: {
			title: string;
			icon: any;
			children: React.ReactNode;
		}) => (
			<AnimatedBox
				entering={FadeInUp.delay(theme.animations.delay.staggered.medium)
					.duration(theme.animations.duration.extraSlow)
					.springify()
					.damping(theme.animations.spring.damping.light)}
				exiting={FadeOutDown.duration(theme.animations.duration.medium)}
				layout={LinearTransition.duration(300)}
				padding="lg"
				marginBottom="lg"
				bg="card"
				rounded="xl"
				style={{
					borderWidth: 1,
					borderColor: theme.colors.divider,
				}}
			>
				<Box row alignCenter marginBottom="md">
					<Ionicons
						name={icon}
						size={theme.sizes.iconSm}
						color={theme.colors.primary}
						style={{ marginEnd: theme.spacing.sm }}
					/>
					<Text variant="lg" weight="semibold" color="textSecondary">
						{title}
					</Text>
				</Box>
				{children}
			</AnimatedBox>
		),
		[theme],
	);
	return (
		<View
			style={{
				flex: 1,
				backgroundColor: theme.colors.background,
				paddingTop: insets.top,
			}}
		>
			<Stack.Screen options={{ headerShown: false }} />
			<Box
				row
				alignItems="center"
				paddingHorizontal="md"
				paddingVertical="sm"
				style={{
					height: theme.sizes.headerHeight,
				}}
			>
				<Text variant="xl" weight="semibold" numberOfLines={1}>
					{t("common.settings")}
				</Text>
			</Box>
			<ScrollView
				contentContainerStyle={{
					paddingHorizontal: theme.spacing.md,
					paddingBottom: theme.spacing.md,
				}}
				showsVerticalScrollIndicator={false}
			>
				<AnimatedBox
					entering={FadeInUp.delay(theme.animations.delay.staggered.medium)
						.duration(theme.animations.duration.extraSlow)
						.springify()
						.damping(theme.animations.spring.damping.light)}
					exiting={FadeOutDown.duration(theme.animations.duration.medium)}
					row
					alignCenter
					bg="card"
					padding="md"
					rounded="xl"
					marginBottom="lg"
					style={{ borderWidth: 1, borderColor: theme.colors.divider }}
				>
					<Avatar
						text={restaurantName.charAt(0)}
						size="md"
						style={{ marginEnd: theme.spacing.md }}
					/>
					<Box alignItems="flex-start" flex={1}>
						<Text variant="sm" color="textSecondary">
							{t("settings.signedInAs") ?? "Signed in as"}
						</Text>
						<Text variant="lg" weight="semibold" numberOfLines={1}>
							{restaurantName}
						</Text>
					</Box>
					<Ionicons
						name="person-circle-outline"
						size={theme.sizes.iconLg}
						color={theme.colors.textMuted}
					/>
				</AnimatedBox>
				<SettingsSection title={t("settings.language")} icon="language-outline">
					<LanguageSelector />
				</SettingsSection>
				<SettingsSection
					title={t("settings.theme")}
					icon="color-palette-outline"
				>
					<View
						style={{
							flexDirection: "row",
							marginHorizontal: -theme.spacing.xs,
						}}
					>
						{themeOptions.map((option) => (
							<ThemeOption key={option.key} option={option} />
						))}
					</View>
				</SettingsSection>
				<SettingsSection
					title={t("settings.appInfo")}
					icon="information-circle-outline"
				>
					<Box row justifyContent="space-between" alignItems="center">
						<Text variant="md" weight="medium" color="textSecondary">
							{t("common.version")}
						</Text>
						<Text variant="md" weight="medium" color="textMuted">
							v1.0.0
						</Text>
					</Box>
				</SettingsSection>
				<AnimatedBox
					entering={FadeInUp.delay(theme.animations.delay.staggered.medium)
						.duration(theme.animations.duration.extraSlow)
						.springify()
						.damping(theme.animations.spring.damping.light)}
					exiting={FadeOutDown.duration(theme.animations.duration.medium)}
				>
					<TouchableOpacity
						style={{
							marginTop: theme.spacing.lg,
							padding: theme.spacing.md,
							borderRadius: theme.radius.lg,
							backgroundColor: theme.colors.cardAlt,
							borderWidth: 1,
							borderColor: theme.colors.error,
							flexDirection: "row",
							alignItems: "center",
							justifyContent: "center",
						}}
						onPress={() => {
							Haptics.notificationAsync(
								Haptics.NotificationFeedbackType.Warning,
							);
							console.log("Logout Pressed");
						}}
					>
						<Ionicons
							name="log-out-outline"
							size={theme.sizes.iconMd}
							color={theme.colors.error}
							style={{ marginEnd: theme.spacing.sm }}
						/>
						<Text variant="md" weight="semibold" color="error">
							{t("settings.logout")}
						</Text>
					</TouchableOpacity>
				</AnimatedBox>
			</ScrollView>
		</View>
	);
});
export default SettingsScreen;
</file>

<file path="apps/merchant-app/components/dashboard/PrepCard.tsx">
import React, { useCallback } from "react";
import { Pressable } from "react-native";
import { Ionicons } from "@expo/vector-icons";
import Animated, {
	useSharedValue,
	useAnimatedStyle,
	withTiming,
	interpolate,
	Extrapolation,
} from "react-native-reanimated";
import * as Haptics from "expo-haptics";
import { Box, Text } from "@/components/ui";
import { MealPrepSummary } from "@/types";
import { useTheme } from "@/stores/themeStore";
import { Card } from "@/components/ui/Card";
import { useTranslation } from "@/stores/translationStore";
interface TodayPrepCardProps {
	summary: MealPrepSummary;
	onPress: () => void;
	variant?:
		| "sage"
		| "peach"
		| "lavender"
		| "coral"
		| "mint"
		| "cream"
		| "sky"
		| "rose";
}
const PREP_CARD_WIDTH = 200;
const AnimatedPressable = Animated.createAnimatedComponent(Pressable);
export const TodayPrepCard = React.memo(
	({ summary, onPress, variant = "cream" }: TodayPrepCardProps) => {
		const theme = useTheme();
		const { t } = useTranslation();
		const pressed = useSharedValue(0);
		const hovered = useSharedValue(0);
		const periodIcons = {
			Breakfast: "cafe-outline",
			Lunch: "restaurant-outline",
			Dinner: "fast-food-outline",
		};
		const translatedPeriod = t(`periods.${summary.period.toLowerCase()}`);
		const handlePressIn = useCallback(() => {
			Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
			pressed.value = withTiming(1, {
				duration: theme.animations.duration.medium,
			});
		}, []);
		const handlePressOut = useCallback(() => {
			pressed.value = withTiming(0, {
				duration: theme.animations.duration.slow,
			});
		}, []);
		const handleHoverIn = useCallback(() => {
			hovered.value = withTiming(1, {
				duration: theme.animations.duration.medium,
			});
		}, []);
		const handleHoverOut = useCallback(() => {
			hovered.value = withTiming(0, {
				duration: theme.animations.duration.medium,
			});
		}, []);
		const handlePress = useCallback(() => {
			Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
			onPress();
		}, [onPress]);
		const animatedCardStyle = useAnimatedStyle(() => {
			const scale = interpolate(
				pressed.value,
				[0, 1],
				[1, 0.98],
				Extrapolation.CLAMP,
			);
			return {
				transform: [{ scale }],
			};
		});
		return (
			<AnimatedPressable
				onPress={handlePress}
				onPressIn={handlePressIn}
				onPressOut={handlePressOut}
				onHoverIn={handleHoverIn}
				onHoverOut={handleHoverOut}
				style={[
					{
						width: PREP_CARD_WIDTH,
						margin: theme.spacing.xs,
					},
					animatedCardStyle,
				]}
			>
				<Card
					variant={variant}
					rounded="sm"
					padding="md"
					elevation="small"
					style={{
						minHeight: theme.sizes.buttonLg * 3.5,
					}}
				>
					<Box row alignCenter marginBottom="xs">
						<Ionicons
							name={
								periodIcons[summary.period as keyof typeof periodIcons] as any
							}
							size={theme.sizes.iconSm}
							color={theme.colors.textSecondary}
							style={{ marginEnd: theme.spacing.sm }}
						/>
						<Text variant="md" weight="medium" fontFamily="serif">
							{translatedPeriod}
						</Text>
					</Box>
					<Box marginTop="xs" flex={1} gap="xs" justifyContent="space-between">
						{summary.mealsToPrep.slice(0, 3).map((meal) => (
							<Box
								key={meal.id}
								row
								justifyContent="space-between"
								paddingVertical={theme.spacing.xs / 2}
							>
								<Text
									variant="sm"
									numberOfLines={1}
									style={{
										flexShrink: 1,
										marginEnd: theme.spacing.sm,
									}}
								>
									{meal.name}
								</Text>
								<Text variant="sm" weight="medium" color="textSecondary">
									{meal.count}
								</Text>
							</Box>
						))}
					</Box>
				</Card>
			</AnimatedPressable>
		);
	},
);
</file>

<file path="apps/merchant-app/components/fields/CategoryField.tsx">
import React, { useCallback } from "react";
import {
	View,
	StyleProp,
	ViewStyle,
	TouchableWithoutFeedback,
} from "react-native";
import * as Haptics from "expo-haptics";
import { useTheme } from "@/stores/themeStore";
import { Text } from "@/components/ui";
import { Ionicons } from "@expo/vector-icons";
import Animated, {
	useSharedValue,
	useAnimatedStyle,
	withTiming,
	withSpring,
	interpolateColor,
	FadeInUp,
} from "react-native-reanimated";
export interface CategoryOption {
	value: string;
	label: string;
	icon: string;
}
export interface CategoryFieldProps {
	options: CategoryOption[];
	value: string;
	onChange: (value: string) => void;
	label?: string;
	style?: StyleProp<ViewStyle>;
	error?: string;
	required?: boolean;
	disabled?: boolean;
	accessibilityLabel?: string;
	accessibilityHint?: string;
}
export const CategoryField = React.memo(
	({
		options,
		value,
		onChange,
		label,
		style,
		error,
		required,
		disabled = false,
	}: CategoryFieldProps) => {
		const theme = useTheme();
		const hasError = !!error;
		const errorAnim = useSharedValue(0);
		React.useEffect(() => {
			if (hasError) {
				Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
				errorAnim.value = 0;
				errorAnim.value = withTiming(1, { duration: 300 });
			} else {
				errorAnim.value = withTiming(0, { duration: 200 });
			}
		}, [hasError, error]);
		const handleSelect = useCallback(
			(optionValue: string) => {
				if (!disabled && optionValue !== value) {
					Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
					onChange(optionValue);
				}
			},
			[disabled, value, onChange],
		);
		const containerAnimStyle = useAnimatedStyle(() => {
			const translateX = hasError
				? withSpring(0, {
						velocity: errorAnim.value > 0.5 ? 0 : 10,
						damping: 5,
						stiffness: 200,
					})
				: 0;
			const backgroundColor = hasError
				? `${theme.colors.error}10`
				: "transparent";
			const borderColor = hasError ? theme.colors.error : "transparent";
			const borderWidth = hasError ? 1.5 : 0;
			return {
				transform: [{ translateX }],
				backgroundColor,
				borderColor,
				borderWidth,
				borderRadius: theme.radius.md,
				padding: hasError ? 4 : 0,
				overflow: "hidden",
			};
		});
		return (
			<View style={[{ width: "100%" }, style]}>
				{label && (
					<View
						style={{ flexDirection: "row", marginBottom: theme.spacing.xs }}
					>
						<Text
							variant="sm"
							weight="semibold"
							color={hasError ? "error" : "textSecondary"}
						>
							{label}
						</Text>
						{required && (
							<Text
								variant="sm"
								weight="semibold"
								color="error"
								style={{ marginStart: theme.spacing.xs / 2 }}
							>
								*
							</Text>
						)}
					</View>
				)}
				<Animated.View style={[{ width: "100%" }, containerAnimStyle]}>
					<Animated.View
						style={{
							flexDirection: "row",
							backgroundColor: theme.colors.backgroundAlt,
							borderRadius: theme.radius.md,
							padding: theme.spacing.xs,
							opacity: disabled ? 0.6 : 1,
						}}
					>
						{options.map((option) => (
							<CategoryOption
								key={option.value}
								option={option}
								isSelected={option.value === value}
								onSelect={() => handleSelect(option.value)}
								disabled={disabled}
								hasError={hasError}
							/>
						))}
					</Animated.View>
				</Animated.View>
				{hasError && (
					<Animated.View
						entering={FadeInUp.duration(200).springify()}
						style={{ marginTop: theme.spacing.xs }}
					>
						<Text variant="xs" color="error">
							{error}
						</Text>
					</Animated.View>
				)}
			</View>
		);
	},
);
interface CategoryOptionProps {
	option: CategoryOption;
	isSelected: boolean;
	onSelect: () => void;
	disabled?: boolean;
	hasError?: boolean;
}
const CategoryOption = React.memo(
	({
		option,
		isSelected,
		onSelect,
		disabled,
		hasError = false,
	}: CategoryOptionProps) => {
		const theme = useTheme();
		const selectedValue = useSharedValue(isSelected ? 1 : 0);
		const pressedValue = useSharedValue(0);
		React.useEffect(() => {
			selectedValue.value = withTiming(isSelected ? 1 : 0, {
				duration: theme.animations.duration.medium,
			});
		}, [isSelected]);
		const handlePressIn = () => {
			if (!disabled) {
				pressedValue.value = withTiming(1, {
					duration: theme.animations.duration.fast,
				});
			}
		};
		const handlePressOut = () => {
			if (!disabled) {
				pressedValue.value = withTiming(0, {
					duration: theme.animations.duration.medium,
				});
			}
		};
		const containerAnimatedStyle = useAnimatedStyle(() => {
			const scale =
				theme.animations.scale.pressed +
				(1 - theme.animations.scale.pressed) * (1 - pressedValue.value);
			const backgroundColor =
				hasError && !isSelected
					? interpolateColor(
							selectedValue.value,
							[0, 1],
							[`${theme.colors.error}10`, theme.colors.card],
						)
					: interpolateColor(
							selectedValue.value,
							[0, 1],
							["transparent", theme.colors.card],
						);
			const borderColor =
				hasError && !isSelected
					? theme.colors.error
					: isSelected
						? theme.colors.primary
						: "transparent";
			const elevation = selectedValue.value * 2;
			const shadowOpacity = selectedValue.value * 0.15;
			return {
				flex: 1,
				margin: theme.sizes.categoryMargin,
				paddingVertical: theme.spacing.sm,
				transform: [{ scale }],
				backgroundColor,
				borderRadius: theme.radius.sm,
				alignItems: "center",
				justifyContent: "center",
				shadowColor: hasError ? theme.colors.error : theme.colors.shadow,
				shadowRadius: 2,
				shadowOpacity,
				elevation,
				borderWidth: hasError && !isSelected ? 1 : 0,
				borderColor,
			};
		});
		const iconAnimatedStyle = useAnimatedStyle(() => {
			const scale = withSpring(
				isSelected ? theme.sizes.categoryOptionScale : 1,
				{ damping: theme.animations.spring.damping.light },
			);
			return {
				transform: [{ scale }],
			};
		});
		const textAnimatedStyle = useAnimatedStyle(() => {
			const color = interpolateColor(
				selectedValue.value,
				[0, 1],
				[theme.colors.text, theme.colors.primary],
			);
			return {
				color,
				fontWeight: isSelected ? "600" : "500",
				fontSize: theme.typography.sizes.sm,
			};
		});
		return (
			<TouchableWithoutFeedback
				onPress={onSelect}
				onPressIn={handlePressIn}
				onPressOut={handlePressOut}
				disabled={disabled}
			>
				<Animated.View style={containerAnimatedStyle}>
					<Animated.View style={iconAnimatedStyle}>
						<Ionicons
							name={option.icon as any}
							size={theme.sizes.iconSm}
							color={
								isSelected ? theme.colors.primary : theme.colors.textSecondary
							}
						/>
					</Animated.View>
					<Animated.Text style={textAnimatedStyle}>
						{option.label}
					</Animated.Text>
				</Animated.View>
			</TouchableWithoutFeedback>
		);
	},
);
</file>

<file path="apps/merchant-app/components/fields/FocusableInput.tsx">
import React, {
	useState,
	useEffect,
	useImperativeHandle,
	forwardRef,
} from "react";
import {
	TextInput,
	StyleProp,
	TextStyle,
	KeyboardTypeOptions,
	ReturnKeyTypeOptions,
	Platform,
	NativeSyntheticEvent,
	TextInputFocusEventData,
	TouchableWithoutFeedback,
	View,
	AccessibilityRole,
} from "react-native";
import Animated, {
	useAnimatedStyle,
	useSharedValue,
	withTiming,
	interpolateColor,
	withSpring,
} from "react-native-reanimated";
import * as Haptics from "expo-haptics";
import { useTheme } from "@/stores/themeStore";
import { Text } from "@/components/ui";
import { z } from "zod";
const AnimatedTextInput = Animated.createAnimatedComponent(TextInput);
interface ValidationProps {
	schema?: z.ZodType<any>;
	onValidation?: (isValid: boolean, error?: string) => void;
}
export interface FocusableInputProps extends ValidationProps {
	inputRef?: React.RefObject<TextInput | null>;
	style?: StyleProp<TextStyle>;
	value?: string;
	onChangeText: (text: string) => void;
	placeholder?: string;
	placeholderTextColor?: string;
	returnKeyType?: ReturnKeyTypeOptions;
	onSubmitEditing?: () => void;
	multiline?: boolean;
	numberOfLines?: number;
	keyboardType?: KeyboardTypeOptions;
	textAlign?: "left" | "center" | "right";
	textAlignVertical?: "top" | "center" | "bottom";
	maxLength?: number;
	autoCapitalize?: "none" | "sentences" | "words" | "characters";
	autoCorrect?: boolean;
	editable?: boolean;
	secureTextEntry?: boolean;
	onFocus?: (e: NativeSyntheticEvent<TextInputFocusEventData>) => void;
	onBlur?: (e: NativeSyntheticEvent<TextInputFocusEventData>) => void;
	label?: string;
	error?: string;
	required?: boolean;
	accessibilityLabel?: string;
	accessibilityHint?: string;
	accessibilityRole?: AccessibilityRole;
}
const FocusableInput = forwardRef<TextInput, FocusableInputProps>(
	(
		{
			inputRef: externalInputRef,
			style,
			value,
			onChangeText,
			placeholder,
			placeholderTextColor,
			returnKeyType,
			onSubmitEditing,
			multiline = false,
			numberOfLines = 1,
			keyboardType = "default",
			textAlign,
			textAlignVertical,
			maxLength,
			autoCapitalize = "sentences",
			autoCorrect = true,
			editable = true,
			secureTextEntry = false,
			onFocus,
			onBlur,
			label,
			error,
			required,
			schema,
			onValidation,
			accessibilityLabel,
			accessibilityHint,
			accessibilityRole,
		},
		ref,
	) => {
		const theme = useTheme();
		const [isFocused, setIsFocused] = useState(false);
		const internalInputRef = React.useRef<TextInput>(null);
		const hasError = !!error;
		useImperativeHandle(
			ref,
			() => {
				if (internalInputRef.current) {
					return internalInputRef.current;
				}
				return new TextInput({}) as TextInput;
			},
			[],
		);
		const inputRefToUse = externalInputRef || internalInputRef;
		const focusProgress = useSharedValue(0);
		const errorProgress = useSharedValue(0);
		useEffect(() => {
			focusProgress.value = withTiming(isFocused ? 1 : 0, {
				duration: 200,
			});
			if (isFocused) {
				if (Platform.OS !== "android") {
					Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light).catch(
						() => {},
					);
				}
			}
		}, [isFocused]);
		useEffect(() => {
			errorProgress.value = withTiming(hasError ? 1 : 0, {
				duration: 200,
			});
			if (hasError && errorProgress.value === 0) {
				Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error).catch(
					() => {},
				);
			}
		}, [hasError]);
		const containerAnimatedStyle = useAnimatedStyle(() => {
			const shadowOpacity = hasError
				? errorProgress.value * 0.3
				: focusProgress.value * 0.15;
			return {
				marginBottom: hasError
					? theme.spacing.md
					: multiline
						? theme.spacing.sm
						: 0,
				borderRadius: theme.radius.input,
				shadowColor: hasError ? theme.colors.error : theme.colors.primary,
				shadowOpacity,
				shadowRadius: hasError ? 5 : 3,
				elevation: hasError ? errorProgress.value * 4 : focusProgress.value * 2,
			};
		});
		const inputAnimatedStyle = useAnimatedStyle(() => {
			const borderColor = hasError
				? interpolateColor(
						errorProgress.value,
						[0, 1],
						[theme.colors.divider, theme.colors.error],
					)
				: interpolateColor(
						focusProgress.value,
						[0, 1],
						[theme.colors.divider, theme.colors.primary],
					);
			const translateX = hasError
				? withSpring(0, {
						velocity: errorProgress.value > 0.5 ? 0 : 10,
						damping: theme.animations.spring.damping.medium,
						stiffness: theme.animations.spring.stiffness.medium,
					})
				: 0;
			return {
				borderColor,
				borderWidth: hasError ? 1.5 : 1,
				paddingHorizontal: theme.spacing.md,
				paddingVertical: multiline ? theme.spacing.sm : 0,
				color: editable ? theme.colors.text : theme.colors.textSecondary,
				backgroundColor: theme.colors.card,
				borderRadius: theme.radius.input,
				height: multiline ? undefined : theme.sizes.inputHeight,
				minHeight: multiline
					? theme.sizes.inputHeight * (numberOfLines || 1)
					: undefined,
				textAlign,
				textAlignVertical,
				opacity: editable ? 1 : 0.8,
				transform: [{ translateX }],
				...(style as any),
			};
		});
		const focusInput = () => {
			if (inputRefToUse.current && editable) {
				inputRefToUse.current.focus();
			}
		};
		const handleFocus = (e: NativeSyntheticEvent<TextInputFocusEventData>) => {
			setIsFocused(true);
			if (onFocus) {
				onFocus(e);
			}
		};
		const validateInput = (text: string) => {
			if (!schema) return true;
			try {
				schema.parse(text);
				if (onValidation) {
					onValidation(true);
				}
				return true;
			} catch (error) {
				if (error instanceof z.ZodError) {
					const errorMessage = error.errors[0]?.message || "Invalid input";
					if (onValidation) {
						onValidation(false, errorMessage);
					}
				}
				return false;
			}
		};
		const handleBlur = (e: NativeSyntheticEvent<TextInputFocusEventData>) => {
			setIsFocused(false);
			if (schema && value !== undefined) {
				validateInput(value);
			}
			if (onBlur) {
				onBlur(e);
			}
		};
		return (
			<View>
				{label && (
					<View
						style={{ flexDirection: "row", marginBottom: theme.spacing.xs }}
					>
						<Text variant="sm" weight="semibold" color="textSecondary">
							{label}
						</Text>
						{required && (
							<Text
								variant="sm"
								weight="semibold"
								color="error"
								style={{ marginStart: theme.spacing.xs / 2 }}
							>
								*
							</Text>
						)}
					</View>
				)}
				<TouchableWithoutFeedback onPress={focusInput}>
					<Animated.View style={containerAnimatedStyle}>
						<AnimatedTextInput
							ref={inputRefToUse}
							style={inputAnimatedStyle}
							value={value}
							onChangeText={onChangeText}
							placeholder={placeholder}
							placeholderTextColor={
								placeholderTextColor || theme.colors.textMuted
							}
							returnKeyType={returnKeyType}
							onSubmitEditing={onSubmitEditing}
							onFocus={handleFocus}
							onBlur={handleBlur}
							multiline={multiline}
							numberOfLines={numberOfLines}
							keyboardType={keyboardType}
							selectionColor={theme.colors.primary}
							maxLength={maxLength}
							autoCapitalize={autoCapitalize}
							autoCorrect={autoCorrect}
							editable={editable}
							secureTextEntry={secureTextEntry}
							accessibilityHint={accessibilityHint}
							accessibilityRole={accessibilityRole}
							accessibilityLabel={accessibilityLabel}
						/>
					</Animated.View>
				</TouchableWithoutFeedback>
				{hasError && (
					<Text
						variant="xs"
						color="error"
						style={{
							marginTop: theme.spacing.xs,
							marginHorizontal: theme.spacing.xs,
						}}
					>
						{error}
					</Text>
				)}
			</View>
		);
	},
);
export default FocusableInput;
</file>

<file path="apps/merchant-app/components/meal/MealFormHeader.tsx">
import { AnimatedBox, Box, Text } from "@/components/ui";
import { useTheme } from "@/stores/themeStore";
import { useRouter } from "expo-router";
import React from "react";
import { FadeIn } from "react-native-reanimated";
import { DeleteButton } from "./DeleteButton";
import { BackButton } from "@/components/common/BackButton";
import { useTranslation } from "@/stores/translationStore";
interface MealFormHeaderProps {
	title: string;
	isEdit: boolean;
	mealName?: string;
	mealNameAr?: string;
	onDelete: () => void;
}
export const MealFormHeader = React.memo(
	({ title, isEdit, mealName, mealNameAr, onDelete }: MealFormHeaderProps) => {
		const theme = useTheme();
		const router = useRouter();
		const { t, language } = useTranslation();
		const isArabic = language === "ar";
		return (
			<AnimatedBox
				row
				alignItems="center"
				justifyContent="space-between"
				paddingHorizontal="md"
				style={{
					height: theme.sizes.headerHeight,
					borderBottomWidth: 1,
					borderBottomColor: theme.colors.divider,
				}}
				entering={FadeIn.duration(300)}
			>
				<Box row alignItems="center">
					<BackButton
						onPress={() => router.back()}
						accessibilityLabel={t("common.back")}
					/>
					<Text variant="xl" weight="semibold" numberOfLines={1}>
						{isEdit ? (isArabic && mealNameAr ? mealNameAr : mealName) : title}
					</Text>
				</Box>
				{isEdit && (
					<DeleteButton
						onPress={onDelete}
						accessibilityLabel={t("common.delete")}
					/>
				)}
			</AnimatedBox>
		);
	},
);
</file>

<file path="apps/merchant-app/components/meal/MealImagePreview.tsx">
import React from "react";
import { Image, TouchableOpacity } from "react-native";
import { Box, Text, AnimatedBox } from "@/components/ui";
import { Ionicons } from "@expo/vector-icons";
import { useTheme } from "@/stores/themeStore";
import { FadeInUp } from "react-native-reanimated";
import { useTranslation } from "@/stores/translationStore";
interface MealImagePreviewProps {
	image?: string;
	name?: string;
	nameAr?: string;
	calories?: number;
	prepTime?: number;
	onSelectImage?: () => void;
}
export const MealImagePreview: React.FC<MealImagePreviewProps> = React.memo(
	({ image, name, nameAr, calories, prepTime, onSelectImage }) => {
		const theme = useTheme();
		const { t, language } = useTranslation();
		const isArabic = language === "ar";
		return (
			<AnimatedBox
				entering={FadeInUp.delay(100).duration(
					theme.animations.duration.extraSlow,
				)}
				style={{
					borderRadius: theme.radius.lg,
					overflow: "hidden",
					height: theme.sizes.mealImageHeight,
				}}
			>
				{image ? (
					<Box style={{ height: "100%", width: "100%", position: "relative" }}>
						<Image
							source={{ uri: image }}
							style={{ width: "100%", height: "100%" }}
							resizeMode="cover"
							accessibilityLabel={
								isArabic && nameAr ? nameAr : name || t("meals.mealName")
							}
						/>
						<Box
							style={{
								position: "absolute",
								bottom: 0,
								left: 0,
								right: 0,
								height: theme.sizes.mealImageOverlayHeight,
								backgroundColor: theme.colors.overlayLight,
								padding: theme.spacing.md,
								justifyContent: "flex-end",
							}}
						>
							<Text
								variant="lg"
								weight="semibold"
								color="#fff"
								numberOfLines={1}
							>
								{isArabic && nameAr ? nameAr : name || t("meals.mealName")}
							</Text>
							<Box row alignItems="center" marginTop="xs">
								<Ionicons
									name="flame-outline"
									size={theme.sizes.iconSm}
									color="#fff"
									style={{ marginEnd: theme.spacing.xs }}
								/>
								<Text variant="sm" color="#fff">
									{calories ? `${calories} cal` : "0 cal"}
								</Text>
								<Text
									variant="sm"
									color="#fff"
									style={{ marginHorizontal: theme.spacing.xs }}
								>
									•
								</Text>
								<Ionicons
									name="time-outline"
									size={theme.sizes.iconSm}
									color="#fff"
									style={{ marginEnd: theme.spacing.xs }}
								/>
								<Text variant="sm" color="#fff">
									{prepTime ? `${prepTime} min` : "0 min"}
								</Text>
							</Box>
						</Box>
						<TouchableOpacity
							style={{
								position: "absolute",
								top: theme.spacing.sm,
								right: theme.spacing.sm,
								backgroundColor: theme.colors.overlayMedium,
								borderRadius: theme.radius.round,
								padding: theme.spacing.xs,
							}}
							onPress={onSelectImage}
							accessibilityLabel={t("meals.addImage")}
							accessibilityRole="button"
						>
							<Ionicons
								name="camera-outline"
								size={theme.sizes.iconMd}
								color="#fff"
							/>
						</TouchableOpacity>
					</Box>
				) : (
					<TouchableOpacity
						style={{
							height: "100%",
							width: "100%",
							backgroundColor: theme.colors.cardAlt,
							alignItems: "center",
							justifyContent: "center",
						}}
						onPress={onSelectImage}
						accessibilityLabel={t("meals.addImage")}
						accessibilityRole="button"
					>
						<Ionicons
							name="camera-outline"
							size={theme.sizes.iconLg}
							color={theme.colors.primary}
							style={{ marginBottom: theme.spacing.sm }}
						/>
						<Text variant="md" weight="semibold" color="primary">
							{t("meals.addImage")}
						</Text>
					</TouchableOpacity>
				)}
			</AnimatedBox>
		);
	},
	(prevProps, nextProps) => {
		return (
			prevProps.image === nextProps.image &&
			prevProps.name === nextProps.name &&
			prevProps.nameAr === nextProps.nameAr &&
			prevProps.calories === nextProps.calories &&
			prevProps.prepTime === nextProps.prepTime
		);
	},
);
</file>

<file path="apps/merchant-app/components/ui/Tabs.tsx">
import React, { useMemo } from "react";
import { Pressable } from "react-native";
import { Box } from "./Box";
import { Text } from "./Text";
import { useTheme } from "@/stores/themeStore";
import * as Haptics from "expo-haptics";
import { Ionicons } from "@expo/vector-icons";
import { radius } from "@/constants/theme/radius";
type TabItem = {
	key: string;
	label: string;
	iconLeft?: string;
	iconRight?: string;
	accessibilityLabel?: string;
	accessibilityHint?: string;
};
export type TabType = string | TabItem;
interface TabsProps {
	tabs: TabType[];
	selectedTab: string;
	onSelectTab: (tab: string) => void;
	labelRender?: (tab: string) => string;
	accessibilityLabel?: string;
	accessibilityHint?: string;
}
export const Tabs = React.memo(
	({
		tabs,
		selectedTab,
		onSelectTab,
		labelRender,
		accessibilityLabel,
		accessibilityHint,
	}: TabsProps) => {
		const theme = useTheme();
		const handlePress = (tab: TabType) => {
			const tabKey = typeof tab === "string" ? tab : tab.key;
			if (tabKey !== selectedTab) {
				Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
				onSelectTab(tabKey);
			}
		};
		const getTabLabel = (tab: TabType): string => {
			if (typeof tab === "string") {
				return labelRender ? labelRender(tab) : tab;
			}
			return tab.label;
		};
		const isTabSelected = (tab: TabType): boolean => {
			const tabKey = typeof tab === "string" ? tab : tab.key;
			return tabKey === selectedTab;
		};
		const renderedTabs = useMemo(() => {
			return tabs.map((tab) => {
				const isSelected = isTabSelected(tab);
				const tabKey = typeof tab === "string" ? tab : tab.key;
				const tabLabel = getTabLabel(tab);
				const iconLeft = typeof tab !== "string" ? tab.iconLeft : undefined;
				const iconRight = typeof tab !== "string" ? tab.iconRight : undefined;
				const tabAccessibilityLabel =
					typeof tab !== "string"
						? tab.accessibilityLabel || tabLabel
						: tabLabel;
				const tabAccessibilityHint =
					typeof tab !== "string" ? tab.accessibilityHint : undefined;
				return (
					<Pressable
						key={tabKey}
						style={({ pressed }) => ({
							flex: 1,
							paddingVertical: 10,
							paddingHorizontal: 12,
							alignItems: "center",
							justifyContent: "center",
							flexDirection: "row",
							borderRadius: radius.md,
							opacity: pressed ? 0.7 : 1,
							gap: theme.spacing.xs,
						})}
						onPress={() => handlePress(tab)}
						android_ripple={{ color: theme.colors.overlay, borderless: true }}
						accessibilityRole="tab"
						accessibilityLabel={tabAccessibilityLabel}
						accessibilityHint={tabAccessibilityHint}
					>
						{iconLeft && (
							<Ionicons
								name={iconLeft as any}
								size={theme.sizes.iconSm}
								color={
									isSelected ? theme.colors.primary : theme.colors.textSecondary
								}
							/>
						)}
						<Text variant="sm" color={isSelected ? "primary" : "textSecondary"}>
							{tabLabel}
						</Text>
						{iconRight && (
							<Ionicons
								name={iconRight as any}
								size={theme.sizes.iconSm}
								color={
									isSelected ? theme.colors.primary : theme.colors.textSecondary
								}
							/>
						)}
					</Pressable>
				);
			});
		}, [tabs, selectedTab, theme, labelRender]);
		return (
			<Box
				row
				bg="transparent"
				accessibilityRole="tablist"
				accessibilityLabel={accessibilityLabel || "Tab navigation"}
				accessibilityHint={accessibilityHint}
			>
				{renderedTabs}
			</Box>
		);
	},
	(prevProps, nextProps) => {
		if (prevProps.selectedTab !== nextProps.selectedTab) {
			return false;
		}
		if (prevProps.tabs.length !== nextProps.tabs.length) {
			return false;
		}
		for (let i = 0; i < prevProps.tabs.length; i++) {
			const prevTab = prevProps.tabs[i];
			const nextTab = nextProps.tabs[i];
			if (typeof prevTab !== typeof nextTab) {
				return false;
			}
			if (typeof prevTab === "string" && typeof nextTab === "string") {
				if (prevTab !== nextTab) {
					return false;
				}
			} else if (typeof prevTab === "object" && typeof nextTab === "object") {
				if (
					prevTab.key !== nextTab.key ||
					prevTab.label !== nextTab.label ||
					prevTab.iconLeft !== nextTab.iconLeft ||
					prevTab.iconRight !== nextTab.iconRight
				) {
					return false;
				}
			}
		}
		return true;
	},
);
</file>

<file path="apps/merchant-app/components/ui/Text.tsx">
import React from "react";
import {
	Text as RNText,
	TextProps as RNTextProps,
	StyleProp,
	TextStyle,
	AccessibilityRole,
} from "react-native";
import { useTheme } from "@/stores/themeStore";
interface TextProps extends RNTextProps {
	variant?: FontSizeVariant;
	weight?: FontWeightVariant;
	color?: ColorToken | string;
	center?: boolean;
	muted?: boolean;
	marginBottom?: SpacingToken | number;
	marginTop?: SpacingToken | number;
	marginStart?: SpacingToken | number;
	marginEnd?: SpacingToken | number;
	marginHorizontal?: SpacingToken | number;
	marginVertical?: SpacingToken | number;
	margin?: SpacingToken | number;
	paddingStart?: SpacingToken | number;
	paddingEnd?: SpacingToken | number;
	paddingHorizontal?: SpacingToken | number;
	paddingVertical?: SpacingToken | number;
	paddingTop?: SpacingToken | number;
	paddingBottom?: SpacingToken | number;
	padding?: SpacingToken | number;
	style?: StyleProp<TextStyle>;
	align?: TextStyle["textAlign"];
	accessibilityRole?: AccessibilityRole;
	accessibilityLabel?: string;
	accessibilityHint?: string;
	accessibilityState?: {
		disabled?: boolean;
		selected?: boolean;
		checked?: boolean | "mixed";
		busy?: boolean;
		expanded?: boolean;
	};
	fontFamily?: "sans" | "serif" | "mono";
}
export const Text: React.FC<TextProps> = React.memo(
	({
		children,
		variant = "md",
		weight = "regular",
		color,
		center,
		muted,
		marginBottom,
		marginTop,
		marginStart,
		marginEnd,
		marginHorizontal,
		marginVertical,
		margin,
		paddingStart,
		paddingEnd,
		paddingHorizontal,
		paddingVertical,
		paddingTop,
		paddingBottom,
		padding,
		style,
		align,
		accessibilityRole,
		accessibilityLabel,
		accessibilityHint,
		accessibilityState,
		fontFamily = "sans",
		...props
	}) => {
		const theme = useTheme();
		const getSpacingValue = (
			value: SpacingToken | number | undefined,
		): number | undefined => {
			if (value === undefined) return undefined;
			return typeof value === "number" ? value : theme.spacing[value];
		};
		const getColorValue = (
			colorProp: ColorToken | string | undefined,
		): string => {
			if (colorProp === undefined) {
				return muted ? theme.colors.textSecondary : theme.colors.text;
			}
			if (typeof colorProp === "string" && colorProp in theme.colors) {
				return theme.colors[colorProp as ColorToken] as string;
			}
			return colorProp;
		};
		const textAlign = center ? "center" : align;
		const textStyle: TextStyle = {
			fontSize: theme.typography.sizes[variant],
			fontWeight: theme.typography.weights[weight],
			color: getColorValue(color),
			textAlign,
			marginBottom: getSpacingValue(marginBottom),
			marginTop: getSpacingValue(marginTop),
			marginStart: getSpacingValue(marginStart),
			marginEnd: getSpacingValue(marginEnd),
			marginHorizontal: getSpacingValue(marginHorizontal),
			marginVertical: getSpacingValue(marginVertical),
			margin: getSpacingValue(margin),
			paddingStart: getSpacingValue(paddingStart),
			paddingEnd: getSpacingValue(paddingEnd),
			paddingHorizontal: getSpacingValue(paddingHorizontal),
			paddingVertical: getSpacingValue(paddingVertical),
			paddingTop: getSpacingValue(paddingTop),
			paddingBottom: getSpacingValue(paddingBottom),
			padding: getSpacingValue(padding),
		};
		return (
			<RNText
				style={[textStyle, style]}
				accessibilityRole={accessibilityRole}
				accessibilityLabel={accessibilityLabel}
				accessibilityHint={accessibilityHint}
				accessibilityState={accessibilityState}
				{...props}
			>
				{children}
			</RNText>
		);
	},
	(prevProps, nextProps) => {
		const equalChildren = prevProps.children === nextProps.children;
		const equalVariant = prevProps.variant === nextProps.variant;
		const equalWeight = prevProps.weight === nextProps.weight;
		const equalColor = prevProps.color === nextProps.color;
		return (
			equalChildren &&
			equalVariant &&
			equalWeight &&
			equalColor &&
			prevProps.numberOfLines === nextProps.numberOfLines &&
			prevProps.center === nextProps.center
		);
	},
);
</file>

<file path="apps/merchant-app/components/dashboard/AlertsCard.tsx">
import React from "react";
import { Pressable, View } from "react-native";
import Animated, {
	FadeInUp,
	FadeOutDown,
	useAnimatedStyle,
	useSharedValue,
	withTiming,
} from "react-native-reanimated";
import { Ionicons } from "@expo/vector-icons";
import { AnimatedBox, Box, Text } from "@/components/ui";
import { useTheme } from "@/stores/themeStore";
import { Alert } from "@/types";
import { useTranslation } from "@/stores/translationStore";
interface AlertsCardProps {
	alerts: Alert[];
	onViewAlert: (id: string | number) => void;
	onViewAllAlerts?: () => void;
}
export const AlertsCard = React.memo(
	({ alerts, onViewAlert, onViewAllAlerts }: AlertsCardProps) => {
		const theme = useTheme();
		const { t } = useTranslation();
		const hasAlerts = alerts.length > 0;
		return (
			<AnimatedBox
				entering={FadeInUp.delay(theme.animations.delay.staggered.medium)
					.duration(theme.animations.duration.extraSlow)
					.springify()
					.damping(theme.animations.spring.damping.light)}
				exiting={FadeOutDown.duration(theme.animations.duration.medium)}
				marginHorizontal="md"
				marginBottom="lg"
				style={{ overflow: "hidden" }}
			>
				<Box rounded="lg" elevation="small">
					<Box
						row
						justifyContent="space-between"
						alignItems="center"
						marginBottom="md"
						paddingTop="md"
					>
						<Text variant="lg" weight="semibold" fontFamily="serif">
							{t("dashboard.alerts")}
						</Text>
						{hasAlerts && (
							<Animated.View>
								<Pressable
									onPress={onViewAllAlerts}
									style={({ pressed }) => ({
										paddingVertical: theme.spacing.xs,
										borderRadius: theme.spacing.sm,
										backgroundColor: pressed
											? theme.colors.backgroundAlt
											: undefined,
										opacity: pressed ? 0.7 : 1,
									})}
								>
									<Text variant="sm" color="primary" weight="medium">
										{t("dashboard.viewAll")}
									</Text>
								</Pressable>
							</Animated.View>
						)}
					</Box>
					{hasAlerts ? (
						<Box>
							{alerts.map((alert, index) => (
								<AlertItem
									key={alert.id}
									alert={alert}
									onPress={() => onViewAlert(alert.id)}
									isLast={index === alerts.length - 1}
								/>
							))}
						</Box>
					) : (
						<Box
							alignCenter
							paddingVertical="lg"
							bg="backgroundAlt"
							style={{
								borderBottomLeftRadius: theme.radius.lg,
								borderBottomRightRadius: theme.radius.lg,
							}}
						>
							<Box
								rounded="round"
								bg="accentMint"
								padding="md"
								marginBottom="md"
								style={{
									width: theme.sizes.avatarLg,
									height: theme.sizes.avatarLg,
									alignItems: "center",
									justifyContent: "center",
								}}
							>
								<Ionicons
									name="checkmark-circle"
									size={theme.sizes.iconMd}
									color={theme.colors.text}
								/>
							</Box>
							<Text color="textSecondary" center fontFamily="serif">
								{t("dashboard.allCaughtUp")}
							</Text>
							<Text color="textMuted" variant="sm" center marginTop="xs">
								{t("dashboard.noAlerts")}
							</Text>
						</Box>
					)}
				</Box>
			</AnimatedBox>
		);
	},
);
interface AlertItemProps {
	alert: Alert;
	onPress: () => void;
	isLast?: boolean;
}
const AlertItem = React.memo(
	({ alert, onPress, isLast = false }: AlertItemProps) => {
		const theme = useTheme();
		const { isRTL } = useTranslation();
		const pressed = useSharedValue(0);
		const getAlertAccentColor = (type: string) => {
			switch (type) {
				case "warning":
					return theme.colors.accentPeach;
				case "info":
					return theme.colors.accentSky;
				case "error":
					return theme.colors.accentCoral;
				case "success":
					return theme.colors.accentMint;
				default:
					return theme.colors.accentSky;
			}
		};
		const iconColor = getAlertAccentColor(alert.type);
		const handlePressIn = () => {
			pressed.value = withTiming(1, {
				duration: theme.animations.duration.medium,
			});
		};
		const handlePressOut = () => {
			pressed.value = withTiming(0, {
				duration: theme.animations.duration.medium,
			});
		};
		const animatedStyle = useAnimatedStyle(() => {
			return {
				transform: [
					{
						scale: withTiming(
							pressed.value === 1 ? theme.animations.scale.pressed : 1,
							{
								duration:
									pressed.value === 1
										? theme.animations.duration.fast / 2
										: theme.animations.duration.medium,
							},
						),
					},
				],
				opacity: withTiming(
					pressed.value === 1 ? theme.animations.scale.pressedSmall : 1,
					{
						duration:
							pressed.value === 1
								? theme.animations.duration.fast / 2
								: theme.animations.duration.medium,
					},
				),
			};
		});
		return (
			<Animated.View
				style={[
					{
						borderBottomWidth: isLast ? 0 : 0.5,
						borderBottomColor: theme.colors.divider,
					},
					animatedStyle,
				]}
			>
				<Pressable
					onPress={onPress}
					onPressIn={handlePressIn}
					onPressOut={handlePressOut}
					style={{
						flexDirection: "row",
						alignItems: "center",
						paddingVertical: theme.spacing.md,
					}}
					android_ripple={{ color: theme.colors.overlay }}
				>
					<View
						style={{
							width: theme.sizes.buttonSm,
							height: theme.sizes.buttonSm,
							borderRadius: theme.radius.round,
							alignItems: "center",
							justifyContent: "center",
							backgroundColor: iconColor,
							marginStart: theme.spacing.sm,
						}}
					>
						<Ionicons
							name={alert.icon as any}
							size={theme.sizes.iconSm}
							color={theme.colors.text}
						/>
					</View>
					<Box
						flex={1}
						marginStart="sm"
						gap={theme.spacing.xs / 2}
						alignItems="flex-start"
					>
						<Text variant="sm" weight="medium" numberOfLines={1}>
							{alert.title}
						</Text>
						{alert.timestamp && (
							<Text variant="xs" color="textMuted">
								{alert.timestamp}
							</Text>
						)}
					</Box>
					<Ionicons
						name={isRTL ? "chevron-back" : "chevron-forward"}
						size={theme.sizes.iconSm}
						color={theme.colors.textMuted}
						style={{ marginStart: theme.spacing.sm }}
					/>
				</Pressable>
			</Animated.View>
		);
	},
);
</file>

<file path="apps/merchant-app/components/dashboard/StatsGrid.tsx">
import React from "react";
import { AnimatedBox, Box, Text } from "@/components/ui";
import { Ionicons } from "@expo/vector-icons";
import {
	FadeInUp,
	FadeOutDown,
	LinearTransition,
} from "react-native-reanimated";
import { useTheme } from "@/stores/themeStore";
import { Card } from "@/components/ui/Card";
interface StatItem {
	title: string;
	value: string | number;
	icon: string;
	variant?:
		| "sage"
		| "peach"
		| "lavender"
		| "coral"
		| "mint"
		| "cream"
		| "sky"
		| "rose";
}
interface StatsGridProps {
	stats: StatItem[];
}
export const StatsGrid = React.memo(({ stats }: StatsGridProps) => {
	const theme = useTheme();
	return (
		<Box row marginHorizontal="sm" marginBottom="lg" gap="sm">
			{stats.map((stat) => (
				<AnimatedBox
					key={stat.title}
					entering={FadeInUp.delay(theme.animations.delay.staggered.medium)
						.duration(theme.animations.duration.extraSlow)
						.springify()
						.damping(theme.animations.spring.damping.light)}
					exiting={FadeOutDown.duration(theme.animations.duration.medium)}
					layout={LinearTransition.duration(300)}
					flex={1}
				>
					<Card
						variant={stat.variant}
						padding="md"
						rounded="sm"
						elevation="small"
					>
						<Box row alignCenter marginBottom="sm" gap="sm">
							<Box
								width={theme.sizes.buttonSm}
								height={theme.sizes.buttonSm}
								rounded="sm"
								bg="primaryLight"
								alignItems="center"
								justifyContent="center"
							>
								<Ionicons
									name={stat.icon as any}
									size={theme.sizes.iconSm}
									color={theme.colors.primary}
								/>
							</Box>
							<Text variant="xs" weight="medium" color="textSecondary">
								{stat.title}
							</Text>
						</Box>
						<Text variant="xl" weight="bold" fontFamily="serif">
							{stat.value}
						</Text>
					</Card>
				</AnimatedBox>
			))}
		</Box>
	);
});
</file>

<file path="apps/merchant-app/app/index.tsx">
import { AlertsCard } from "@/components/dashboard/AlertsCard";
import { TodayPrepCard } from "@/components/dashboard/PrepCard";
import { StatsGrid } from "@/components/dashboard/StatsGrid";
import { AnimatedBox, Box } from "@/components/ui";
import { Tabs } from "@/components/ui/Tabs";
import { Text } from "@/components/ui/Text";
import { ALERTS, TODAY_PREP_SUMMARY } from "@/data";
import { useTheme } from "@/stores/themeStore";
import { useTranslation } from "@/stores/translationStore";
import * as Haptics from "expo-haptics";
import React, { useState, useCallback, useMemo } from "react";
import { FlatList, ScrollView, View } from "react-native";
import Animated, { FadeInUp, FadeOutDown } from "react-native-reanimated";
import { useSafeAreaInsets } from "react-native-safe-area-context";
const PREP_CARD_WIDTH = 200;
const HomeScreen = React.memo(() => {
	const theme = useTheme();
	const insets = useSafeAreaInsets();
	const { t, language } = useTranslation();
	const [selectedTab, setSelectedTab] = useState("Today");
	const tabItems = useMemo(() => {
		return ["Today", "Week", "Month"];
	}, [t]);
	const mapPeriodToVariant = (
		period: string,
	): "sage" | "peach" | "lavender" => {
		switch (period) {
			case "Breakfast":
				return "sage";
			case "Lunch":
				return "peach";
			case "Dinner":
				return "lavender";
			default:
				return "sage";
		}
	};
	const currentStats = useMemo(() => {
		switch (selectedTab) {
			case "Week":
				return [
					{
						title: t("dashboard.newThisWeek"),
						value: 52,
						icon: "people-outline",
						variant: "sky" as const,
					},
					{
						title: t("dashboard.newThisMonth"),
						value: "+3",
						icon: "add-circle-outline",
						variant: "mint" as const,
					},
				];
			case "Month":
				return [
					{
						title: t("dashboard.newThisWeek"),
						value: 52,
						icon: "people-outline",
						variant: "rose" as const,
					},
					{
						title: t("dashboard.newThisMonth"),
						value: "+12",
						icon: "add-circle-outline",
						variant: "cream" as const,
					},
				];
			default:
				return [
					{
						title: t("dashboard.newThisWeek"),
						value: 52,
						icon: "people-outline",
						variant: "lavender" as const,
					},
					{
						title: t("dashboard.newThisMonth"),
						value: "+12",
						icon: "add-circle-outline",
						variant: "peach" as const,
					},
				];
		}
	}, [selectedTab, t]);
	const currentDateString = useMemo(
		() =>
			new Date().toLocaleDateString(language, {
				weekday: "long",
				month: "short",
				day: "numeric",
			}),
		[language],
	);
	const handleSelectTab = useCallback(
		(tab: string) => {
			if (tab !== selectedTab) {
				Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
				setSelectedTab(tab);
			}
		},
		[selectedTab],
	);
	const handleViewSchedule = useCallback((period?: string) => {
		console.log("Navigate to Schedule Screen, Filter:", period || "Full");
	}, []);
	const handleViewAlert = useCallback((id: string | number) => {
		console.log("Navigate to Alert Details Screen, ID:", id);
	}, []);
	const handleViewAllAlerts = useCallback(() => {
		console.log("Navigate to All Alerts Screen");
	}, []);
	return (
		<View
			style={{
				flex: 1,
				backgroundColor: theme.colors.background,
				paddingTop: insets.top,
			}}
		>
			<ScrollView
				contentContainerStyle={{
					paddingBottom: theme.spacing.md,
					paddingHorizontal: theme.spacing.xs,
				}}
				showsVerticalScrollIndicator={false}
			>
				<Box
					row
					alignItems="center"
					paddingHorizontal="md"
					paddingVertical="sm"
					marginBottom="sm"
					style={{
						height: theme.sizes.headerHeight,
					}}
				>
					<Text variant="xl" weight="semibold" numberOfLines={1}>
						{currentDateString}
					</Text>
				</Box>
				<AnimatedBox
					marginHorizontal="sm"
					gap="md"
					entering={FadeInUp.delay(theme.animations.delay.staggered.medium)
						.duration(theme.animations.duration.extraSlow)
						.springify()
						.damping(theme.animations.spring.damping.light)}
					exiting={FadeOutDown.duration(theme.animations.duration.medium)}
				>
					<Box elevation="small" padding="xs">
						<Tabs
							tabs={tabItems}
							selectedTab={selectedTab}
							onSelectTab={handleSelectTab}
							labelRender={(tab) => t(`dashboard.${tab.toLowerCase()}`)}
						/>
					</Box>
					<StatsGrid stats={currentStats} key={selectedTab} />
				</AnimatedBox>
				<Animated.Text
					entering={FadeInUp.duration(400)}
					style={{
						fontSize: theme.typography.sizes.lg,
						fontWeight: theme.typography.weights.medium,
						color: theme.colors.text,
						marginHorizontal: theme.spacing.md,
						marginVertical: theme.spacing.sm,
						alignSelf: "flex-start",
						letterSpacing: 0.5,
					}}
				>
					{t("dashboard.todaysPrep")}
				</Animated.Text>
				<Animated.View
					entering={FadeInUp.delay(theme.animations.delay.staggered.medium)
						.duration(theme.animations.duration.extraSlow)
						.springify()
						.damping(theme.animations.spring.damping.light)}
					exiting={FadeOutDown.duration(theme.animations.duration.medium)}
				>
					<FlatList
						horizontal
						data={TODAY_PREP_SUMMARY}
						keyExtractor={(item) => item.period}
						showsHorizontalScrollIndicator={false}
						contentContainerStyle={{
							paddingHorizontal: theme.spacing.md,
							paddingVertical: theme.spacing.sm,
							gap: theme.spacing.sm,
						}}
						snapToInterval={PREP_CARD_WIDTH + theme.spacing.sm}
						decelerationRate="fast"
						renderItem={({ item }) => (
							<TodayPrepCard
								summary={item}
								onPress={() => handleViewSchedule(item.period)}
								variant={mapPeriodToVariant(item.period)}
							/>
						)}
					/>
				</Animated.View>
				<AlertsCard
					alerts={ALERTS}
					onViewAlert={handleViewAlert}
					onViewAllAlerts={handleViewAllAlerts}
				/>
			</ScrollView>
		</View>
	);
});
export default HomeScreen;
</file>

</files>
