This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/*.log, tmp/, **/Illustrations/**, **/*.json, **/Localization.ts, **/SVGS/**, **/generated/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
apps/
  merchant-app/
    app/
      meals/
        _layout.tsx
        [meal-id].tsx
        index.tsx
      _layout.tsx
      index.tsx
      settings.tsx
    components/
      dashboard/
        AlertRow.tsx
        AlertsCard.tsx
        DashboardHeader.tsx
        PrepCard.tsx
        StatsGrid.tsx
      fields/
        FocusableInput.tsx
      layout/
        ScreenContainer.tsx
      ui/
        Avatar.tsx
        Badge.tsx
        Box.tsx
        Button.tsx
        Card.tsx
        index.ts
        Tabs.tsx
        Text.tsx
      LanguageSelector.tsx
    constants/
      i18n.ts
      theme.ts
    hooks/
      useColorScheme/
        index.ts
        useColorScheme.web.ts
      useLanguage.ts
      useTheme.ts
      useTranslation.ts
    .gitignore
    data.ts
    types.ts
.gitignore
.npmrc
.nvimrc
pnpm-workspace.yaml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="apps/merchant-app/components/fields/FocusableInput.tsx">
import React, {
	useState,
	useEffect,
	useImperativeHandle,
	forwardRef,
} from "react";
import {
	TextInput,
	StyleProp,
	TextStyle,
	KeyboardTypeOptions,
	ReturnKeyTypeOptions,
	Platform,
	NativeSyntheticEvent,
	TextInputFocusEventData,
	TouchableWithoutFeedback,
} from "react-native";
import Animated, {
	useAnimatedStyle,
	useSharedValue,
	withTiming,
	interpolateColor,
} from "react-native-reanimated";
import * as Haptics from "expo-haptics";
import { useTheme } from "@/hooks/useTheme";
const AnimatedTextInput = Animated.createAnimatedComponent(TextInput);
export interface FocusableInputProps {
	inputRef?: React.RefObject<TextInput | null>;
	style?: StyleProp<TextStyle>;
	value?: string;
	onChangeText: (text: string) => void;
	placeholder?: string;
	placeholderTextColor?: string;
	returnKeyType?: ReturnKeyTypeOptions;
	onSubmitEditing?: () => void;
	multiline?: boolean;
	numberOfLines?: number;
	keyboardType?: KeyboardTypeOptions;
	textAlign?: "left" | "center" | "right";
	textAlignVertical?: "top" | "center" | "bottom";
	maxLength?: number;
	autoCapitalize?: "none" | "sentences" | "words" | "characters";
	autoCorrect?: boolean;
	editable?: boolean;
	secureTextEntry?: boolean;
	onFocus?: (e: NativeSyntheticEvent<TextInputFocusEventData>) => void;
	onBlur?: (e: NativeSyntheticEvent<TextInputFocusEventData>) => void;
}
const FocusableInput = forwardRef<TextInput, FocusableInputProps>(
	(
		{
			inputRef: externalInputRef,
			style,
			value,
			onChangeText,
			placeholder,
			placeholderTextColor,
			returnKeyType,
			onSubmitEditing,
			multiline = false,
			numberOfLines = 1,
			keyboardType = "default",
			textAlign,
			textAlignVertical,
			maxLength,
			autoCapitalize = "sentences",
			autoCorrect = true,
			editable = true,
			secureTextEntry = false,
			onFocus,
			onBlur,
		},
		ref,
	) => {
		const theme = useTheme();
		const [isFocused, setIsFocused] = useState(false);
		const internalInputRef = React.useRef<TextInput>(null);
		useImperativeHandle(
			ref,
			() => {
				if (internalInputRef.current) {
					return internalInputRef.current;
				}
				return new TextInput({}) as TextInput;
			},
			[],
		);
		const inputRefToUse = externalInputRef || internalInputRef;
		const focusProgress = useSharedValue(0);
		useEffect(() => {
			focusProgress.value = withTiming(isFocused ? 1 : 0, {
				duration: 200,
			});
			if (isFocused) {
				if (Platform.OS !== "android") {
					Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light).catch(
						() => {},
					);
				}
			}
		}, [isFocused]);
		const containerAnimatedStyle = useAnimatedStyle(() => {
			return {
				marginBottom: multiline ? theme.spacing.sm : 0,
				borderRadius: theme.radius.input,
				shadowColor: theme.colors.primary,
				shadowOffset: { width: 0, height: 0 },
				shadowOpacity: focusProgress.value * 0.15,
				shadowRadius: 3,
				elevation: focusProgress.value * 2,
			};
		});
		const inputAnimatedStyle = useAnimatedStyle(() => {
			const borderColor = interpolateColor(
				focusProgress.value,
				[0, 1],
				[theme.colors.divider, theme.colors.primary],
			);
			return {
				borderColor,
				borderWidth: 1,
				paddingHorizontal: theme.spacing.md,
				paddingVertical: multiline ? theme.spacing.sm : 0,
				color: editable ? theme.colors.text : theme.colors.textSecondary,
				backgroundColor: theme.colors.card,
				borderRadius: theme.radius.input,
				height: multiline ? undefined : theme.sizes.inputHeight,
				minHeight: multiline
					? theme.sizes.inputHeight * (numberOfLines || 1)
					: undefined,
				textAlign,
				textAlignVertical,
				opacity: editable ? 1 : 0.8,
				...(style as any),
			};
		});
		const focusInput = () => {
			if (inputRefToUse.current && editable) {
				inputRefToUse.current.focus();
			}
		};
		const handleFocus = (e: NativeSyntheticEvent<TextInputFocusEventData>) => {
			setIsFocused(true);
			if (onFocus) {
				onFocus(e);
			}
		};
		const handleBlur = (e: NativeSyntheticEvent<TextInputFocusEventData>) => {
			setIsFocused(false);
			if (onBlur) {
				onBlur(e);
			}
		};
		return (
			<TouchableWithoutFeedback onPress={focusInput}>
				<Animated.View style={containerAnimatedStyle}>
					<AnimatedTextInput
						ref={inputRefToUse}
						style={inputAnimatedStyle}
						value={value}
						onChangeText={onChangeText}
						placeholder={placeholder}
						placeholderTextColor={placeholderTextColor}
						returnKeyType={returnKeyType}
						onSubmitEditing={onSubmitEditing}
						onFocus={handleFocus}
						onBlur={handleBlur}
						multiline={multiline}
						numberOfLines={numberOfLines}
						keyboardType={keyboardType}
						selectionColor={theme.colors.primary}
						maxLength={maxLength}
						autoCapitalize={autoCapitalize}
						autoCorrect={autoCorrect}
						editable={editable}
						secureTextEntry={secureTextEntry}
					/>
				</Animated.View>
			</TouchableWithoutFeedback>
		);
	},
);
export default FocusableInput;
</file>

<file path="apps/merchant-app/app/meals/_layout.tsx">
import { Stack } from "expo-router";
export default function MealsLayout() {
	return (
		<Stack screenOptions={{ headerShown: false }}>
			<Stack.Screen name="index" />
			<Stack.Screen name="[meal-id]" />
		</Stack>
	);
}
</file>

<file path="apps/merchant-app/app/meals/[meal-id].tsx">
import { AnimatedBox, Badge, Box, Button, Text } from "@/components/ui";
import FocusableInput from "@/components/fields/FocusableInput";
import { MEALS } from "@/data";
import { useTheme } from "@/hooks/useTheme";
import { useTranslation } from "@/hooks/useTranslation";
import { Meal } from "@/types";
import { Ionicons } from "@expo/vector-icons";
import * as Haptics from "expo-haptics";
import { Stack, useLocalSearchParams, useRouter } from "expo-router";
import React, { useState, useEffect, useRef } from "react";
import {
	Alert,
	Image,
	Keyboard,
	KeyboardAvoidingView,
	Platform,
	ScrollView,
	Switch,
	TextInput,
	View,
} from "react-native";
import Animated, {
	FadeIn,
	FadeInRight,
	FadeInUp,
} from "react-native-reanimated";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { Tabs, TabType } from "@/components/ui/Tabs";
const MealFormScreen = () => {
	const { "meal-id": mealId } = useLocalSearchParams<{ "meal-id": string }>();
	const theme = useTheme();
	const { t, language, isRTL } = useTranslation();
	const sectionTabs: TabType[] = [
		{
			key: "basic",
			label: t("meals.basicInfo"),
			iconLeft: "information-circle-outline",
		},
		{
			key: "settings",
			label: t("common.settings"),
			iconLeft: "settings-outline",
		},
	];
	const insets = useSafeAreaInsets();
	const router = useRouter();
	const isArabic = language === "ar";
	const isEdit = mealId !== "new";
	const [activeSection, setActiveSection] = useState<string>("basic");
	const [loading, setLoading] = useState(false);
	const nameInputRef = useRef<TextInput>(null);
	const nameArInputRef = useRef<TextInput>(null);
	const descInputRef = useRef<TextInput>(null);
	const descArInputRef = useRef<TextInput>(null);
	const priceInputRef = useRef<TextInput>(null);
	const caloriesInputRef = useRef<TextInput>(null);
	const prepTimeInputRef = useRef<TextInput>(null);
	const ingredientsInputRef = useRef<TextInput>(null);
	const ingredientsArInputRef = useRef<TextInput>(null);
	const [meal, setMeal] = useState<Partial<Meal>>({
		id: "",
		name: "",
		name_ar: "",
		description: "",
		description_ar: "",
		price: 0,
		ingredients: [],
		ingredients_ar: [],
		calories: 0,
		prepTime: 0,
		period: "Breakfast",
		available: true,
		image: "",
	});
	useEffect(() => {
		if (isEdit) {
			const existingMeal = MEALS.find((m) => m.id === mealId);
			if (existingMeal) setMeal(existingMeal);
		} else {
			setMeal((prev) => ({ ...prev, id: `meal-${Date.now()}` }));
		}
	}, [mealId, isEdit]);
	// Add an effect to auto-focus the first field after initial load
	useEffect(() => {
		// Wait for component to mount before attempting to focus
		const timer = setTimeout(() => {
			if (!isEdit && nameInputRef.current) {
				nameInputRef.current.focus();
			}
		}, 300);
		return () => clearTimeout(timer);
	}, [isEdit]);
	const handleSave = () => {
		Keyboard.dismiss();
		Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
		setLoading(true);
		setTimeout(() => {
			setLoading(false);
			router.back();
		}, 1000);
	};
	// Handle enter key press to advance to next field
	const handleSubmitEditing = (
		nextInput: React.RefObject<TextInput | null>,
	) => {
		if (nextInput?.current) {
			setTimeout(() => {
				nextInput.current?.focus();
			}, 50); // Small delay to ensure proper focus sequence
		} else {
			Keyboard.dismiss();
		}
	};
	const handleDelete = () => {
		Alert.alert(t("meals.confirmDelete"), "", [
			{ text: t("common.cancel"), style: "cancel" },
			{
				text: t("common.delete"),
				style: "destructive",
				onPress: () => {
					Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);
					setTimeout(() => router.back(), 500);
				},
			},
		]);
	};
	const updateField = (field: keyof Meal, value: any) => {
		setMeal((prev) => ({ ...prev, [field]: value }));
	};
	const periods = ["Breakfast", "Lunch", "Dinner"];
	return (
		<KeyboardAvoidingView
			style={{ flex: 1 }}
			behavior={Platform.OS === "ios" ? "padding" : "height"}
			keyboardVerticalOffset={Platform.OS === "ios" ? 0 : 0}
		>
			<View
				style={{
					flex: 1,
					backgroundColor: theme.colors.background,
					paddingTop: insets.top,
				}}
			>
				<Stack.Screen options={{ headerShown: false }} />
				{}
				<AnimatedBox
					row
					alignItems="center"
					justifyContent="space-between"
					paddingHorizontal="md"
					paddingVertical="sm"
					style={{
						height: theme.sizes.headerHeight,
						borderBottomWidth: 1,
						borderBottomColor: theme.colors.divider,
					}}
					entering={FadeIn.duration(300)}
				>
					<Box row alignItems="center">
						<Button
							title=""
							variant="ghost"
							leftIcon={isRTL ? "chevron-forward" : "chevron-back"}
							size="sm"
							onPress={() => router.back()}
							style={{ marginEnd: theme.spacing.sm }}
						/>
						<Text variant="xl" weight="semibold" numberOfLines={1}>
							{isEdit
								? isArabic && meal.name_ar
									? meal.name_ar
									: meal.name
								: t("meals.addNew")}
						</Text>
						{isEdit && (
							<Badge
								text={t(
									meal.available ? "meals.available" : "meals.unavailable",
								)}
								variant={meal.available ? "success" : "warning"}
								size="sm"
								style={{ marginStart: theme.spacing.sm }}
							/>
						)}
					</Box>
					{isEdit && (
						<Button
							title=""
							variant="ghost"
							leftIcon="trash-outline"
							size="sm"
							onPress={handleDelete}
							textColor={theme.colors.error}
						/>
					)}
				</AnimatedBox>
				<ScrollView
					style={{ flex: 1 }}
					contentContainerStyle={{
						padding: theme.spacing.md,
						paddingBottom: insets.bottom + theme.spacing.xxl,
					}}
					showsVerticalScrollIndicator={false}
					keyboardShouldPersistTaps="handled"
				>
					{}
					<AnimatedBox
						entering={FadeInUp.delay(100).duration(400)}
						marginBottom="md"
						style={{
							borderRadius: theme.radius.lg,
							overflow: "hidden",
							height: 240,
						}}
					>
						{meal.image ? (
							<Box
								style={{ height: "100%", width: "100%", position: "relative" }}
							>
								<Image
									source={{ uri: meal.image }}
									style={{ width: "100%", height: "100%" }}
									resizeMode="cover"
								/>
								<Box
									style={{
										position: "absolute",
										bottom: 0,
										left: 0,
										right: 0,
										height: 80,
										backgroundColor: "rgba(0,0,0,0.3)",
										padding: theme.spacing.md,
										justifyContent: "flex-end",
									}}
								>
									<Text
										variant="lg"
										weight="semibold"
										color="#fff"
										numberOfLines={1}
									>
										{isArabic && meal.name_ar
											? meal.name_ar
											: meal.name || t("meals.mealName")}
									</Text>
									<Box row alignItems="center" marginTop="xs">
										<Ionicons
											name="flame-outline"
											size={theme.sizes.iconSm}
											color="#fff"
											style={{ marginEnd: theme.spacing.xs }}
										/>
										<Text variant="sm" color="#fff">
											{meal.calories ? `${meal.calories} cal` : "0 cal"}
										</Text>
										<Text
											variant="sm"
											color="#fff"
											style={{ marginHorizontal: theme.spacing.xs }}
										>
											•
										</Text>
										<Ionicons
											name="time-outline"
											size={theme.sizes.iconSm}
											color="#fff"
											style={{ marginEnd: theme.spacing.xs }}
										/>
										<Text variant="sm" color="#fff">
											{meal.prepTime ? `${meal.prepTime} min` : "0 min"}
										</Text>
									</Box>
								</Box>
								<Box
									style={{
										position: "absolute",
										top: theme.spacing.sm,
										right: theme.spacing.sm,
										backgroundColor: "rgba(0,0,0,0.5)",
										borderRadius: theme.radius.round,
										padding: theme.spacing.xs,
									}}
								>
									<Ionicons
										name="camera-outline"
										size={theme.sizes.iconMd}
										color="#fff"
									/>
								</Box>
							</Box>
						) : (
							<Box
								style={{
									height: "100%",
									width: "100%",
									backgroundColor: theme.colors.cardAlt,
									alignItems: "center",
									justifyContent: "center",
								}}
							>
								<Ionicons
									name="camera-outline"
									size={theme.sizes.iconLg}
									color={theme.colors.primary}
									style={{ marginBottom: theme.spacing.sm }}
								/>
								<Text variant="md" weight="semibold" color="primary">
									{t("meals.addImage")}
								</Text>
							</Box>
						)}
					</AnimatedBox>
					{}
					<AnimatedBox
						entering={FadeInUp.delay(200).duration(400)}
						bg="backgroundAlt"
						rounded="lg"
						marginBottom="md"
					>
						<Tabs
							tabs={sectionTabs}
							selectedTab={activeSection}
							onSelectTab={setActiveSection}
							theme={theme}
						/>
					</AnimatedBox>
					{}
					{activeSection === "basic" && (
						<Animated.View
							entering={FadeInRight.delay(100).duration(100)}
							key={activeSection}
							style={{ gap: theme.spacing.md }}
						>
							{}
							<Box card rounded="md" padding="lg" elevation="small">
								<Box row alignItems="center" marginBottom="md">
									<Ionicons
										name="information-circle-outline"
										size={theme.sizes.iconSm}
										color={theme.colors.primary}
										style={{ marginEnd: theme.spacing.sm }}
									/>
									<Text variant="lg" weight="semibold">
										{t("meals.basicInfo")}
									</Text>
								</Box>
								{}
								<Box marginBottom="md">
									<Text
										variant="sm"
										weight="semibold"
										color="textSecondary"
										marginBottom="xs"
									>
										{t("meals.mealName")}
									</Text>
									<FocusableInput
										inputRef={nameInputRef}
										value={meal.name}
										onChangeText={(text) => updateField("name", text)}
										placeholder={t("meals.mealName")}
										placeholderTextColor={theme.colors.textMuted}
										returnKeyType="next"
										onSubmitEditing={() => handleSubmitEditing(nameArInputRef)}
										style={{ marginBottom: theme.spacing.sm }}
									/>
									<FocusableInput
										inputRef={nameArInputRef}
										value={meal.name_ar}
										onChangeText={(text) => updateField("name_ar", text)}
										placeholder={`${t("meals.mealName")} (العربية)`}
										placeholderTextColor={theme.colors.textMuted}
										returnKeyType="next"
										onSubmitEditing={() => handleSubmitEditing(descInputRef)}
										textAlign={isArabic ? "right" : "left"}
									/>
								</Box>
								{}
								<Box marginBottom="md">
									<Text
										variant="sm"
										weight="semibold"
										color="textSecondary"
										marginBottom="xs"
									>
										{t("meals.description")}
									</Text>
									<FocusableInput
										inputRef={descInputRef}
										value={meal.description}
										onChangeText={(text) => updateField("description", text)}
										placeholder={t("meals.description")}
										placeholderTextColor={theme.colors.textMuted}
										multiline={true}
										numberOfLines={4}
										returnKeyType="next"
										onSubmitEditing={() => handleSubmitEditing(descArInputRef)}
										textAlignVertical="top"
										style={{ marginBottom: theme.spacing.sm }}
									/>
									<FocusableInput
										inputRef={descArInputRef}
										value={meal.description_ar}
										onChangeText={(text) => updateField("description_ar", text)}
										placeholder={`${t("meals.description")} (العربية)`}
										placeholderTextColor={theme.colors.textMuted}
										multiline={true}
										numberOfLines={4}
										returnKeyType="done"
										textAlign={isArabic ? "right" : "left"}
										textAlignVertical="top"
									/>
								</Box>
								{}
								<Box marginBottom="md">
									<Text
										variant="sm"
										weight="semibold"
										color="textSecondary"
										marginBottom="xs"
									>
										{t("meals.mealPeriod")}
									</Text>
									<Box row bg="backgroundAlt" rounded="md" padding="xs">
										{periods.map((period) => (
											<Box
												key={period}
												flex={1}
												alignItems="center"
												justifyContent="center"
												bg={meal.period === period ? "card" : undefined}
												rounded="sm"
												style={{
													margin: 2,
													paddingVertical: theme.spacing.sm,
													...(meal.period === period
														? theme.shadows.small
														: {}),
													shadowColor: theme.colors.shadow,
												}}
												onPress={() => {
													Haptics.impactAsync(
														Haptics.ImpactFeedbackStyle.Light,
													);
													updateField("period", period);
												}}
											>
												<Ionicons
													name={
														period === "Breakfast"
															? "cafe-outline"
															: period === "Lunch"
																? "restaurant-outline"
																: "fast-food-outline"
													}
													size={theme.sizes.iconSm}
													color={
														meal.period === period
															? theme.colors.primary
															: theme.colors.textSecondary
													}
													style={{ marginBottom: theme.spacing.xs }}
												/>
												<Text
													variant="sm"
													weight={
														meal.period === period ? "semibold" : "medium"
													}
													color={
														meal.period === period ? "primary" : "textSecondary"
													}
												>
													{t(`periods.${period.toLowerCase()}`)}
												</Text>
											</Box>
										))}
									</Box>
								</Box>
							</Box>
							{}
							<Box card rounded="md" padding="lg" elevation="small">
								<Box row alignItems="center" marginBottom="md">
									<Ionicons
										name="list-outline"
										size={theme.sizes.iconSm}
										color={theme.colors.primary}
										style={{ marginEnd: theme.spacing.sm }}
									/>
									<Text variant="lg" weight="semibold">
										{t("meals.details")}
									</Text>
								</Box>
								{}
								<Box row gap="md" marginBottom="md">
									{}
									<Box flex={1}>
										<Text
											variant="sm"
											weight="semibold"
											color="textSecondary"
											marginBottom="xs"
										>
											{t("meals.price")}
										</Text>
										<Box
											style={{
												position: "relative",
												width: "100%",
											}}
										>
											<FocusableInput
												inputRef={priceInputRef}
												value={meal.price ? meal.price.toString() : ""}
												onChangeText={(text) => {
													const numValue = Number.parseFloat(text) || 0;
													updateField("price", numValue);
												}}
												placeholder="0.00"
												placeholderTextColor={theme.colors.textMuted}
												keyboardType="numeric"
												returnKeyType="next"
												onSubmitEditing={() =>
													handleSubmitEditing(caloriesInputRef)
												}
												style={{
													paddingLeft: 36,
													fontSize: theme.typography.sizes.lg,
													fontWeight: theme.typography.weights.semibold as any,
												}}
											/>
											<Box
												style={{
													position: "absolute",
													left: theme.spacing.md,
													top: 0,
													bottom: 0,
													justifyContent: "center",
													zIndex: 1,
												}}
											>
												<Text variant="md" color="textSecondary">
													$
												</Text>
											</Box>
										</Box>
									</Box>
									{}
									<Box flex={1}>
										<Text
											variant="sm"
											weight="semibold"
											color="textSecondary"
											marginBottom="xs"
										>
											{t("meals.calories")}
										</Text>
										<Box
											style={{
												position: "relative",
												width: "100%",
											}}
										>
											<FocusableInput
												inputRef={caloriesInputRef}
												value={meal.calories ? meal.calories.toString() : ""}
												onChangeText={(text) => {
													const numValue = Number.parseInt(text) || 0;
													updateField("calories", numValue);
												}}
												placeholder="0"
												placeholderTextColor={theme.colors.textMuted}
												keyboardType="numeric"
												returnKeyType="next"
												onSubmitEditing={() =>
													handleSubmitEditing(prepTimeInputRef)
												}
												style={{
													paddingRight: 40,
													fontSize: theme.typography.sizes.lg,
													fontWeight: theme.typography.weights.semibold as any,
												}}
											/>
											<Box
												style={{
													position: "absolute",
													right: theme.spacing.md,
													top: 0,
													bottom: 0,
													justifyContent: "center",
													zIndex: 1,
												}}
											>
												<Text variant="md" color="textSecondary">
													cal
												</Text>
											</Box>
										</Box>
									</Box>
								</Box>
								{}
								<Box marginBottom="md">
									<Text
										variant="sm"
										weight="semibold"
										color="textSecondary"
										marginBottom="xs"
									>
										{t("meals.prepTime")}
									</Text>
									<Box
										style={{
											position: "relative",
											maxWidth: "50%",
										}}
									>
										<FocusableInput
											inputRef={prepTimeInputRef}
											value={meal.prepTime ? meal.prepTime.toString() : ""}
											onChangeText={(text) => {
												const numValue = Number.parseInt(text) || 0;
												updateField("prepTime", numValue);
											}}
											placeholder="0"
											placeholderTextColor={theme.colors.textMuted}
											keyboardType="numeric"
											returnKeyType="next"
											onSubmitEditing={() =>
												handleSubmitEditing(ingredientsInputRef)
											}
											style={{
												paddingRight: 42,
												fontSize: theme.typography.sizes.lg,
												fontWeight: theme.typography.weights.semibold as any,
											}}
										/>
										<Box
											style={{
												position: "absolute",
												right: theme.spacing.md,
												top: 0,
												bottom: 0,
												justifyContent: "center",
												zIndex: 1,
											}}
										>
											<Text variant="md" color="textSecondary">
												min
											</Text>
										</Box>
									</Box>
								</Box>
								{}
								<Box marginBottom="md">
									<Text
										variant="sm"
										weight="semibold"
										color="textSecondary"
										marginBottom="xs"
									>
										{t("meals.ingredients")}
									</Text>
									<FocusableInput
										inputRef={ingredientsInputRef}
										value={meal.ingredients ? meal.ingredients.join(", ") : ""}
										onChangeText={(text) => {
											const ingredients = text
												.split(",")
												.map((item) => item.trim())
												.filter(Boolean);
											updateField("ingredients", ingredients);
										}}
										placeholder={t("meals.ingredients")}
										placeholderTextColor={theme.colors.textMuted}
										multiline={true}
										numberOfLines={2}
										returnKeyType="next"
										textAlignVertical="top"
										onSubmitEditing={() =>
											handleSubmitEditing(ingredientsArInputRef)
										}
										style={{ marginBottom: theme.spacing.sm }}
									/>
									<FocusableInput
										inputRef={ingredientsArInputRef}
										value={
											meal.ingredients_ar ? meal.ingredients_ar.join(", ") : ""
										}
										onChangeText={(text) => {
											const ingredients = text
												.split(",")
												.map((item) => item.trim())
												.filter(Boolean);
											updateField("ingredients_ar", ingredients);
										}}
										placeholder={`${t("meals.ingredients")} (العربية)`}
										placeholderTextColor={theme.colors.textMuted}
										multiline={true}
										numberOfLines={2}
										returnKeyType="done"
										textAlign={isArabic ? "right" : "left"}
										textAlignVertical="top"
										onSubmitEditing={() => Keyboard.dismiss()}
									/>
								</Box>
								{}
								{meal.ingredients && meal.ingredients.length > 0 && (
									<Box
										row
										gap="xs"
										marginTop="md"
										padding="md"
										bg="backgroundAlt"
										rounded="md"
										style={{ flexWrap: "wrap" }}
									>
										{meal.ingredients.map((ingredient, idx) => (
											<Badge
												key={`ing-${idx.toString()}`}
												text={ingredient}
												variant="info"
												size="sm"
											/>
										))}
									</Box>
								)}
							</Box>
						</Animated.View>
					)}
					{}
					{activeSection === "settings" && (
						<Animated.View
							entering={FadeInRight.delay(100).duration(100)}
							key={activeSection}
						>
							{}
							<Box
								card
								rounded="md"
								padding="lg"
								marginBottom="md"
								elevation="small"
							>
								<Box row alignItems="center" marginBottom="md">
									<Ionicons
										name="settings-outline"
										size={theme.sizes.iconSm}
										color={theme.colors.primary}
										style={{ marginEnd: theme.spacing.sm }}
									/>
									<Text variant="lg" weight="semibold">
										{t("common.settings")}
									</Text>
								</Box>
								<Box
									row
									justifyContent="space-between"
									alignItems="center"
									padding="md"
									bg="backgroundAlt"
									rounded="md"
									marginBottom="md"
								>
									<Box row alignItems="center">
										<Ionicons
											name={
												meal.available
													? "checkmark-circle-outline"
													: "close-circle-outline"
											}
											size={theme.sizes.iconMd}
											color={
												meal.available
													? theme.colors.success
													: theme.colors.error
											}
											style={{ marginEnd: theme.spacing.sm }}
										/>
										<Box>
											<Text variant="md" weight="semibold">
												{meal.available
													? t("meals.available")
													: t("meals.unavailable")}
											</Text>
											<Text variant="sm" color="textSecondary">
												{meal.available
													? t("meals.availableDesc")
													: t("meals.unavailableDesc")}
											</Text>
										</Box>
									</Box>
									<Switch
										value={meal.available}
										onValueChange={(value) => {
											Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
											updateField("available", value);
										}}
										trackColor={{
											false: theme.colors.backgroundAlt,
											true: theme.colors.primary,
										}}
										thumbColor={
											Platform.OS === "ios"
												? undefined
												: meal.available
													? theme.colors.background
													: theme.colors.card
										}
										ios_backgroundColor={theme.colors.backgroundAlt}
									/>
								</Box>
							</Box>
							{}
							{isEdit && (
								<Box
									bg="error"
									padding="md"
									rounded="md"
									marginBottom="md"
									style={{ opacity: 0.9 }}
								>
									<Box row alignItems="center" marginBottom="sm">
										<Ionicons
											name="warning-outline"
											size={theme.sizes.iconMd}
											color="#fff"
											style={{ marginEnd: theme.spacing.sm }}
										/>
										<Text variant="md" weight="semibold" color="#fff">
											{t("meals.dangerZone")}
										</Text>
									</Box>
									<Text variant="sm" color="#fff" marginBottom="md">
										{t("meals.deleteMealWarning")}
									</Text>
									<Button
										title={t("common.delete")}
										variant="outline"
										size="md"
										style={{ borderColor: "#fff" }}
										textColor="#fff"
										onPress={handleDelete}
									/>
								</Box>
							)}
						</Animated.View>
					)}
					{}
					<AnimatedBox
						entering={FadeInUp.delay(300).duration(400)}
						marginTop="lg"
					>
						<Button
							title={isEdit ? t("meals.saveChanges") : t("meals.createMeal")}
							variant="primary"
							size="lg"
							loading={loading}
							fullWidth
							rounded
							leftIcon="save-outline"
							onPress={handleSave}
						/>
						{!isEdit && (
							<Button
								title={t("common.cancel")}
								variant="ghost"
								size="lg"
								fullWidth
								style={{ marginTop: theme.spacing.md }}
								onPress={() => router.back()}
							/>
						)}
					</AnimatedBox>
				</ScrollView>
			</View>
		</KeyboardAvoidingView>
	);
};
export default MealFormScreen;
</file>

<file path="apps/merchant-app/app/meals/index.tsx">
import React, { useState, useCallback, useMemo } from "react";
import { FlatList, View, Image, Pressable } from "react-native";
import { Ionicons } from "@expo/vector-icons";
import Animated, {
	FadeIn,
	FadeInUp,
	LinearTransition,
} from "react-native-reanimated";
import * as Haptics from "expo-haptics";
import { AnimatedBox, Box, Card, Text } from "@/components/ui";
import { Tabs } from "@/components/ui/Tabs";
import { useTheme } from "@/hooks/useTheme";
import { useTranslation } from "@/hooks/useTranslation";
import { MEALS } from "@/data";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { Meal } from "@/types";
import { Link } from "expo-router";
const MealScreen = () => {
	const theme = useTheme();
	const { t } = useTranslation();
	const [selectedPeriod, setSelectedPeriod] = useState<string>("Breakfast");
	const insets = useSafeAreaInsets();
	const [meals] = useState<Meal[]>(MEALS);
	const periods = useMemo(() => ["Breakfast", "Lunch", "Dinner"], []);
	const filteredMeals = useMemo(() => {
		return meals.filter((meal) => meal.period === selectedPeriod);
	}, [meals, selectedPeriod]);
	const handleSelectPeriod = useCallback(
		(period: string) => {
			if (period !== selectedPeriod) {
				Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
				setSelectedPeriod(period);
			}
		},
		[selectedPeriod],
	);
	function renderEmptyList() {
		return (
			<View
				style={{
					flex: 1,
					alignItems: "center",
					justifyContent: "center",
					padding: theme.spacing.xl,
				}}
			>
				<Ionicons
					name="restaurant-outline"
					size={theme.sizes.iconLg}
					color={theme.colors.textMuted}
					style={{ marginBottom: theme.spacing.md }}
				/>
				<Text variant="lg" weight="semibold" color="textSecondary" center>
					{t("meals.noMeals")}
				</Text>
				<Text variant="md" color="textMuted" center marginTop="xs">
					{t("meals.addFirstMeal")}
				</Text>
			</View>
		);
	}
	return (
		<View
			style={{
				flex: 1,
				backgroundColor: theme.colors.background,
				paddingTop: insets.top,
			}}
		>
			<Box
				row
				alignItems="center"
				paddingHorizontal="md"
				paddingVertical="sm"
				style={{
					height: theme.sizes.headerHeight,
				}}
			>
				<Text variant="xl" weight="semibold" numberOfLines={1}>
					{t("meals.title")}
				</Text>
			</Box>
			<AnimatedBox
				marginHorizontal="md"
				gap="lg"
				entering={FadeInUp.delay(50).duration(400).springify().damping(15)}
			>
				<Tabs
					tabs={periods}
					selectedTab={selectedPeriod}
					onSelectTab={handleSelectPeriod}
					theme={theme}
					labelRender={(tab) => t(`periods.${tab.toLowerCase()}`)}
				/>
			</AnimatedBox>
			<Animated.View layout={LinearTransition.springify()} style={{ flex: 1 }}>
				{filteredMeals.length > 0 ? (
					<FlatList
						data={filteredMeals}
						keyExtractor={(item) => item.id}
						renderItem={({ item }) => <MealCard item={item} />}
						showsVerticalScrollIndicator={false}
						contentContainerStyle={{
							padding: theme.spacing.md,
							paddingBottom: theme.spacing.xxl,
						}}
					/>
				) : (
					renderEmptyList()
				)}
			</Animated.View>
		</View>
	);
};
const MealCard = (props: { item: Meal }) => {
	const { item } = props;
	const { language } = useTranslation();
	const theme = useTheme();
	const isArabic = language === "ar";
	return (
		<Animated.View
			layout={LinearTransition.springify().damping(15)}
			entering={FadeIn.duration(300)}
			style={{ marginBottom: theme.spacing.md }}
		>
			<Link asChild href={`/meals/${item.id}`}>
				<Pressable
					onPress={() => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light)}
					style={({ pressed }) => ({
						opacity: pressed ? 0.9 : 1,
						transform: [{ scale: pressed ? 0.98 : 1 }],
					})}
				>
					<Card padding="none" elevation="small">
						{item.image && (
							<Image
								source={{ uri: item.image }}
								style={{
									height: 140,
									width: "100%",
									borderTopLeftRadius: theme.radius.card,
									borderTopRightRadius: theme.radius.card,
								}}
								resizeMode="cover"
							/>
						)}
						<Box padding="md" gap={"sm"} alignItems="flex-start">
							<Text variant="lg" weight="semibold">
								{isArabic && item.name_ar ? item.name_ar : item.name}
							</Text>
							<Text
								variant="sm"
								color="textSecondary"
								marginBottom="md"
								numberOfLines={2}
							>
								{isArabic && item.description_ar
									? item.description_ar
									: item.description}
							</Text>
							<Box row marginBottom="sm">
								<Box row alignCenter>
									<Ionicons
										name="flame-outline"
										size={theme.sizes.iconSm}
										color={theme.colors.textSecondary}
										style={{ marginEnd: theme.spacing.xs }}
									/>
									<Text variant="sm" color="textSecondary">
										{item.calories} cal
									</Text>
								</Box>
							</Box>
						</Box>
					</Card>
				</Pressable>
			</Link>
		</Animated.View>
	);
};
export default MealScreen;
</file>

<file path="apps/merchant-app/hooks/useColorScheme/index.ts">
export { useColorScheme } from 'react-native';
</file>

<file path="apps/merchant-app/hooks/useColorScheme/useColorScheme.web.ts">
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);
  useEffect(() => {
    setHasHydrated(true);
  }, []);
  const colorScheme = useRNColorScheme();
  if (hasHydrated) {
    return colorScheme;
  }
  return 'light';
}
</file>

<file path=".npmrc">
node-linker=hoisted
engine-strict=true
</file>

<file path="apps/merchant-app/components/layout/ScreenContainer.tsx">
import { useTheme } from "@/hooks/useTheme";
import { Screen } from "expo-router/build/views/Screen";
import React from "react";
import {
	RefreshControlProps,
	ScrollView,
	StatusBar,
	StyleSheet,
	View,
} from "react-native";
import {
	SafeAreaView,
	useSafeAreaInsets,
} from "react-native-safe-area-context";
interface ScreenContainerProps {
	children: React.ReactNode;
	scrollable?: boolean;
	screenOptions?: any;
	header?: React.ReactNode;
	padded?: boolean;
	refreshControl?: React.ReactElement<RefreshControlProps>;
	contentContainerStyle?: any;
	bottomInset?: boolean;
}
export const ScreenContainer: React.FC<ScreenContainerProps> = ({
	children,
	scrollable = true,
	screenOptions = { headerShown: false },
	header,
	padded = true,
	refreshControl,
	contentContainerStyle,
	bottomInset = true,
}) => {
	const theme = useTheme();
	const insets = useSafeAreaInsets();
	const styles = StyleSheet.create({
		container: {
			flex: 1,
			backgroundColor: theme.colors.background,
		},
		content: {
			flex: 1,
			paddingHorizontal: padded ? theme.spacing.screenPadding : 0,
		},
		scrollContent: {
			flexGrow: 1,
			paddingBottom: bottomInset
				? insets.bottom || theme.spacing.xl
				: theme.spacing.xl,
		},
	});
	const Container = header ? View : SafeAreaView;
	return (
		<>
			<Screen options={screenOptions} />
			<StatusBar
				barStyle={theme.isDark ? "light-content" : "dark-content"}
				backgroundColor={theme.colors.background}
			/>
			<Container style={styles.container}>
				{header}
				{scrollable ? (
					<ScrollView
						style={styles.content}
						contentContainerStyle={[
							styles.scrollContent,
							contentContainerStyle,
						]}
						showsVerticalScrollIndicator={false}
						refreshControl={refreshControl}
						keyboardShouldPersistTaps="handled"
					>
						{children}
					</ScrollView>
				) : (
					<View style={styles.content}>{children}</View>
				)}
			</Container>
		</>
	);
};
</file>

<file path="apps/merchant-app/components/ui/Avatar.tsx">
import { ThemeTokens, useTheme } from "@/hooks/useTheme";
import React from "react";
import {
	Image,
	ImageSourcePropType,
	StyleSheet,
	View,
	ViewProps,
} from "react-native";
import { Text } from "./Text";
interface AvatarProps extends ViewProps {
	size?: "sm" | "md" | "lg" | number;
	source?: ImageSourcePropType;
	text?: string;
	color?: ThemeTokens["colors"];
	backgroundColor?: ThemeTokens["colors"];
}
export const Avatar: React.FC<AvatarProps> = ({
	size = "md",
	source,
	text,
	color,
	backgroundColor,
	style,
	...props
}) => {
	const theme = useTheme();
	const getSize = () => {
		if (typeof size === "number") return size;
		switch (size) {
			case "sm":
				return theme.sizes.avatarSm;
			case "md":
				return theme.sizes.avatarMd;
			case "lg":
				return theme.sizes.avatarLg;
			default:
				return theme.sizes.avatarMd;
		}
	};
	const getFontSize = () => {
		if (typeof size === "number") return size / 2;
		switch (size) {
			case "sm":
				return theme.typography.sizes.sm;
			case "md":
				return theme.typography.sizes.lg;
			case "lg":
				return theme.typography.sizes.xl;
			default:
				return theme.typography.sizes.lg;
		}
	};
	const avatarSize = getSize();
	const bgColor = backgroundColor
		? theme.colors[backgroundColor]
		: theme.colors.primaryLight;
	const textColor = color ? theme.colors[color] : theme.colors.primary;
	const styles = StyleSheet.create({
		container: {
			width: avatarSize,
			height: avatarSize,
			borderRadius: avatarSize / 2,
			backgroundColor: bgColor,
			alignItems: "center",
			justifyContent: "center",
			overflow: "hidden",
		},
		image: {
			width: avatarSize,
			height: avatarSize,
		},
		textStyle: {
			fontSize: getFontSize(),
			lineHeight: getFontSize() * 1.2,
		},
	});
	return (
		<View style={[styles.container, style]} {...props}>
			{source ? (
				<Image source={source} style={styles.image} resizeMode="cover" />
			) : (
				<Text weight="bold" color={textColor} style={styles.textStyle}>
					{text ? text.charAt(0).toUpperCase() : "?"}
				</Text>
			)}
		</View>
	);
};
</file>

<file path="apps/merchant-app/components/ui/Button.tsx">
import React from "react";
import {
	TouchableOpacity,
	TouchableOpacityProps,
	StyleSheet,
	StyleProp,
	ViewStyle,
	ActivityIndicator,
} from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { useTheme } from "@/hooks/useTheme";
import { Text } from "./Text";
interface ButtonProps extends TouchableOpacityProps {
	title: string;
	variant?: "primary" | "secondary" | "outline" | "ghost";
	size?: "sm" | "md" | "lg";
	leftIcon?: string;
	rightIcon?: string;
	loading?: boolean;
	rounded?: boolean;
	fullWidth?: boolean;
	style?: StyleProp<ViewStyle>;
	textColor?: string;
}
export const Button: React.FC<ButtonProps> = ({
	title,
	variant = "primary",
	size = "md",
	leftIcon,
	rightIcon,
	loading = false,
	rounded = false,
	fullWidth = false,
	style,
	textColor: textColorOverride,
	...props
}) => {
	const theme = useTheme();
	const getVariantStyles = () => {
		switch (variant) {
			case "primary":
				return {
					backgroundColor: theme.colors.primary,
					textColorToken: theme.colors.background,
				};
			case "secondary":
				return {
					backgroundColor: theme.colors.cardAlt,
					textColorToken: theme.colors.text,
				};
			case "outline":
				return {
					backgroundColor: "transparent",
					borderWidth: 1,
					borderColor: theme.colors.primary,
					textColorToken: theme.colors.primary,
				};
			case "ghost":
				return {
					backgroundColor: "transparent",
					textColorToken: theme.colors.primary,
				};
			default:
				return {
					backgroundColor: theme.colors.primary,
					textColorToken: theme.colors.background,
				};
		}
	};
	const getSizeStyles = () => {
		switch (size) {
			case "sm":
				return {
					height: theme.sizes.buttonSm,
					paddingHorizontal: theme.spacing.md,
					fontSize: "sm" as const,
					iconSize: theme.sizes.iconXs,
				};
			case "md":
				return {
					height: theme.sizes.buttonMd,
					paddingHorizontal: theme.spacing.md,
					fontSize: "md" as const,
					iconSize: theme.sizes.iconSm,
				};
			case "lg":
				return {
					height: theme.sizes.buttonLg,
					paddingHorizontal: theme.spacing.lg,
					fontSize: "md" as const,
					iconSize: theme.sizes.iconMd,
				};
			default:
				return {
					height: theme.sizes.buttonMd,
					paddingHorizontal: theme.spacing.md,
					fontSize: "md" as const,
					iconSize: theme.sizes.iconSm,
				};
		}
	};
	const variantStyle = getVariantStyles();
	const sizeStyle = getSizeStyles();
	const finalTextColor = textColorOverride || variantStyle.textColorToken;
	const styles = StyleSheet.create({
		button: {
			height: sizeStyle.height,
			paddingHorizontal: sizeStyle.paddingHorizontal,
			borderRadius: rounded ? theme.radius.round : theme.radius.button,
			backgroundColor: variantStyle.backgroundColor,
			borderWidth: variantStyle.borderWidth || 0,
			borderColor: variantStyle.borderColor,
			flexDirection: "row",
			alignItems: "center",
			justifyContent: "center",
			width: fullWidth ? "100%" : undefined,
		},
		icon: {
			marginRight: leftIcon && title ? theme.spacing.xs : 0,
			marginLeft: rightIcon && title ? theme.spacing.xs : 0,
		},
	});
	return (
		<TouchableOpacity
			style={[styles.button, style]}
			activeOpacity={0.7}
			disabled={loading || props.disabled}
			{...props}
		>
			{loading ? (
				<ActivityIndicator color={finalTextColor} size="small" />
			) : (
				<>
					{leftIcon && (
						<Ionicons
							name={leftIcon as any}
							size={sizeStyle.iconSize}
							color={finalTextColor}
							style={styles.icon}
						/>
					)}
					<Text
						variant={sizeStyle.fontSize}
						weight="semibold"
						color={finalTextColor}
					>
						{title}
					</Text>
					{rightIcon && (
						<Ionicons
							name={rightIcon as any}
							size={sizeStyle.iconSize}
							color={finalTextColor}
							style={styles.icon}
						/>
					)}
				</>
			)}
		</TouchableOpacity>
	);
};
</file>

<file path="apps/merchant-app/components/ui/Card.tsx">
import React from "react";
import {
	TouchableOpacity,
	StyleSheet,
	TouchableOpacityProps,
	StyleProp,
	ViewStyle,
	View,
} from "react-native";
import { RadiusToken, SpacingToken, useTheme } from "@/hooks/useTheme";
interface CardProps extends TouchableOpacityProps {
	elevation?: "none" | "small" | "medium" | "large";
	padding?: SpacingToken | number;
	rounded?: RadiusToken;
	style?: StyleProp<ViewStyle>;
	children?: React.ReactNode;
}
export const Card: React.FC<CardProps> = ({
	children,
	elevation = "small",
	padding = "md",
	rounded = "card",
	style,
	onPress,
	...props
}) => {
	const theme = useTheme();
	const getElevation = () => {
		if (elevation === "none") return {};
		const shadowStyle = theme.shadows[elevation];
		return { ...shadowStyle, shadowColor: theme.colors.shadow };
	};
	const getPaddingValue = () => {
		return typeof padding === "number" ? padding : theme.spacing[padding];
	};
	const getRadiusValue = () => {
		return theme.radius[rounded];
	};
	const styles = StyleSheet.create({
		card: {
			backgroundColor: theme.colors.card,
			borderRadius: getRadiusValue(),
			padding: getPaddingValue(),
			...getElevation(),
		},
	});
	const ContainerComponent = onPress ? TouchableOpacity : View;
	return (
		<ContainerComponent
			activeOpacity={onPress ? 0.7 : 1}
			style={[styles.card, style]}
			onPress={onPress}
			{...props}
		>
			{children}
		</ContainerComponent>
	);
};
</file>

<file path="apps/merchant-app/components/ui/index.ts">
export * from "./Box";
export * from "./Text";
export * from "./Button";
export * from "./Avatar";
export * from "./Card";
export * from "./Badge";
export * from "./Tabs";
</file>

<file path="apps/merchant-app/hooks/useLanguage.ts">
import { useState, useEffect } from "react";
import { I18nManager } from "react-native";
import { Language } from "@/constants/i18n";
const DEFAULT_LANGUAGE: Language = "ar";
export function useLanguage() {
	const [language, setLanguage] = useState<Language>(DEFAULT_LANGUAGE);
	useEffect(() => {
		const loadLanguage = async () => {
			const savedLanguage = DEFAULT_LANGUAGE;
			if (savedLanguage === "en" || savedLanguage === "ar") {
				setLanguage(savedLanguage);
				const shouldBeRTL = savedLanguage === "ar";
				if (shouldBeRTL !== I18nManager.isRTL) {
					I18nManager.forceRTL(shouldBeRTL);
				} else if (!shouldBeRTL && I18nManager.isRTL) {
					I18nManager.forceRTL(false);
				}
			}
		};
		loadLanguage();
	}, []);
	const changeLanguage = async (newLanguage: Language) => {
		try {
			setLanguage(newLanguage);
			const shouldBeRTL = newLanguage === "ar";
			if (shouldBeRTL !== I18nManager.isRTL) {
				I18nManager.allowRTL(shouldBeRTL);
				I18nManager.forceRTL(shouldBeRTL);
			}
		} catch (error) {
			console.error("Failed to save language setting:", error);
		}
	};
	return { language, changeLanguage };
}
</file>

<file path="apps/merchant-app/hooks/useTheme.ts">
import { useColorScheme } from "react-native";
import { theme, ThemeMode } from "@/constants/theme";
import { DarkTheme, DefaultTheme } from "@react-navigation/native";
export const useTheme = () => {
	const colorScheme = useColorScheme() || "light";
	const isDark = colorScheme === "dark";
	const mode: ThemeMode = isDark ? "dark" : "light";
	const navTheme = isDark ? DarkTheme : DefaultTheme;
	return {
		colors: theme.colors[mode],
		isDark,
		mode,
		spacing: theme.spacing,
		radius: theme.radius,
		sizes: theme.sizes,
		typography: theme.typography,
		shadows: theme.shadows,
		platform: theme.platform,
		navTheme: {
			...navTheme,
			colors: {
				...navTheme.colors,
				primary: theme.colors[mode].primary,
				background: theme.colors[mode].background,
				card: theme.colors[mode].card,
				text: theme.colors[mode].text,
				border: theme.colors[mode].divider,
				notification: theme.colors[mode].primary,
			},
		},
	};
};
export type AppTheme = ReturnType<typeof useTheme>;
export type SpacingToken = keyof AppTheme["spacing"];
export type RadiusToken = keyof AppTheme["radius"];
export type ColorToken = keyof AppTheme["colors"];
export type ThemeTokens = {
	spacing: SpacingToken;
	radius: RadiusToken;
	colors: ColorToken;
};
export type FontSizeVariant = keyof AppTheme["typography"]["sizes"];
export type FontWeightVariant = keyof AppTheme["typography"]["weights"];
</file>

<file path="apps/merchant-app/hooks/useTranslation.ts">
import { translations } from "@/constants/i18n";
import { useCallback } from "react";
import { useLanguage } from "./useLanguage";
import { I18nManager } from "react-native";
type TranslationsType = typeof translations.en;
type Primitive = string | number | boolean | null | undefined;
type Join<K, P> = K extends string | number
	? P extends string | number
		? `${K}${"" extends P ? "" : "."}${P}`
		: never
	: never;
type Paths<T, D extends number = 10> = [D] extends [never]
	? never
	: T extends Primitive
		? ""
		:
				| {
						[K in keyof T]: K extends string | number
							? K | Join<K, Paths<T[K], Prev[D]>>
							: never;
				  }[keyof T & (string | number)]
				| "";
type Prev = [never, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
export type TranslationPath = Paths<TranslationsType, 4>;
export function useTranslation() {
	const { language } = useLanguage();
	const isRTL = I18nManager.isRTL;
	const t = useCallback(
		(path: string, params?: Record<string, string | number>): string => {
			const keys = path.split(".");
			let translation: any = translations[language];
			for (const key of keys) {
				translation = translation?.[key];
				if (translation === undefined) {
					let fallback: any = translations.en;
					for (const k of keys) {
						fallback = fallback?.[k];
						if (fallback === undefined) break;
					}
					translation = fallback;
					break;
				}
			}
			if (typeof translation !== "string") {
				return path;
			}
			if (params) {
				return Object.entries(params).reduce(
					(result, [key, value]) => result.replace(`{{${key}}}`, String(value)),
					translation,
				);
			}
			return translation;
		},
		[language],
	);
	return { t, language, isRTL };
}
</file>

<file path="apps/merchant-app/types.ts">
export interface MealCount {
	name: string;
	count: number;
	id: string | number;
}
export interface MealPrepSummary {
	period: "Breakfast" | "Lunch" | "Dinner";
	totalMeals: number;
	mealsToPrep: MealCount[];
}
export interface Alert {
	id: string | number;
	type: "warning" | "info" | "error";
	title: string;
	icon: string;
	timestamp?: string;
}
export interface StatItem {
	title: string;
	value: string | number;
	icon: string;
}
export interface OverviewStats {
	activeSubscriptions: number;
	newThisWeek: number;
}
export interface QuickActionItem {
	label: string;
	icon: string;
	action: () => void;
}
export interface Meal {
	id: string;
	name: string;
	name_ar?: string;
	description: string;
	description_ar?: string;
	price: number;
	ingredients: string[];
	ingredients_ar?: string[];
	calories: number;
	prepTime: number;
	period: string;
	available: boolean;
	image?: string;
}
</file>

<file path="apps/merchant-app/components/ui/Badge.tsx">
import React from "react";
import { View, StyleSheet, ViewProps } from "react-native";
import { useTheme } from "@/hooks/useTheme";
import { Text } from "./Text";
export interface BadgeProps extends ViewProps {
	text: string | number;
	variant?: "primary" | "success" | "warning" | "info" | "error" | "default";
	size?: "sm" | "md";
}
export const Badge: React.FC<BadgeProps> = ({
	text,
	variant = "default",
	size = "md",
	style,
	...props
}) => {
	const theme = useTheme();
	const getBadgeStyles = () => {
		const base = {
			textColor: theme.colors.text,
			bgColor: theme.colors.backgroundAlt,
		};
		switch (variant) {
			case "primary":
				return {
					textColor: theme.colors.background,
					bgColor: theme.colors.primary,
				};
			case "success":
				return {
					textColor: theme.colors.background,
					bgColor: theme.colors.success,
				};
			case "warning":
				return { textColor: theme.colors.text, bgColor: theme.colors.warning };
			case "info":
				return {
					textColor: theme.colors.background,
					bgColor: theme.colors.info,
				};
			case "error":
				return {
					textColor: theme.colors.background,
					bgColor: theme.colors.error,
				};
			default:
				return base;
		}
	};
	const getSizeStyles = () => {
		switch (size) {
			case "sm":
				return {
					paddingHorizontal: theme.spacing.sm,
					paddingVertical: theme.spacing.xs / 2,
					fontSize: "xs" as const,
				};
			default:
				return {
					paddingHorizontal: theme.spacing.sm,
					paddingVertical: theme.spacing.xs / 2 + 1,
					fontSize: "sm" as const,
				};
		}
	};
	const badgeStyle = getBadgeStyles();
	const sizeStyle = getSizeStyles();
	const styles = StyleSheet.create({
		badge: {
			backgroundColor: badgeStyle.bgColor,
			paddingHorizontal: sizeStyle.paddingHorizontal,
			paddingVertical: sizeStyle.paddingVertical,
			borderRadius: theme.radius.badge,
			alignItems: "center",
			justifyContent: "center",
			alignSelf: "flex-start",
		},
	});
	return (
		<View style={[styles.badge, style]} {...props}>
			<Text
				variant={sizeStyle.fontSize}
				weight="medium"
				color={badgeStyle.textColor}
			>
				{text}
			</Text>
		</View>
	);
};
</file>

<file path="apps/merchant-app/components/LanguageSelector.tsx">
import { Text } from "@/components/ui/Text";
import { useLanguage } from "@/hooks/useLanguage";
import { useTheme } from "@/hooks/useTheme";
import { Ionicons } from "@expo/vector-icons";
import React, { memo, useCallback } from "react";
import { TouchableOpacity, View } from "react-native";
export const LanguageSelector: React.FC = memo(() => {
	const { language, changeLanguage } = useLanguage();
	const theme = useTheme();
	const handleLanguageChange = useCallback((newLanguage: "en" | "ar") => {
		changeLanguage(newLanguage);
	}, []);
	return (
		<View style={{ alignItems: "flex-start" }}>
			<View
				style={{
					flexDirection: "row",
					justifyContent: "space-between",
				}}
			>
				<TouchableOpacity
					style={{
						flex: 1,
						margin: theme.spacing.xs,
						padding: theme.spacing.sm,
						borderRadius: theme.radius.sm,
						borderWidth: 1,
						borderColor: theme.colors.primary,
						alignItems: "center",
						justifyContent: "center",
						backgroundColor:
							language === "en" ? theme.colors.primary : "transparent",
					}}
					onPress={() => handleLanguageChange("en")}
					accessible={true}
					accessibilityRole="button"
					accessibilityLabel="Switch to English"
				>
					<View
						style={{
							flexDirection: "row",
							alignItems: "center",
							justifyContent: "center",
						}}
					>
						<Ionicons
							name="globe-outline"
							size={theme.sizes.iconSm}
							color={
								language === "en"
									? theme.colors.background
									: theme.colors.primary
							}
							style={{ marginRight: theme.spacing.xs }}
						/>
						<Text
							variant="md"
							weight="medium"
							color={language === "en" ? "background" : "primary"}
						>
							English
						</Text>
					</View>
				</TouchableOpacity>
				<TouchableOpacity
					style={{
						flex: 1,
						margin: theme.spacing.xs,
						padding: theme.spacing.sm,
						borderRadius: theme.radius.sm,
						borderWidth: 1,
						borderColor: theme.colors.primary,
						alignItems: "center",
						justifyContent: "center",
						backgroundColor:
							language === "ar" ? theme.colors.primary : "transparent",
					}}
					onPress={() => handleLanguageChange("ar")}
					accessible={true}
					accessibilityRole="button"
					accessibilityLabel="Switch to Arabic"
				>
					<View
						style={{
							flexDirection: "row",
							alignItems: "center",
							justifyContent: "center",
						}}
					>
						<Ionicons
							name="globe-outline"
							size={theme.sizes.iconSm}
							color={
								language === "ar"
									? theme.colors.background
									: theme.colors.primary
							}
							style={{ marginRight: theme.spacing.xs }}
						/>
						<Text
							variant="md"
							weight="medium"
							color={language === "ar" ? "background" : "primary"}
						>
							العربية
						</Text>
					</View>
				</TouchableOpacity>
			</View>
		</View>
	);
});
</file>

<file path="apps/merchant-app/.gitignore">
# @generated expo-cli sync-2b81b286409207a5da26e14c78851eb30d8ccbdb
# The following patterns were generated by expo-cli

expo-env.d.ts
# @end expo-cli
</file>

<file path="apps/merchant-app/data.ts">
import { Alert, MealPrepSummary } from "./types";
export const TODAY_PREP_SUMMARY: MealPrepSummary[] = [
	{
		period: "Breakfast",
		totalMeals: 25,
		mealsToPrep: [
			{ id: "shashuka", name: "Shashuka", count: 15 },
			{ id: "oats", name: "Overnight Oats", count: 7 },
			{ id: "smoothie", name: "Green Smoothie", count: 3 },
		],
	},
	{
		period: "Lunch",
		totalMeals: 32,
		mealsToPrep: [
			{ id: "salad_x", name: "Quinoa Salad", count: 18 },
			{ id: "wrap_y", name: "Falafel Wrap", count: 10 },
			{ id: "soup_z", name: "Lentil Soup", count: 4 },
			{ id: "extra1", name: "Side Salad", count: 2 },
		],
	},
	{
		period: "Dinner",
		totalMeals: 28,
		mealsToPrep: [
			{ id: "salmon", name: "Grilled Salmon", count: 12 },
			{ id: "tofu_stirfry", name: "Tofu Stir-fry", count: 9 },
			{ id: "pasta_veg", name: "Veggie Pasta", count: 7 },
		],
	},
];
export const ALERTS: Alert[] = [
	{
		id: 1,
		type: "info",
		title: "New 'Keto Weekly' subscriber",
		icon: "person-add-outline",
		timestamp: "3h ago",
	},
	{
		id: 2,
		type: "warning",
		title: "Low inventory: Quinoa",
		icon: "cube-outline",
		timestamp: "1h ago",
	},
	{
		id: 3,
		type: "error",
		title: "Delivery issue Order #12345",
		icon: "car-sport-outline",
		timestamp: "Yesterday",
	},
];
export const MEALS = [
	{
		id: "b1",
		name: "Shakshuka",
		name_ar: "شكشوكة",
		description: "Eggs poached in spiced tomato sauce",
		description_ar: "بيض مطبوخ في صلصة طماطم متبلة",
		price: 12.99,
		ingredients: ["Eggs", "Tomatoes", "Bell Peppers", "Onions", "Spices"],
		ingredients_ar: ["بيض", "طماطم", "فلفل حلو", "بصل", "توابل"],
		calories: 380,
		prepTime: 25,
		period: "Breakfast",
		available: true,
		image:
			"https://images.unsplash.com/photo-1590412200988-a436970781fa?w=800&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8Mnx8c2hha3NodWthfGVufDB8fDB8fHww",
	},
	{
		id: "b2",
		name: "Overnight Oats",
		name_ar: "شوفان مبيت",
		description: "Oats soaked with yogurt and fruits",
		description_ar: "شوفان منقوع مع الزبادي والفواكه",
		price: 8.99,
		ingredients: ["Oats", "Yogurt", "Berries", "Honey", "Nuts"],
		ingredients_ar: ["شوفان", "زبادي", "توت", "عسل", "مكسرات"],
		calories: 320,
		prepTime: 10,
		period: "Breakfast",
		available: true,
		image:
			"https://images.unsplash.com/photo-1614961233913-a5113a4a34ed?w=800&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MTB8fG92ZXJuaWdodCUyMG9hdHN8ZW58MHx8MHx8fDA%3D",
	},
	{
		id: "l1",
		name: "Quinoa Salad",
		name_ar: "سلطة الكينوا",
		description: "Fresh salad with quinoa and vegetables",
		description_ar: "سلطة طازجة مع الكينوا والخضروات",
		price: 14.99,
		ingredients: ["Quinoa", "Cucumber", "Tomato", "Avocado", "Lemon Dressing"],
		ingredients_ar: ["كينوا", "خيار", "طماطم", "أفوكادو", "صلصة ليمون"],
		calories: 420,
		prepTime: 20,
		period: "Lunch",
		available: true,
		image:
			"https://images.unsplash.com/photo-1505253716362-afaea1d3d1af?w=800&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8NXx8cXVpbm9hJTIwc2FsYWR8ZW58MHx8MHx8fDA%3D",
	},
	{
		id: "l2",
		name: "Falafel Wrap",
		name_ar: "لفائف الفلافل",
		description: "Falafel with vegetables in a whole wheat wrap",
		description_ar: "فلافل مع الخضروات في خبز القمح الكامل",
		price: 10.99,
		ingredients: ["Falafel", "Lettuce", "Tomato", "Cucumber", "Tahini"],
		ingredients_ar: ["فلافل", "خس", "طماطم", "خيار", "طحينة"],
		calories: 480,
		prepTime: 15,
		period: "Lunch",
		available: true,
		image:
			"https://images.unsplash.com/photo-1565299624946-b28f40a0ae38?w=800&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8M3x8ZmFsYWZlbHxlbnwwfHwwfHx8MA%3D%3D",
	},
	{
		id: "d1",
		name: "Grilled Salmon",
		name_ar: "سلمون مشوي",
		description: "Fresh salmon with herbs and lemon",
		description_ar: "سلمون طازج مع الأعشاب والليمون",
		price: 18.99,
		ingredients: ["Salmon", "Lemon", "Herbs", "Olive Oil", "Garlic"],
		ingredients_ar: ["سلمون", "ليمون", "أعشاب", "زيت زيتون", "ثوم"],
		calories: 520,
		prepTime: 30,
		period: "Dinner",
		available: true,
		image:
			"https://images.unsplash.com/photo-1519708227418-c8fd9a32b7a2?w=800&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8Mnx8Z3JpbGxlZCUyMHNhbG1vbnxlbnwwfHwwfHx8MA%3D%3D",
	},
	{
		id: "d2",
		name: "Tofu Stir-fry",
		name_ar: "توفو مقلي",
		description: "Tofu and vegetables in a savory sauce",
		description_ar: "توفو وخضروات في صلصة لذيذة",
		price: 13.99,
		ingredients: ["Tofu", "Broccoli", "Carrots", "Bell Peppers", "Soy Sauce"],
		ingredients_ar: ["توفو", "بروكلي", "جزر", "فلفل حلو", "صلصة الصويا"],
		calories: 380,
		prepTime: 25,
		period: "Dinner",
		available: true,
		image:
			"https://images.unsplash.com/photo-1512003867696-6d5ce6835040?w=800&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8Mnx8dG9mdSUyMHN0aXIlMjBmcnl8ZW58MHx8MHx8fDA%3D",
	},
];
</file>

<file path=".nvimrc">
23.11.0
</file>

<file path="apps/merchant-app/app/settings.tsx">
import React, { useCallback } from "react";
import {
	TouchableOpacity,
	View,
	Appearance,
	ScrollView,
	Pressable,
} from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { Stack } from "expo-router";
import { useTheme } from "@/hooks/useTheme";
import { Text, Box, AnimatedBox, Avatar } from "@/components/ui";
import { useTranslation } from "@/hooks/useTranslation";
import { LanguageSelector } from "@/components/LanguageSelector";
import Animated, {
	FadeInUp,
	useAnimatedStyle,
	withTiming,
	LinearTransition,
} from "react-native-reanimated";
import * as Haptics from "expo-haptics";
import { useSafeAreaInsets } from "react-native-safe-area-context";
const AnimatedPressable = Animated.createAnimatedComponent(Pressable);
export default function SettingsScreen() {
	const theme = useTheme();
	const insets = useSafeAreaInsets();
	const { t } = useTranslation();
	const restaurantName = "The Gourmet Spot";
	const handleThemeChange = useCallback((newTheme: "light" | "dark") => {
		Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
		Appearance.setColorScheme(newTheme);
		console.log("Theme changed to:", newTheme);
	}, []);
	const ThemeOption = ({
		option,
	}: { option: { key: "light" | "dark"; icon: string; label: string } }) => {
		const isSelected = theme.mode === option.key;
		const animatedStyle = useAnimatedStyle(() => {
			return {
				backgroundColor: withTiming(
					isSelected ? theme.colors.primaryLight : theme.colors.backgroundAlt,
					{ duration: 200 },
				),
				borderColor: withTiming(
					isSelected ? theme.colors.primary : theme.colors.divider,
					{ duration: 200 },
				),
				transform: [
					{ scale: withTiming(isSelected ? 1.0 : 0.98, { duration: 150 }) },
				],
				opacity: withTiming(isSelected ? 1 : 0.8, { duration: 200 }),
			};
		});
		const iconColor = isSelected
			? theme.colors.primary
			: theme.colors.textSecondary;
		const textColor = isSelected
			? theme.colors.primary
			: theme.colors.textSecondary;
		return (
			<AnimatedPressable
				key={option.key}
				style={[
					{
						flex: 1,
						marginHorizontal: theme.spacing.xs,
						paddingVertical: theme.spacing.md,
						paddingHorizontal: theme.spacing.sm,
						borderRadius: theme.radius.lg,
						borderWidth: 2,
						alignItems: "center" as const,
						justifyContent: "center" as const,
						minHeight: theme.sizes.buttonLg * 1.8,
					},
					animatedStyle,
				]}
				onPress={() => handleThemeChange(option.key)}
				accessible={true}
				accessibilityRole="button"
				accessibilityLabel={`Set theme to ${option.label}`}
				accessibilityState={{ selected: isSelected }}
			>
				<Ionicons
					name={option.icon as any}
					size={theme.sizes.iconLg}
					color={iconColor}
					style={{ marginBottom: theme.spacing.sm }}
				/>
				<Text variant="sm" weight="semibold" color={textColor}>
					{option.label}
				</Text>
			</AnimatedPressable>
		);
	};
	const themeOptions = [
		{ key: "light", icon: "sunny-outline", label: t("settings.lightMode") },
		{ key: "dark", icon: "moon-outline", label: t("settings.darkMode") },
	] as const;
	const SettingsSection = ({
		title,
		icon,
		children,
		delay,
	}: {
		title: string;
		icon: any;
		children: React.ReactNode;
		delay: number;
	}) => (
		<AnimatedBox
			entering={FadeInUp.delay(delay).duration(500).springify().damping(18)}
			layout={LinearTransition.duration(300)}
			padding="lg"
			marginBottom="lg"
			bg="card"
			rounded="xl"
			style={{
				borderWidth: 1,
				borderColor: theme.colors.divider,
			}}
		>
			<Box row alignCenter marginBottom="md">
				<Ionicons
					name={icon}
					size={theme.sizes.iconSm}
					color={theme.colors.primary}
					style={{ marginEnd: theme.spacing.sm }}
				/>
				<Text variant="lg" weight="semibold" color="textSecondary">
					{title}
				</Text>
			</Box>
			{children}
		</AnimatedBox>
	);
	return (
		<View
			style={{
				flex: 1,
				backgroundColor: theme.colors.background,
				paddingTop: insets.top,
			}}
		>
			<Stack.Screen options={{ headerShown: false }} />
			<Box
				row
				alignItems="center"
				paddingHorizontal="md"
				paddingVertical="sm"
				style={{
					height: theme.sizes.headerHeight,
				}}
			>
				<Text variant="xl" weight="semibold" numberOfLines={1}>
					{t("common.settings")}
				</Text>
			</Box>
			<ScrollView
				contentContainerStyle={{
					paddingHorizontal: theme.spacing.md,
					paddingBottom: theme.spacing.md,
				}}
				showsVerticalScrollIndicator={false}
			>
				<AnimatedBox
					entering={FadeInUp.delay(100).duration(500).springify().damping(18)}
					row
					alignCenter
					bg="card"
					padding="md"
					rounded="xl"
					marginBottom="lg"
					style={{ borderWidth: 1, borderColor: theme.colors.divider }}
				>
					<Avatar
						text={restaurantName.charAt(0)}
						size="md"
						style={{ marginEnd: theme.spacing.md }}
					/>
					<Box alignItems="flex-start" flex={1}>
						<Text variant="sm" color="textSecondary">
							{t("settings.signedInAs") ?? "Signed in as"}
						</Text>
						<Text variant="lg" weight="semibold" numberOfLines={1}>
							{restaurantName}
						</Text>
					</Box>
					<Ionicons
						name="person-circle-outline"
						size={theme.sizes.iconLg}
						color={theme.colors.textMuted}
					/>
				</AnimatedBox>
				<SettingsSection
					title={t("settings.language")}
					icon="language-outline"
					delay={200}
				>
					<LanguageSelector />
				</SettingsSection>
				<SettingsSection
					title={t("settings.theme")}
					icon="color-palette-outline"
					delay={300}
				>
					<View
						style={{
							flexDirection: "row",
							marginHorizontal: -theme.spacing.xs,
						}}
					>
						{themeOptions.map((option) => (
							<ThemeOption key={option.key} option={option} />
						))}
					</View>
				</SettingsSection>
				<SettingsSection
					title={t("settings.appInfo")}
					icon="information-circle-outline"
					delay={400}
				>
					<Box row justifyContent="space-between" alignItems="center">
						<Text variant="md" weight="medium" color="textSecondary">
							{t("common.version")}
						</Text>
						<Text variant="md" weight="medium" color="textMuted">
							v1.0.0
						</Text>
					</Box>
				</SettingsSection>
				<AnimatedBox
					entering={FadeInUp.delay(500).duration(500).springify().damping(18)}
				>
					<TouchableOpacity
						style={{
							marginTop: theme.spacing.lg,
							padding: theme.spacing.md,
							borderRadius: theme.radius.lg,
							backgroundColor: theme.colors.cardAlt,
							borderWidth: 1,
							borderColor: theme.colors.error,
							flexDirection: "row",
							alignItems: "center",
							justifyContent: "center",
						}}
						onPress={() => {
							Haptics.notificationAsync(
								Haptics.NotificationFeedbackType.Warning,
							);
							console.log("Logout Pressed");
						}}
					>
						<Ionicons
							name="log-out-outline"
							size={theme.sizes.iconMd}
							color={theme.colors.error}
							style={{ marginEnd: theme.spacing.sm }}
						/>
						<Text variant="md" weight="semibold" color="error">
							{t("settings.logout")}
						</Text>
					</TouchableOpacity>
				</AnimatedBox>
			</ScrollView>
		</View>
	);
}
</file>

<file path="apps/merchant-app/components/dashboard/AlertRow.tsx">
import React from "react";
import { Pressable } from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { Box, Text } from "@/components/ui";
import { AppTheme } from "@/hooks/useTheme";
import { Alert } from "@/types";
interface AlertRowProps {
	alert: Alert;
	theme: AppTheme;
	onPress: () => void;
}
export const AlertRow: React.FC<AlertRowProps> = React.memo(
	({ alert, theme, onPress }) => {
		const iconColor = theme.colors[alert.type];
		return (
			<Pressable
				onPress={onPress}
				style={({ pressed }) => [
					{
						paddingHorizontal: theme.spacing.sm,
						flexDirection: "row",
						alignItems: "center",
						paddingVertical: theme.spacing.md,
						borderRadius: theme.radius.sm,
					},
					pressed && {
						backgroundColor: theme.colors.backgroundAlt,
					},
				]}
				android_ripple={{ color: theme.colors.overlay }}
			>
				<Ionicons
					name={alert.icon as any}
					size={theme.sizes.iconSm}
					color={iconColor}
					style={{
						marginStart: theme.spacing.md,
					}}
				/>
				<Box flex={1}>
					<Text variant="sm" numberOfLines={1}>
						{alert.title}
					</Text>
					{alert.timestamp && (
						<Text
							variant="xs"
							color="textMuted"
							marginTop={theme.spacing.xs / 2}
						>
							{alert.timestamp}
						</Text>
					)}
				</Box>
				<Ionicons
					name={"chevron-back"}
					size={theme.sizes.iconSm}
					color={theme.colors.textMuted}
				/>
			</Pressable>
		);
	},
);
</file>

<file path="apps/merchant-app/components/dashboard/AlertsCard.tsx">
import React from "react";
import { StyleSheet, Pressable, View } from "react-native";
import Animated, {
	FadeInUp,
	FadeOutDown,
	useAnimatedStyle,
	useSharedValue,
	withTiming,
} from "react-native-reanimated";
import { Ionicons } from "@expo/vector-icons";
import { AnimatedBox, Box, Text } from "@/components/ui";
import { AppTheme } from "@/hooks/useTheme";
import { Alert } from "@/types";
import { useTranslation } from "@/hooks/useTranslation";
interface AlertsCardProps {
	alerts: Alert[];
	theme: AppTheme;
	onViewAlert: (id: string | number) => void;
	onViewAllAlerts?: () => void;
}
export const AlertsCard: React.FC<AlertsCardProps> = React.memo(
	({ alerts, theme, onViewAlert, onViewAllAlerts }) => {
		const { t } = useTranslation();
		const hasAlerts = alerts.length > 0;
		return (
			<AnimatedBox
				entering={FadeInUp.delay(350).duration(400).springify().damping(15)}
				exiting={FadeOutDown.duration(200)}
				card
				rounded="sm"
				marginHorizontal="md"
				marginBottom="lg"
				elevation="small"
				style={{ overflow: "hidden" }}
			>
				<Box
					row
					justifyContent="space-between"
					alignItems="center"
					marginBottom="md"
					paddingHorizontal="md"
					paddingTop="md"
				>
					<Text variant="lg" weight="semibold">
						{t("dashboard.alerts")}
					</Text>
					{hasAlerts && (
						<Animated.View>
							<Pressable
								onPress={onViewAllAlerts}
								style={({ pressed }) => [
									{
										paddingVertical: theme.spacing.xs,
										paddingHorizontal: theme.spacing.sm,
										borderRadius: theme.radius.sm,
										backgroundColor: pressed
											? theme.colors.primaryLight
											: undefined,
										transform: [{ scale: pressed ? 0.96 : 1 }],
									},
								]}
							>
								<Text variant="sm" color="primary" weight="medium">
									{t("dashboard.viewAll")}
								</Text>
							</Pressable>
						</Animated.View>
					)}
				</Box>
				{hasAlerts ? (
					<Box>
						{alerts.map((alert, index) => (
							<AlertItem
								key={alert.id}
								alert={alert}
								theme={theme}
								onPress={() => onViewAlert(alert.id)}
								isLast={index === alerts.length - 1}
							/>
						))}
					</Box>
				) : (
					<Box
						alignCenter
						paddingVertical="lg"
						paddingHorizontal="md"
						bg="backgroundAlt"
						style={{
							borderBottomLeftRadius: theme.radius.lg,
							borderBottomRightRadius: theme.radius.lg,
						}}
					>
						<Box
							rounded="round"
							bg="primaryLight"
							padding="md"
							marginBottom="md"
							style={{
								width: theme.sizes.avatarLg,
								height: theme.sizes.avatarLg,
								alignItems: "center",
								justifyContent: "center",
							}}
						>
							<Ionicons
								name="checkmark-circle"
								size={theme.sizes.iconMd}
								color={theme.colors.primary}
							/>
						</Box>
						<Text color="textSecondary" center>
							{t("dashboard.allCaughtUp")}
						</Text>
						<Text color="textMuted" variant="sm" center marginTop="xs">
							{t("dashboard.noAlerts")}
						</Text>
					</Box>
				)}
			</AnimatedBox>
		);
	},
);
interface AlertItemProps {
	alert: Alert;
	theme: AppTheme;
	onPress: () => void;
	isLast?: boolean;
}
const AlertItem: React.FC<AlertItemProps> = React.memo(
	({ alert, theme, onPress, isLast = false }) => {
		const iconColor = theme.colors[alert.type];
		const { isRTL } = useTranslation();
		const pressed = useSharedValue(0);
		const handlePressIn = () => {
			pressed.value = withTiming(1, { duration: 100 });
		};
		const handlePressOut = () => {
			pressed.value = withTiming(0, { duration: 200 });
		};
		const animatedStyle = useAnimatedStyle(() => {
			return {
				transform: [
					{
						scale: withTiming(pressed.value === 1 ? 0.98 : 1, {
							duration: pressed.value === 1 ? 50 : 200,
						}),
					},
				],
				opacity: withTiming(pressed.value === 1 ? 0.5 : 1, {
					duration: pressed.value === 1 ? 50 : 200,
				}),
			};
		});
		return (
			<Animated.View
				style={[
					{
						borderBottomWidth: isLast ? 0 : StyleSheet.hairlineWidth,
						borderBottomColor: theme.colors.divider,
					},
					animatedStyle,
				]}
			>
				<Pressable
					onPress={onPress}
					onPressIn={handlePressIn}
					onPressOut={handlePressOut}
					style={{
						flexDirection: "row",
						alignItems: "center",
						padding: theme.spacing.md,
					}}
					android_ripple={{ color: theme.colors.overlay }}
				>
					<View
						style={{
							width: theme.sizes.buttonSm,
							height: theme.sizes.buttonSm,
							borderRadius: theme.radius.round,
							alignItems: "center",
							justifyContent: "center",
							backgroundColor: theme.colors.primaryLight,
							marginStart: theme.spacing.sm,
						}}
					>
						<Ionicons
							name={alert.icon as any}
							size={theme.sizes.iconSm}
							color={iconColor}
						/>
					</View>
					<Box
						flex={1}
						marginStart={"sm"}
						gap={theme.spacing.xs / 2}
						alignItems="flex-start"
					>
						<Text variant="sm" weight="medium" numberOfLines={1}>
							{alert.title}
						</Text>
						{alert.timestamp && (
							<Text variant="xs" color="textMuted">
								{alert.timestamp}
							</Text>
						)}
					</Box>
					<Box
						marginStart={"sm"}
						paddingVertical="xs"
						paddingHorizontal="sm"
						rounded="xs"
						bg="backgroundAlt"
					>
						<Text
							variant="xs"
							weight="medium"
							color={alert.type}
							numberOfLines={1}
						>
							{alert.type.charAt(0).toUpperCase() + alert.type.slice(1)}
						</Text>
					</Box>
					<Ionicons
						name={isRTL ? "chevron-back" : "chevron-forward"}
						size={theme.sizes.iconSm}
						color={theme.colors.textMuted}
						style={{ marginStart: theme.spacing.sm }}
					/>
				</Pressable>
			</Animated.View>
		);
	},
);
</file>

<file path="apps/merchant-app/components/dashboard/PrepCard.tsx">
import React, { useCallback } from "react";
import { Pressable } from "react-native";
import { Ionicons } from "@expo/vector-icons";
import Animated, {
	useSharedValue,
	useAnimatedStyle,
	withTiming,
	interpolate,
	Extrapolation,
} from "react-native-reanimated";
import * as Haptics from "expo-haptics";
import { Box, Text, Badge } from "@/components/ui";
import { AppTheme } from "@/hooks/useTheme";
import { MealPrepSummary } from "@/types";
import { useTranslation } from "@/hooks/useTranslation";
interface TodayPrepCardProps {
	summary: MealPrepSummary;
	theme: AppTheme;
	onPress: () => void;
}
const MAX_MEALS_TO_SHOW = 3;
const PREP_CARD_WIDTH = 180;
const AnimatedPressable = Animated.createAnimatedComponent(Pressable);
export const TodayPrepCard: React.FC<TodayPrepCardProps> = React.memo(
	({ summary, theme, onPress }) => {
		const { t } = useTranslation();
		const pressed = useSharedValue(0);
		const hovered = useSharedValue(0);
		const periodIcons = {
			Breakfast: "cafe-outline",
			Lunch: "restaurant-outline",
			Dinner: "fast-food-outline",
		};
		const periodColors: Record<
			"Breakfast" | "Lunch" | "Dinner",
			"info" | "primary" | "error"
		> = { Breakfast: "info", Lunch: "primary", Dinner: "error" };
		const translatedPeriod = t(`periods.${summary.period.toLowerCase()}`);
		const handlePressIn = useCallback(() => {
			Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
			pressed.value = withTiming(1, { duration: 100 });
		}, []);
		const handlePressOut = useCallback(() => {
			pressed.value = withTiming(0, { duration: 200 });
		}, []);
		const handleHoverIn = useCallback(() => {
			hovered.value = withTiming(1, { duration: 300 });
		}, []);
		const handleHoverOut = useCallback(() => {
			hovered.value = withTiming(0, { duration: 300 });
		}, []);
		const handlePress = useCallback(() => {
			Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
			onPress();
		}, [onPress]);
		const animatedCardStyle = useAnimatedStyle(() => {
			const scale = interpolate(
				pressed.value,
				[0, 1],
				[1, 0.95],
				Extrapolation.CLAMP,
			);
			const opacity = interpolate(
				pressed.value,
				[0, 1],
				[1, 0.5],
				Extrapolation.CLAMP,
			);
			const translateY = interpolate(
				pressed.value,
				[0, 1],
				[0, 2],
				Extrapolation.CLAMP,
			);
			return {
				transform: [{ scale }, { translateY }],
				opacity,
			};
		});
		return (
			<AnimatedPressable
				onPress={handlePress}
				onPressIn={handlePressIn}
				onPressOut={handlePressOut}
				onHoverIn={handleHoverIn}
				onHoverOut={handleHoverOut}
				style={[
					{
						width: PREP_CARD_WIDTH,
						margin: theme.spacing.xs / 2,
						borderRadius: theme.radius.lg,
					},
					animatedCardStyle,
				]}
			>
				<Box
					card
					rounded="lg"
					padding="md"
					elevation="small"
					style={{
						minHeight: theme.sizes.buttonLg * 4,
					}}
				>
					<Box row alignCenter marginBottom="sm">
						<Ionicons
							name={periodIcons[summary.period] as any}
							size={theme.sizes.iconSm}
							color={theme.colors[periodColors[summary.period]]}
							style={{ marginEnd: theme.spacing.sm }}
						/>
						<Text variant="md" weight="semibold">
							{translatedPeriod}
						</Text>
					</Box>
					<Text
						variant="sm"
						weight="medium"
						color="textSecondary"
						marginBottom="xs"
						style={{ alignSelf: "flex-start" }}
					>
						{t("dashboard.prepList")}
					</Text>
					<Box marginTop="xs" flex={1} gap={"sm"}>
						{summary.mealsToPrep.slice(0, MAX_MEALS_TO_SHOW).map((meal) => (
							<Box
								key={meal.id}
								row
								justifyContent="space-between"
								paddingVertical={theme.spacing.xs / 1.5}
							>
								<Text
									variant="sm"
									numberOfLines={1}
									style={{
										flexShrink: 1,
										marginEnd: theme.spacing.sm,
									}}
								>
									{meal.name}
								</Text>
								<Text variant="sm" weight="medium" color="textSecondary">
									{meal.count}
								</Text>
							</Box>
						))}
					</Box>
					<Box
						row
						justifyContent="space-between"
						alignItems="flex-end"
						paddingTop="sm"
					>
						<Badge
							text={`${summary.totalMeals} ${t("common.total")}`}
							variant={periodColors[summary.period]}
							size="sm"
						/>
					</Box>
				</Box>
			</AnimatedPressable>
		);
	},
);
</file>

<file path="apps/merchant-app/components/ui/Text.tsx">
import {
	ColorToken,
	FontSizeVariant,
	FontWeightVariant,
	SpacingToken,
	useTheme,
} from "@/hooks/useTheme";
import React, { memo } from "react";
import {
	Text as RNText,
	TextProps as RNTextProps,
	StyleProp,
	TextStyle,
} from "react-native";
interface TextProps extends RNTextProps {
	variant?: FontSizeVariant;
	weight?: FontWeightVariant;
	color?: ColorToken | string;
	center?: boolean;
	muted?: boolean;
	marginBottom?: SpacingToken | number;
	marginTop?: SpacingToken | number;
	marginStart?: SpacingToken | number;
	marginEnd?: SpacingToken | number;
	marginHorizontal?: SpacingToken | number;
	marginVertical?: SpacingToken | number;
	margin?: SpacingToken | number;
	paddingStart?: SpacingToken | number;
	paddingEnd?: SpacingToken | number;
	paddingHorizontal?: SpacingToken | number;
	paddingVertical?: SpacingToken | number;
	paddingTop?: SpacingToken | number;
	paddingBottom?: SpacingToken | number;
	padding?: SpacingToken | number;
	style?: StyleProp<TextStyle>;
	align?: TextStyle["textAlign"];
}
export const Text: React.FC<TextProps> = memo(
	({
		children,
		variant = "md",
		weight = "regular",
		color,
		center,
		muted,
		marginBottom,
		marginTop,
		marginStart,
		marginEnd,
		marginHorizontal,
		marginVertical,
		margin,
		paddingStart,
		paddingEnd,
		paddingHorizontal,
		paddingVertical,
		paddingTop,
		paddingBottom,
		padding,
		style,
		align,
		...props
	}) => {
		const theme = useTheme();
		const getSpacingValue = (
			value: SpacingToken | number | undefined,
		): number | undefined => {
			if (value === undefined) return undefined;
			return typeof value === "number" ? value : theme.spacing[value];
		};
		const getColorValue = (
			colorProp: ColorToken | string | undefined,
		): string => {
			if (colorProp === undefined) {
				return muted ? theme.colors.textSecondary : theme.colors.text;
			}
			if (typeof colorProp === "string" && colorProp in theme.colors) {
				return theme.colors[colorProp as ColorToken];
			}
			return colorProp;
		};
		const textAlign = center ? "center" : align;
		const textStyle: TextStyle = {
			fontSize: theme.typography.sizes[variant],
			fontWeight: theme.typography.weights[weight],
			color: getColorValue(color),
			textAlign,
			marginBottom: getSpacingValue(marginBottom),
			marginTop: getSpacingValue(marginTop),
			marginStart: getSpacingValue(marginStart),
			marginEnd: getSpacingValue(marginEnd),
			marginHorizontal: getSpacingValue(marginHorizontal),
			marginVertical: getSpacingValue(marginVertical),
			margin: getSpacingValue(margin),
			paddingStart: getSpacingValue(paddingStart),
			paddingEnd: getSpacingValue(paddingEnd),
			paddingHorizontal: getSpacingValue(paddingHorizontal),
			paddingVertical: getSpacingValue(paddingVertical),
			paddingTop: getSpacingValue(paddingTop),
			paddingBottom: getSpacingValue(paddingBottom),
			padding: getSpacingValue(padding),
		};
		return (
			<RNText style={[textStyle, style]} {...props}>
				{children}
			</RNText>
		);
	},
);
export default Text;
</file>

<file path="apps/merchant-app/constants/theme.ts">
import { Platform } from "react-native";
import { DefaultTheme } from "@react-navigation/native";
const colorPalette = {
	primary: {
		50: "#EBFFF9",
		100: "#C3FFF0",
		200: "#9BFFE6",
		300: "#5FF6D8",
		400: "#22E5C8",
		500: "#0AC5AB",
		600: "#09A98F",
		700: "#07866F",
		800: "#056952",
		900: "#034C3A",
	},
	secondary: {
		50: "#F2EFFF",
		100: "#E4DFFF",
		200: "#CABFFF",
		300: "#A799FF",
		400: "#8E7AFF",
		500: "#7559FF",
		600: "#6038FF",
		700: "#4E1AFF",
		800: "#3C00FB",
		900: "#2F00C2",
	},
	neutral: {
		0: "#FFFFFF",
		50: "#F9FAFB",
		100: "#F1F5F9",
		200: "#E2E8F0",
		300: "#CBD5E1",
		400: "#94A3B8",
		500: "#64748B",
		600: "#475569",
		700: "#334155",
		800: "#1E293B",
		900: "#0F172A",
		950: "#0A0D14",
		1000: "#000000",
	},
	semantic: {
		success: "#22C55E",
		warning: "#FFBE0B",
		info: "#3B82F6",
		error: "#FF5E5B",
	},
};
const getRgba = (hex: string, alpha: number) => {
	const r = Number.parseInt(hex.slice(1, 3), 16);
	const g = Number.parseInt(hex.slice(3, 5), 16);
	const b = Number.parseInt(hex.slice(5, 7), 16);
	return `rgba(${r}, ${g}, ${b}, ${alpha})`;
};
export const theme = {
	colors: {
		light: {
			primary: colorPalette.primary[500],
			primaryDark: colorPalette.primary[600],
			primaryLight: getRgba(colorPalette.primary[500], 0.1),
			secondary: colorPalette.secondary[500],
			secondaryLight: getRgba(colorPalette.secondary[500], 0.1),
			background: colorPalette.neutral[50],
			backgroundAlt: colorPalette.neutral[100],
			card: colorPalette.neutral[0],
			cardAlt: colorPalette.neutral[100],
			text: colorPalette.neutral[900],
			textSecondary: colorPalette.neutral[600],
			textMuted: colorPalette.neutral[400],
			success: colorPalette.semantic.success,
			warning: colorPalette.semantic.warning,
			info: colorPalette.semantic.info,
			error: colorPalette.semantic.error,
			divider: colorPalette.neutral[200],
			overlay: getRgba(colorPalette.neutral[950], 0.3),
			shadow: getRgba(colorPalette.neutral[900], 0.08),
			tabBar: colorPalette.neutral[0],
			tabIconDefault: colorPalette.neutral[400],
			tabIconSelected: colorPalette.primary[500],
		},
		dark: {
			primary: colorPalette.primary[400],
			primaryDark: colorPalette.primary[500],
			primaryLight: getRgba(colorPalette.primary[400], 0.15),
			secondary: colorPalette.secondary[400],
			secondaryLight: getRgba(colorPalette.secondary[400], 0.15),
			background: colorPalette.neutral[950],
			backgroundAlt: colorPalette.neutral[800],
			card: colorPalette.neutral[900],
			cardAlt: colorPalette.neutral[800],
			text: colorPalette.neutral[50],
			textSecondary: colorPalette.neutral[300],
			textMuted: colorPalette.neutral[500],
			success: colorPalette.semantic.success,
			warning: colorPalette.semantic.warning,
			info: colorPalette.semantic.info,
			error: colorPalette.semantic.error,
			divider: getRgba(colorPalette.neutral[0], 0.1),
			overlay: getRgba(colorPalette.neutral[950], 0.6),
			shadow: getRgba(colorPalette.neutral[1000], 0.3),
			tabBar: colorPalette.neutral[900],
			tabIconDefault: colorPalette.neutral[500],
			tabIconSelected: colorPalette.primary[400],
		},
	},
	spacing: {
		none: 0,
		xs: 4,
		sm: 8,
		md: 16,
		lg: 24,
		xl: 32,
		xxl: 48,
		screenPadding: 16,
		cardPadding: 16,
		itemSpacing: 12,
		sectionSpacing: 24,
	} as const,
	radius: {
		none: 0,
		xs: 4,
		sm: 8,
		md: 12,
		lg: 16,
		xl: 24,
		round: 999,
		button: 12,
		card: 16,
		input: 12,
		badge: 12,
	} as const,
	sizes: {
		touchTarget: 44,
		smallTouchTarget: 36,
		iconXs: 16,
		iconSm: 20,
		iconMd: 24,
		iconLg: 32,
		buttonSm: 36,
		buttonMd: 44,
		buttonLg: 52,
		inputHeight: 48,
		headerHeight: 56,
		tabBarHeight: 49,
		avatarSm: 32,
		avatarMd: 44,
		avatarLg: 64,
	} as const,
	typography: {
		sizes: {
			xs: 12,
			sm: 14,
			md: 16,
			lg: 18,
			xl: 20,
			xxl: 24,
			xxxl: 30,
		} as const,
		weights: {
			regular: "400",
			medium: "500",
			semibold: "600",
			bold: "700",
			extrabold: "800",
		} as const,
		lineHeights: {
			tight: 1.2,
			normal: 1.5,
			loose: 1.8,
		} as const,
	} as const,
	shadows: {
		small: {
			shadowOffset: { width: 0, height: 1 },
			shadowOpacity: 0.8,
			shadowRadius: 2,
			elevation: 2,
		},
		medium: {
			shadowOffset: { width: 0, height: 2 },
			shadowOpacity: 0.8,
			shadowRadius: 4,
			elevation: 4,
		},
		large: {
			shadowOffset: { width: 0, height: 4 },
			shadowOpacity: 0.8,
			shadowRadius: 8,
			elevation: 8,
		},
	},
	platform: {
		topInset: Platform.OS === "ios" ? (DefaultTheme.dark ? 44 : 50) : 16,
		bottomInset: Platform.OS === "ios" ? 34 : 16,
		isIOS: Platform.OS === "ios",
		isAndroid: Platform.OS === "android",
	},
};
export type ThemeColors = typeof theme.colors.light;
export type ThemeMode = "light" | "dark";
</file>

<file path="apps/merchant-app/components/dashboard/DashboardHeader.tsx">
import { AnimatedBox, Text } from "@/components/ui";
import { AppTheme } from "@/hooks/useTheme";
import React, { memo } from "react";
import { EdgeInsets } from "react-native-safe-area-context";
interface DashboardHeaderProps {
	theme: AppTheme;
	insets: EdgeInsets;
	animatedStyle: any;
	currentDateString: string;
	onSettingsPress: () => void;
	headerHeight: number;
}
export const DashboardHeader: React.FC<DashboardHeaderProps> = memo(
	({
		theme,
		insets,
		animatedStyle,
		currentDateString,
		onSettingsPress,
		headerHeight,
	}) => {
		return (
			<AnimatedBox
				row
				alignItems="center"
				paddingHorizontal="md"
				paddingVertical="sm"
				style={[
					{
						height: theme.sizes.headerHeight,
					},
					animatedStyle,
				]}
			>
				<Text variant="xl" weight="semibold" numberOfLines={1}>
					{currentDateString}
				</Text>
			</AnimatedBox>
		);
	},
);
</file>

<file path="apps/merchant-app/components/dashboard/StatsGrid.tsx">
import { AnimatedBox, Box, Text } from "@/components/ui";
import { AppTheme } from "@/hooks/useTheme";
import { Ionicons } from "@expo/vector-icons";
import React from "react";
import {
	FadeInUp,
	FadeOutDown,
	LinearTransition,
} from "react-native-reanimated";
interface StatItem {
	title: string;
	value: string | number;
	icon: string;
}
interface StatsGridProps {
	stats: StatItem[];
	theme: AppTheme;
}
export const StatsGrid: React.FC<StatsGridProps> = React.memo(
	({ stats, theme }) => {
		return (
			<AnimatedBox
				layout={LinearTransition.delay(100).duration(300)}
				row
				marginHorizontal="sm"
				marginBottom="lg"
				gap={"sm"}
			>
				{stats.map((stat) => (
					<AnimatedBox
						key={stat.title}
						entering={FadeInUp.duration(300)}
						exiting={FadeOutDown.duration(200)}
						layout={LinearTransition.duration(300)}
						flex={1}
					>
						<Box bg="card" padding="md" rounded="lg" elevation="small">
							<Box row alignCenter marginBottom="sm" gap={"sm"}>
								<Box
									width={theme.sizes.buttonSm}
									height={theme.sizes.buttonSm}
									alignItems="center"
									justifyContent="center"
									rounded={"sm"}
									bg="primaryLight"
								>
									<Ionicons
										name={stat.icon as any}
										size={theme.sizes.iconSm}
										color={theme.colors.primary}
									/>
								</Box>
								<Text variant="xs" weight="semibold" color="textSecondary">
									{stat.title}
								</Text>
							</Box>
							<Text variant="xl" weight="bold">
								{stat.value}
							</Text>
						</Box>
					</AnimatedBox>
				))}
			</AnimatedBox>
		);
	},
);
</file>

<file path="apps/merchant-app/components/ui/Box.tsx">
import { useTheme } from "@/hooks/useTheme";
import { ColorToken, RadiusToken, SpacingToken } from "@/hooks/useTheme";
import React, { memo } from "react";
import {
	DimensionValue,
	FlexAlignType,
	Pressable,
	StyleProp,
	View,
	ViewProps,
	ViewStyle,
} from "react-native";
import Animated from "react-native-reanimated";
type JustifyContentType =
	| "flex-start"
	| "flex-end"
	| "center"
	| "space-between"
	| "space-around"
	| "space-evenly";
interface BoxProps extends ViewProps {
	flex?: number;
	row?: boolean;
	center?: boolean;
	alignCenter?: boolean;
	alignItems?: FlexAlignType;
	justifyCenter?: boolean;
	justifyContent?: JustifyContentType;
	card?: boolean;
	padding?: SpacingToken | number;
	gap?: SpacingToken | number;
	margin?: SpacingToken | number;
	marginTop?: SpacingToken | number;
	marginBottom?: SpacingToken | number;
	marginStart?: SpacingToken | number;
	marginEnd?: SpacingToken | number;
	marginHorizontal?: SpacingToken | number;
	marginVertical?: SpacingToken | number;
	paddingHorizontal?: SpacingToken | number;
	paddingBottom?: SpacingToken | number;
	paddingTop?: SpacingToken | number;
	paddingVertical?: SpacingToken | number;
	paddingStart?: SpacingToken | number;
	paddingEnd?: SpacingToken | number;
	rounded?: RadiusToken | number;
	width?: DimensionValue;
	height?: DimensionValue;
	borderWidth?: number;
	borderColor?: ColorToken;
	bg?: ColorToken | string;
	elevation?: "none" | "small" | "medium" | "large";
	style?: StyleProp<ViewStyle>;
	onPress?: () => void;
	activeOpacity?: number;
}
export const Box: React.FC<BoxProps> = memo(
	({
		children,
		flex,
		row,
		gap,
		center,
		alignCenter,
		paddingTop,
		alignItems,
		paddingBottom,
		justifyCenter,
		justifyContent,
		card,
		padding,
		margin,
		marginTop,
		marginBottom,
		marginStart,
		marginEnd,
		marginHorizontal,
		marginVertical,
		paddingHorizontal,
		paddingVertical,
		paddingStart,
		paddingEnd,
		rounded,
		width,
		height,
		borderWidth,
		borderColor,
		bg,
		elevation,
		style,
		onPress,
		activeOpacity = 0.7,
		...props
	}) => {
		const theme = useTheme();
		let finalAlignItems: FlexAlignType | undefined;
		let finalJustifyContent: JustifyContentType | undefined;
		if (center) {
			finalAlignItems = "center";
			finalJustifyContent = "center";
		} else {
			finalAlignItems = alignCenter ? "center" : alignItems;
			finalJustifyContent = justifyCenter ? "center" : justifyContent;
		}
		const getSpacingValue = (
			value: SpacingToken | number | undefined,
		): number | undefined => {
			if (value === undefined) return undefined;
			return typeof value === "number" ? value : theme.spacing[value];
		};
		const getRadiusValue = (
			value: RadiusToken | number | undefined,
		): number | undefined => {
			if (value === undefined) return undefined;
			return typeof value === "number" ? value : theme.radius[value];
		};
		const getColorValue = (
			color: ColorToken | string | undefined,
		): string | undefined => {
			if (color === undefined) return undefined;
			if (typeof color === "string" && color in theme.colors) {
				return theme.colors[color as ColorToken];
			}
			return color;
		};
		const getElevation = (level?: "none" | "small" | "medium" | "large") => {
			if (!level || level === "none") return {};
			const shadowStyle = theme.shadows[level];
			return { ...shadowStyle, shadowColor: theme.colors.shadow };
		};
		const boxStyle: ViewStyle = {
			flex,
			flexDirection: row ? "row" : "column",
			alignItems: finalAlignItems,
			justifyContent: finalJustifyContent,
			padding: getSpacingValue(padding),
			margin: getSpacingValue(margin),
			marginTop: getSpacingValue(marginTop),
			marginBottom: getSpacingValue(marginBottom),
			marginStart: getSpacingValue(marginStart),
			marginEnd: getSpacingValue(marginEnd),
			marginHorizontal: getSpacingValue(marginHorizontal),
			marginVertical: getSpacingValue(marginVertical),
			paddingHorizontal: getSpacingValue(paddingHorizontal),
			paddingVertical: getSpacingValue(paddingVertical),
			gap: getSpacingValue(gap),
			paddingTop: getSpacingValue(paddingTop),
			paddingBottom: getSpacingValue(paddingBottom),
			paddingStart: getSpacingValue(paddingStart),
			paddingEnd: getSpacingValue(paddingEnd),
			borderRadius: getRadiusValue(rounded),
			width,
			height,
			borderWidth,
			borderColor: getColorValue(borderColor),
			backgroundColor: card ? theme.colors.card : getColorValue(bg),
			...(card ? getElevation("small") : {}),
			...(elevation ? getElevation(elevation) : {}),
		};
		if (onPress) {
			return (
				<Pressable
					onPress={onPress}
					style={({ pressed }) => [
						boxStyle,
						{ opacity: pressed ? activeOpacity : 1 },
						style,
					]}
					{...props}
					android_ripple={{ color: theme.colors.overlay }}
				>
					{children}
				</Pressable>
			);
		}
		return (
			<View style={[boxStyle, style]} {...props}>
				{children}
			</View>
		);
	},
);
export default Box;
export const AnimatedBox = Animated.createAnimatedComponent(Box);
</file>

<file path="apps/merchant-app/components/ui/Tabs.tsx">
import React from "react";
import { Pressable } from "react-native";
import { Box } from "./Box";
import { Text } from "./Text";
import { AppTheme } from "@/hooks/useTheme";
import * as Haptics from "expo-haptics";
import { Ionicons } from "@expo/vector-icons";
type TabItem = {
	key: string;
	label: string;
	iconLeft?: string;
	iconRight?: string;
};
export type TabType = string | TabItem;
interface TabsProps {
	tabs: TabType[];
	selectedTab: string;
	onSelectTab: (tab: string) => void;
	theme: AppTheme;
	labelRender?: (tab: string) => string;
}
export const Tabs: React.FC<TabsProps> = React.memo(
	({ tabs, selectedTab, onSelectTab, theme, labelRender }) => {
		const handlePress = (tab: TabType) => {
			const tabKey = typeof tab === "string" ? tab : tab.key;
			if (tabKey !== selectedTab) {
				Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
				onSelectTab(tabKey);
			}
		};
		const getTabLabel = (tab: TabType): string => {
			if (typeof tab === "string") {
				return labelRender ? labelRender(tab) : tab;
			}
			return tab.label;
		};
		const isTabSelected = (tab: TabType): boolean => {
			const tabKey = typeof tab === "string" ? tab : tab.key;
			return tabKey === selectedTab;
		};
		return (
			<Box row bg={theme.colors.backgroundAlt} rounded={"md"} padding={"xs"}>
				{tabs.map((tab) => {
					const isSelected = isTabSelected(tab);
					const tabKey = typeof tab === "string" ? tab : tab.key;
					return (
						<Pressable
							key={tabKey}
							style={({ pressed }) => [
								{
									flex: 1,
									paddingVertical: 8,
									paddingHorizontal: 12,
									alignItems: "center",
									justifyContent: "center",
									flexDirection: "row",
									borderRadius: theme.radius.sm,
								},
								isSelected && {
									backgroundColor: theme.colors.card,
									shadowOffset: { width: 0, height: 1 },
									shadowOpacity: 0.1,
									shadowRadius: 2,
									elevation: 2,
									shadowColor: theme.colors.shadow,
								},
								pressed && { opacity: 0.5 },
							]}
							onPress={() => handlePress(tab)}
							android_ripple={{ color: theme.colors.overlay, borderless: true }}
						>
							{}
							{typeof tab !== "string" && tab.iconLeft && (
								<Ionicons
									name={tab.iconLeft as any}
									size={theme.sizes.iconSm}
									color={
										isSelected
											? theme.colors.primary
											: theme.colors.textSecondary
									}
									style={{ marginRight: theme.spacing.xs }}
								/>
							)}
							{}
							<Text
								variant="sm"
								weight={isSelected ? "semibold" : "medium"}
								color={isSelected ? "primary" : "textSecondary"}
							>
								{getTabLabel(tab)}
							</Text>
							{}
							{typeof tab !== "string" && tab.iconRight && (
								<Ionicons
									name={tab.iconRight as any}
									size={theme.sizes.iconSm}
									color={
										isSelected
											? theme.colors.primary
											: theme.colors.textSecondary
									}
									style={{ marginLeft: theme.spacing.xs }}
								/>
							)}
						</Pressable>
					);
				})}
			</Box>
		);
	},
);
</file>

<file path="apps/merchant-app/constants/i18n.ts">
export const translations = {
	en: {
		common: {
			settings: "Settings",
			dashboard: "Dashboard",
			meals: "Meals",
			cancel: "Cancel",
			save: "Save",
			delete: "Delete",
			edit: "Edit",
			loading: "Loading...",
			total: "Total",
			more: "more",
			back: "Back",
			version: "Version",
		},
		search: {
			title: "Search",
			placeholder: "Search...",
			noResults: "No results found for",
			recentSearches: "Recent Searches",
			clear: "Clear",
		},
		settings: {
			title: "Settings",
			language: "Language",
			theme: "Appearance",
			notifications: "Notifications",
			about: "About",
			logout: "Logout",
			lightMode: "Light",
			darkMode: "Dark",
			systemTheme: "System",
			signedInAs: "Signed in as",
			appInfo: "App Information",
		},
		dashboard: {
			title: "Dashboard",
			todaysPrep: "Today's Prep",
			activeSubscriptions: "Active Subs",
			newThisWeek: "New This Week",
			newThisMonth: "New This Month",
			mealsToday: "Meals Today",
			alerts: "Alerts",
			viewAll: "View all",
			allCaughtUp: "You're all caught up!",
			noAlerts: "No pressing alerts at the moment",
			prepList: "Prep List:",
			today: "Today",
			week: "Week",
			month: "Month",
		},
		meals: {
			title: "Meal Management",
			addNew: "Add New Meal",
			noMeals: "No meals found",
			addFirstMeal: "Add your first meal to get started",
			mealName: "Meal Name",
			description: "Description",
			price: "Price ($)",
			calories: "Calories",
			prepTime: "Prep Time (min)",
			ingredients: "Ingredients (comma separated)",
			mealPeriod: "Meal Period",
			createMeal: "Create Meal",
			saveChanges: "Save Changes",
			confirmDelete: "Are you sure you want to delete this meal?",
			basicInfo: "Basic Information",
			details: "Details",
			available: "Available",
			unavailable: "Unavailable",
			availableDesc: "This meal is visible to customers",
			unavailableDesc: "This meal is hidden from customers",
			featured: "Featured Meal",
			featuredDesc: "Show this meal in featured sections",
			dangerZone: "Danger Zone",
			deleteMealWarning: "Once deleted, this meal cannot be recovered.",
			addImage: "Add Image",
		},
		periods: {
			breakfast: "Breakfast",
			lunch: "Lunch",
			dinner: "Dinner",
		},
		alerts: {
			warning: "Warning",
			info: "Info",
			error: "Error",
		},
	},
	ar: {
		common: {
			settings: "الإعدادات",
			dashboard: "لوحة التحكم",
			meals: "الوجبات",
			cancel: "إلغاء",
			save: "حفظ",
			delete: "حذف",
			edit: "تعديل",
			loading: "جاري التحميل...",
			total: "المجموع",
			more: "المزيد",
			back: "رجوع",
			version: "الإصدار",
		},
		search: {
			title: "بحث",
			placeholder: "بحث...",
			noResults: "لا توجد نتائج لـ",
			recentSearches: "عمليات البحث الأخيرة",
			clear: "مسح",
		},
		settings: {
			title: "الإعدادات",
			language: "اللغة",
			theme: "المظهر",
			notifications: "الإشعارات",
			about: "حول",
			logout: "تسجيل الخروج",
			lightMode: "فاتح",
			darkMode: "داكن",
			systemTheme: "النظام",
			signedInAs: "مسجل الدخول كـ",
			appInfo: "معلومات التطبيق",
		},
		dashboard: {
			title: "لوحة التحكم",
			todaysPrep: "تحضير اليوم",
			activeSubscriptions: "الاشتراكات النشطة",
			newThisWeek: "جديد هذا الأسبوع",
			newThisMonth: "جديد هذا الشهر",
			mealsToday: "وجبات اليوم",
			alerts: "التنبيهات",
			viewAll: "عرض الكل",
			allCaughtUp: "أنت على اطلاع بكل شيء!",
			noAlerts: "لا توجد تنبيهات ملحة في الوقت الحالي",
			prepList: "قائمة التحضير:",
			today: "اليوم",
			week: "الأسبوع",
			month: "الشهر",
		},
		meals: {
			title: "إدارة الوجبات",
			addNew: "إضافة وجبة جديدة",
			noMeals: "لم يتم العثور على وجبات",
			addFirstMeal: "أضف وجبتك الأولى للبدء",
			mealName: "اسم الوجبة",
			description: "الوصف",
			price: "السعر ($)",
			calories: "السعرات الحرارية",
			prepTime: "وقت التحضير (دقيقة)",
			ingredients: "المكونات (مفصولة بفواصل)",
			mealPeriod: "فترة الوجبة",
			createMeal: "إنشاء وجبة",
			saveChanges: "حفظ التغييرات",
			confirmDelete: "هل أنت متأكد من حذف هذه الوجبة؟",
			basicInfo: "المعلومات الأساسية",
			details: "التفاصيل",
			available: "متاح",
			unavailable: "غير متاح",
			availableDesc: "هذه الوجبة مرئية للعملاء",
			unavailableDesc: "هذه الوجبة مخفية عن العملاء",
			featured: "وجبة مميزة",
			featuredDesc: "عرض هذه الوجبة في الأقسام المميزة",
			dangerZone: "منطقة الخطر",
			deleteMealWarning: "بمجرد الحذف، لا يمكن استعادة هذه الوجبة.",
			addImage: "إضافة صورة",
		},
		periods: {
			breakfast: "الإفطار",
			lunch: "الغداء",
			dinner: "العشاء",
		},
		alerts: {
			warning: "تحذير",
			info: "معلومات",
			error: "خطأ",
		},
	},
};
export type Language = keyof typeof translations;
</file>

<file path="pnpm-workspace.yaml">
packages:
  - apps/*
catalog:
  '@biomejs/biome': 1.9.4
  typescript: ~5.8.3
catalogs:
  react18:
    react: 18.3.1
    react-dom: 18.3.1
    '@types/react': ^18.3.3
    '@types/react-dom': ^18.3.0
  react-native:
    react: 19.0.0
    react-dom: 19.0.0
    react-native: 0.79.0
    '@types/react': ~19.0.10
nodeLinker: hoisted
onlyBuiltDependencies:
  - '@biomejs/biome'
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
node_modules
.pnp
.pnp.js

# testing
coverage

# next.js
.next/
out/
next-env.d.ts
#sveltekit
.svelte-kit
# nitro
.nitro/
.output/

# expo
.expo
expo-env.d.ts
ios/
android/
*.gen.ts

# production
build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# local env files
.env
.env*.local

# typescript
*.tsbuildinfo
dist/

# turbo
.turbo




# Output
.cache
.output
.vercel
/.svelte-kit
/build

# OS
.DS_Store
Thumbs.db

# Env
.env
.env.*
!.env.example
!.env.test

# Vite
vite.config.js.timestamp-*
vite.config.ts.timestamp-*
.maestro/tests/
messages.js
</file>

<file path="apps/merchant-app/app/_layout.tsx">
import { ThemeProvider } from "@react-navigation/native";
import { useFonts } from "expo-font";
import { Tabs } from "expo-router";
import * as SplashScreen from "expo-splash-screen";
import { StatusBar } from "expo-status-bar";
import { useEffect } from "react";
import "react-native-reanimated";
import { SafeAreaProvider } from "react-native-safe-area-context";
import { useTheme } from "@/hooks/useTheme";
import { Ionicons } from "@expo/vector-icons";
import { useTranslation } from "@/hooks/useTranslation";
import { LogBox } from "react-native";
LogBox.ignoreLogs([
	"Sending `onAnimatedValueUpdate` with no listeners registered.",
]);
SplashScreen.preventAutoHideAsync();
export default function RootLayout() {
	const { isDark, navTheme, colors } = useTheme();
	const { t } = useTranslation();
	const [loaded, error] = useFonts({
		SpaceMono: require("../assets/fonts/SpaceMono-Regular.ttf"),
	});
	useEffect(() => {
		if (error) throw error;
	}, [error]);
	useEffect(() => {
		if (loaded) {
			SplashScreen.hideAsync();
		}
	}, [loaded]);
	if (!loaded) {
		return null;
	}
	return (
		<SafeAreaProvider>
			<ThemeProvider value={navTheme}>
				<Tabs
					screenOptions={{
						headerShown: false,
						tabBarActiveTintColor: colors.primary,
						tabBarInactiveTintColor: colors.textMuted,
					}}
				>
					<Tabs.Screen
						name="index"
						options={{
							title: t("common.dashboard"),
							tabBarIcon: ({ color, size }) => (
								<Ionicons name="home-outline" size={size} color={color} />
							),
						}}
					/>
					<Tabs.Screen
						name="meals"
						options={{
							title: t("common.meals"),
							tabBarIcon: ({ color, size }) => (
								<Ionicons name="restaurant-outline" size={size} color={color} />
							),
						}}
					/>
					<Tabs.Screen
						name="settings"
						options={{
							title: t("common.settings"),
							tabBarIcon: ({ color, size }) => (
								<Ionicons name="settings-outline" size={size} color={color} />
							),
						}}
					/>
				</Tabs>
				<StatusBar style={isDark ? "light" : "dark"} />
			</ThemeProvider>
		</SafeAreaProvider>
	);
}
</file>

<file path="apps/merchant-app/app/index.tsx">
import { AlertsCard } from "@/components/dashboard/AlertsCard";
import { TodayPrepCard } from "@/components/dashboard/PrepCard";
import { StatsGrid } from "@/components/dashboard/StatsGrid";
import { AnimatedBox, Box } from "@/components/ui";
import { Tabs } from "@/components/ui/Tabs";
import { Text } from "@/components/ui/Text";
import { ALERTS, TODAY_PREP_SUMMARY } from "@/data";
import { useTheme } from "@/hooks/useTheme";
import { useTranslation } from "@/hooks/useTranslation";
import * as Haptics from "expo-haptics";
import React, { useState, useCallback, useMemo } from "react";
import { FlatList, View, ScrollView } from "react-native";
import Animated, { FadeInUp } from "react-native-reanimated";
import { useSafeAreaInsets } from "react-native-safe-area-context";
const PREP_CARD_WIDTH = 170;
const HomeScreen: React.FC = () => {
	const theme = useTheme();
	const insets = useSafeAreaInsets();
	const { t, language } = useTranslation();
	const [selectedTab, setSelectedTab] = useState("Today");
	const tabItems = useMemo(() => {
		return ["Today", "Week", "Month"];
	}, [t]);
	const currentStats = useMemo(() => {
		switch (selectedTab) {
			case "Week":
				return [
					{
						title: t("dashboard.newThisWeek"),
						value: 52,
						icon: "people-outline",
					},
					{
						title: t("dashboard.newThisMonth"),
						value: "+3",
						icon: "add-circle-outline",
					},
				];
			case "Month":
				return [
					{
						title: t("dashboard.newThisWeek"),
						value: 52,
						icon: "people-outline",
					},
					{
						title: t("dashboard.newThisMonth"),
						value: "+12",
						icon: "add-circle-outline",
					},
				];
			default:
				return [
					{
						title: t("dashboard.newThisWeek"),
						value: 52,
						icon: "people-outline",
					},
					{
						title: t("dashboard.newThisMonth"),
						value: "+12",
						icon: "add-circle-outline",
					},
				];
		}
	}, [selectedTab]);
	const currentDateString = useMemo(
		() =>
			new Date().toLocaleDateString(language, {
				weekday: "long",
				month: "short",
				day: "numeric",
			}),
		[],
	);
	const handleSelectTab = useCallback(
		(tab: string) => {
			if (tab !== selectedTab) {
				Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
				setSelectedTab(tab);
			}
		},
		[selectedTab],
	);
	const handleViewSchedule = useCallback((period?: string) => {
		console.log("Navigate to Schedule Screen, Filter:", period || "Full");
	}, []);
	const handleViewAlert = useCallback((id: string | number) => {
		console.log("Navigate to Alert Details Screen, ID:", id);
	}, []);
	const handleViewAllAlerts = useCallback(() => {
		console.log("Navigate to All Alerts Screen");
	}, []);
	return (
		<View
			style={{
				flex: 1,
				backgroundColor: theme.colors.background,
				paddingTop: insets.top,
			}}
		>
			<ScrollView
				contentContainerStyle={{
					paddingBottom: theme.spacing.md,
				}}
				showsVerticalScrollIndicator={false}
			>
				<Box
					row
					alignItems="center"
					paddingHorizontal="md"
					paddingVertical="sm"
					style={{
						height: theme.sizes.headerHeight,
					}}
				>
					<Text variant="xl" weight="semibold" numberOfLines={1}>
						{currentDateString}
					</Text>
				</Box>
				<AnimatedBox
					marginHorizontal="md"
					gap="lg"
					entering={FadeInUp.delay(50).duration(400).springify().damping(15)}
				>
					<Tabs
						tabs={tabItems}
						selectedTab={selectedTab}
						onSelectTab={handleSelectTab}
						theme={theme}
						labelRender={(tab) => t(`dashboard.${tab.toLowerCase()}`)}
					/>
					<StatsGrid stats={currentStats} theme={theme} key={selectedTab} />
				</AnimatedBox>
				<Animated.Text
					entering={FadeInUp.duration(400)}
					style={{
						fontSize: theme.typography.sizes.lg,
						fontWeight: theme.typography.weights.semibold,
						color: theme.colors.text,
						marginHorizontal: theme.spacing.md,
						marginBottom: theme.spacing.sm,
						alignSelf: "flex-start",
					}}
				>
					{t("dashboard.todaysPrep")}
				</Animated.Text>
				<Animated.View entering={FadeInUp.delay(300).duration(400).damping(15)}>
					<FlatList
						horizontal
						data={TODAY_PREP_SUMMARY}
						keyExtractor={(item) => item.period}
						showsHorizontalScrollIndicator={false}
						contentContainerStyle={[
							{
								paddingHorizontal: theme.spacing.md,
								paddingVertical: theme.spacing.sm,
								gap: theme.spacing.sm,
							},
						]}
						snapToInterval={PREP_CARD_WIDTH + theme.spacing.sm}
						decelerationRate="fast"
						renderItem={({ item }) => (
							<TodayPrepCard
								summary={item}
								theme={theme}
								onPress={() => handleViewSchedule(item.period)}
							/>
						)}
					/>
				</Animated.View>
				<AlertsCard
					alerts={ALERTS}
					theme={theme}
					onViewAlert={handleViewAlert}
					onViewAllAlerts={handleViewAllAlerts}
				/>
			</ScrollView>
		</View>
	);
};
export default HomeScreen;
</file>

</files>
